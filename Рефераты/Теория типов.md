[[Типы в языках прогарммирования.pdf]]

[Система типов в математике](https://habr.com/ru/post/347294/)

[Теория категорий позволяет математике отказаться от равенств](https://habr.com/ru/post/476372/)

[[Высшие индуктивные типы]]


## Аннотация

Мы так привыкли к типам, что редко задаёмся вопросом, что же они такое на самом деле?
А главное - **почему возникла необходимость в их использовании**?
Этот поверхностный обзор сделан для того, чтобы продемонстрировать, как типы и другие связанные абстракции являются следствием из обобщения условий различных задач.

## Предисловие

Не секрет, что программирование основывается на глубокой математической теории.
Многие ключевые понятия, которые встречаются в различных областях компьютерных наук, пришли именно из математики.
Поэтому для всех, кто хочет быть программистом, было бы здорово получить более широкое видение предмета - разобраться в самой математической основе программирования.

Но, зачастую, это возвышенное намерение наталкивается на высокий порог вхождения в высшую математику.
Основная проблема заключается в традиционных особенностях математической литературы - нарочитой оторванности от реальности, от практических задач.
Типичный математический текст начинается со знакомства со "взятой с потолка" абстракцией, и потом рассматриваются её "удивительной красоты" свойства.
И только в редких работах где-то в конце можно увидеть коротенькую заметку, что, мол, какие-то физики нашли как применить эту "красоту" для каких-то там своих нужд.

Порог вхождения снижают различные блоги, в которых рассказывается, как те или иные математические абстракции применяются для решения конкретных задач, в частности, в программировании.
Но при объяснении полезности абстракции часто упускается важный аспект - **неизбежность** появления именно этой абстракции как **наилучшего** инструмента для решения целого класса задач.
Дело в том, что сами условия обобщённой задачи приводят к появлению наилучшей абстракции для её решения.
Понимание связи абстракции с условиями задачи расширяет горизонты, позволяет в дальнейшем находить оптимальные реализации этой абстракции для каждого конкретного случая, подпадающего под указанные условия.
Именно на этот аспект сделан основной упор в этом обзоре теории типов.

Я дилетант в математике, да и в области компьютерных наук не довелось получить системных знаний. Немного печально, но я этого не стыжусь)).
Ожидаю, что знающие люди в комментариях будут посылать в правильных направлениях, но всё же надеюсь, что этот обзор приоткроет завесу тайны над типами с не самой известной стороны и окажется интересен широкому классу читателей.

## Множества и классы

### Предпосылки

С давних времён люди находили нечто общее в решаемых задачах из самых разных сфер жизни.
Например, если одна корова да ещё одна корова - это две коровы, то такое же рассуждение справедливо и для яблок.
В этом рассуждении ключевую роль играют не коровы (и, тем более, не яблоки), а [**числа**](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE) - одна из первых математических абстракций.

Более четырёх тысяч лет назад в древнем Междуречье люди [умели вычислять](https://elementy.ru/nauchno-populyarnaya_biblioteka/434752/Matematika_v_Mesopotamii) объёмы крепостных стен, площади земельных участков, динамику численности стад и проч.
Тогда на примере конкретных житейских проблем были описаны **способы вычисления**, которые применимы для широкого спектра задач, достаточно лишь заменить числа в условии.
Но лишь в средние века в Европе в обиход вошло понятие «[алгоритм](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC "Алгоритм")» (по имени [учёного IX века](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C-%D0%A5%D0%BE%D1%80%D0%B5%D0%B7%D0%BC%D0%B8)), для которого необходимо использование новой абстракции - [**переменной**](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD%D0%B0).
Алгоритм описывает, что мы должны сделать с переменными, не зависимо от того, какие значения (из некоторого **набора** возможных значений) будут **подставлены** вместо неё при решении конкретной задачи.
Таким образом, "переменная" представляет собой значение из некоторого **набора** возможных значений.

Свойства таких наборов-множеств, их взаимоотношений исследуются веками.
В XIX веке активно ищутся способы нахождения корней многочленов (см. [алгебраические замыкания](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8_%D0%B7%D0%B0%D0%BC%D0%BA%D0%BD%D1%83%D1%82%D0%BE%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B5)), для упрощения сложных задач изучается разделение множеств на классы эквивалентности (см. например, [классы вычетов](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_%D0%B2%D1%8B%D1%87%D0%B5%D1%82%D0%BE%D0%B2)) и многое другое.
Внезапно оказалось, что четкое понимание множества просто категорически необходимо в самых разных областях математики, которые развиваются зачастую независимо друг от друга узкими специалистами.
Множества представляются потенциальным фундаментом, на котором можно построить **единый способ проверки корректности любых алгоритмов**!

Ближе к XX веку в научном сообществе накопилась необходимость к формализации понятия "множество".
Это было исторически неизбежно, и не так важно, кого бы назвали первым.

### Множества

Множество определяется условием **принадлежности** к нему какого-либо элемента (которое, например, может быть другим множеством): $a\in A$.
Существует выделенное пустое множество $\emptyset$, такое что для любого $a$ утверждение $a\in\emptyset$ ложно.
Задать множество можно двумя способами:
* **экстенсионально** - просто перечислив его элементы - $\{a, b, c\}$;
* **интенсионально** - указав условие, по которому можно выбрать некоторые элементы существующего множества - $\{$*множество всех людей, кто сейчас это читает*$\}$.

Интенсионально определяются основные операции над множествами.
![[Pasted Image 20230202120411_492.png]]

Также важно понятие отношения между множествами, в частности, равенство множеств.
![[Pasted Image 20230202122008_025.png]]

### Парадоксы

Оказывается, что некоторые предикаты не позволяют определить множество.
Возникают разного рода [парадоксы](https://habr.com/ru/post/197578/):
* не существует множества всех множеств,
* не существует множества элементов, не равных самим себе,
* и т.п.
Пытаясь построить такие множества неизбежно возникают противоречия.

Вводится понятие **класса** - совокупности объектов, удовлетворяющих некому условию.
При этом, каждый класс может быть
* либо множеством,
* либо **собственным классом** ("больше" чем множество).
Термин "класс" попал и в программирование - к заданному классу принадлежат экземпляры, у которых есть все перечисленные атрибуты (члены класса).

Парадоксы сигнализируют о "дырявости" концепции, неприменимости её задачам, которые она призвана решать.
Избежать таких проблем можно с помощью [ограничений](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2#%D0%90%D0%BA%D1%81%D0%B8%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2 "Теория множеств"), запрещающих появление парадоксальных утверждений, или расширений, например, привлекая концепцию [кумулятивных вселенных](https://ru.wikipedia.org/wiki/%D0%A3%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D1%83%D0%BC_%D0%93%D1%80%D0%BE%D1%82%D0%B5%D0%BD%D0%B4%D0%B8%D0%BA%D0%B0).
Последний подход используется также в теории типов, где возникают аналогичные парадоксы (см. далее).

### Неразличимость и вычисления

Итак, множества нужны прежде всего для того, чтобы характеризовать алгоритмы-функции, отношение совокупностей входных и выходных данных для них.
![[Pasted Image 20230203101528_980.png]]
Кажется очевидным, что биекцию возможно определить только на множествах одинаковой **мощности** (см. [интересные](https://habr.com/ru/post/445398/) [посты](https://habr.com/ru/post/445904/)).
Биекция задаёт отношение эквивалентности на множествах - множества одинаковой мощности, без обогащения иными математическими структурами, попросту неразличимы!
Например, восьмибайтовая ячейка памяти может хранить в себе значения как из множества `Int64`, так и из `double`.
Эти множества имеют одинаковую мощность, но для них предоставляется **разный набор возможностей**.

(Множества одинаковой мощности образует **классы эквивалентности множеств**, которые зачастую не представляют собой множества, но мы пока договорились, что это не проблема.)

Житейский пример: мы не сможем отличить множество коров от множества яблок, если и яблоки и коровы не только выглядят, но даже пишутся одинаково))).
А если не одинаково, значит у нас есть дополнительная структура - операция отношения, которая позволяет сравнить корову с яблоком.

Рассмотрим пример ближе к программированию - обычный моноид.
Несмотря на, возможно, пугающее название, эта простая конструкция регулярно используется для свёртки разного рода списков - редуцирование списка до единственного значения.
Суммирование чисел, или конкатенация строк - частные случаи моноида.
Любая программа - это по сути список инструкций, который тоже можно собрать в единственную инструкцию с помощью подходящего моноида.
Абстрактный моноид обычно описывается так:
* некое **множество** (числа, строки...),
* бинарная операция на этом множестве (сложение, умножение чисел; конкатенация строк или вычисление самой длинной...),
* нейтральный элемент из этого множества (единица для умножения, пустая строка для конкатенации...),
* ("законы" - ассоциативность бинарной операции, и свойства нейтрального элемента).

На практике для построения алгоритмов с использованием, например, того же моноида "лишним" в его определении оказывается... множество!
В самом деле, для суммирования списка (заданы ассоциативная бинарная операция и $0$) инструкции не меняются, если в качестве множества мы выбираем `int`, `decimal` или `double` - описание алгоритма остаётся тем же!
Фактически, множество выступает всего лишь как некий ярлык - связующее звено для композиции различных возможности (структуры моноида и прочих).
Так на переднем плане появляется концепция типа.

## Типы

### Определение типа

Важно понимать, чем отличаются понятия типа и множества. [Попытки ассоциировать эти понятия](https://habr.com/ru/post/713800/) приводят к разного рода противоречиям.

Суть типа полностью определяется совокупностью отображений (функций), связывающих его с другими типами, его положением на диаграмме вида
![[Pasted Image 20230210110121_871.png]]
Т.е., буквально, чтобы определить тип нужно
* указать совокупность "входящих" отображений (также говорят "инъекторы" или "конструкторы");
* указать совокупность "исходящих" отображений (также говорят "проекторы").
На картинке выше видно, что
* если у нас есть объект типа **$A_1$, или $A_2$, то мы можем считать, что у нас есть (мы всегда можем получить) и объект типа $C$.
* с другой стороны, если у нас есть объект типа $C$, то у нас есть (мы можем получить) объекты типов **$B_1$ и $B_2$.
В математике в такой ситуации вместо "или" и "и" используют знаки $+$ и $\times$.
Таким образом тип $C$ на картинке выше можно сформулировать так:
$$A_1+A_2\equiv C \equiv B_1\times B_2.$$
Но это не точно))

Дело в том, строгое определение должно быть полным и однозначным.
Так что из всех возможных типов-претендентов называться **суммой** типов $A_1$, $A_2$, или **произведением** типов $B_1$, $B_2$, нам нужно выбрать наилучшего представителя.
Нам нужно некое **универсальное свойство**.

### Универсальное свойство

В нашем случае, мы должны гарантировать, что нет никаких $A_3$, $B_3
$ и прочих, кто ещё связан отображениями с $C$.
Но с другой стороны, например, если для $A_1$ есть отображение в $A_2$ (подтипизация), то $A_2$ вполне можно исключить из определения типа $C$.
Аналогично, среди типов $B$ также могут найтись те, кто связан с отображениями, значит там тоже кого-то можно исключить из формулировки $C$ через произведения.

Универсальное свойство какой-либо конструкции в теории типов определяется единственностью морфизма (функции) из любого типа-кандитата в "наилучший" тип, либо же наоборот в обратную сторону.
Такой "наилучший" тип и семейство уникальных морфизмов также называют "универсальными".

На диаграммах ниже представлены универсальные морфизмы для типов сумм и произведения.

Универсальное свойство - 

### Подтипизация

### Сумма и произведение типов

### Экспоненциал и карирование

### Типы и множества

Признак наличия совокупности связанных с типом отображений можно считать предикатом, выделяющим некий **класс** объектов.
А классы, как было сказано выше, не обязательно описывают множество.
Тип не имеет внутренней структуры - его не всегда можно описать поэлементно.
Но зачастую такую структуру можно привязать "снаружи", определив совокупность морфизмов в элементы некоторого множества.

### Типы и логическая корректность программ

### Другие типы

Эквивалентность (тут сложнее, но, как минимум, морфизмы эквивалентных типов образуют циклы на диаграмме).

### А если без типов?
SKI - как пример языка для бестипового исчисления



## Вселенные типов
Парадоксы, характерные для множеств, проявляются и для типов.
Например, парадокс Жерара демонстрирует, что **тип всех типов невозможно построить**.
Один из способов избегания такого рода парадоксов - введение **кумулятивной вселенной типов**.
(В теории множеств есть аналогичная идея - вселенные Гротендика, но это другая история)

* Каждый терм вводится с указанием своего типа.
* Следовательно, каждый тип, будучи термом, имеет свой тип.
* Но тип типа уже не будет принадлежать той же вселенной типов, что исходный тип - он будет принадлежать следующей вселенной типов.
* Таким образом, вселенные типов образуют совокупность, индексированную натуральными числами.
* Каждый тип принадлежит не только своей вселенной, но и всем вселенным с более высоким индексом (**кумулятивность**).
Например, в программировании обобщённые типы (`list`, `option`, `Task`) относятся к вселенным более высоких индексов чем простые типы (`integer`, `boolean`, `string`, пользовательские простые типы и т.п.).

### Обобщённые типы

### Сорта

### Зависимые типы

### Полиморфизм сортов и вселенных

## Перспективы

### Теория категорий

Теория категорий появилась как развитие идей теории типов - не все интересные штуки удавалось описать в рамках теории типов.
Стрелки - это не только морфизмы, которые позволяют перейти от $A$ к $B$.
Но сейчас (HoTT?) известно, что теорию категорий (также как и теорию множеств) можно вывести из теории типов.

### Гомотопическая теория типов

### Теория типов с учётом стоимости



Философская муть: [Понятия: множество, тип, атрибут](https://habr.com/ru/post/330196/)
