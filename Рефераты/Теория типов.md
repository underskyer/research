[[Типы в языках прогарммирования.pdf]]

[Система типов в математике](https://habr.com/ru/post/347294/)

[Теория категорий позволяет математике отказаться от равенств](https://habr.com/ru/post/476372/)

[[Высшие индуктивные типы]]




Мы все привыкли к типам. Но что же это такое? Почему возникла необходимость в использовании чего-то такого?



**Множества** можно задавать двумя способами:
* **экстенсионально** - поэлементно, например, через операции с существующими множествами (объединение, пересечение, вычитание и т.п.)
* **интенсионально** - через некий предикат, определяющий принадлежность к этому множеству.

Оказывается, что некоторые предикаты не позволяют определить множество.
Возникают разного рода **парадоксы** (не только Расселовские):
* не существует множества всех множеств,
* не существует множества элементов, не равных самим себе,
* "парадокс брадобрея" (он стрижёт всех жителей своего города кроме тех, кто не стрижёт сам себя),
* и т.п.

Вводится понятие **класса** - совокупности, определяемой через предикат. Каждый класс может быть
* либо множеством,
* либо **собственным классом** (больше чем множество).

Множества, связанные биекцией (взаимно-однозначным отображением) имеют одинаковую мощность (кардинальное число).
Такие множества фактически неразличимы.
Предикат, проверяющий соответствие заданной мощности, определяют **класс эквивалентности множеств**.
Классы эквивалентности не являются множествами (собственный класс).

Вычисления (алгоритмы, программы) строятся как логическая композиция отображений одних множеств на другие.
Иными словами, множества снабжаются дополнительными структурами - совокупностью отображений **из** этих множеств или, наоборот, **на** них.
Множества с одинаковой мощностью, снабженные такими структурами, теряют неразличимость.
Например, восьмибайтовая ячейка памяти может хранить в себе значения как из множества Int64, так и из double.
Эти множества имеют одинаковую мощность, но для значений из этих множеств предоставляется **разный набор возможностей**.
Так появляется концепция типа.

Тип (объекта) определяется совокупностью связанных с ним морфизмов (с их помощью объект отображается в объекты других типов).
Это можно считать предикатом, определяющим совокупность объектов, следовательно, тип может соответствовать не только множествам, но и собственным классам.
Тип не имеет внутренней структуры - его не всегда можно описать поэлементно - но зачастую структуру можно привязать снаружи, как совокупность морфизмов в элементы некоторого множества.
Но это возможно не всегда.

Тип не имеет смысла сам по себе, если для него нет морфизмов.
Суть типа определяется только его положением на **диаграмме типов**, его отношением к другим типам на этой диаграмме. 
Через положение типа на диаграмме определяются такие базовые понятия, как, например,
* подтипизация (по сути, морфизм от супертипа к подтипу),
* сумма типов (определяется морфизмами **в** тип-сумму),
* произведение типов (определяется морфизмами **из** типа-произведения),
* функция (морфизм из произведения функции с типом кодомена в тип домена),
* эквивалентность (тут сложнее, но, как минимум, морфизмы эквивалентных типов образуют циклы на диаграмме).
Большинство перечисленных выше понятий опираются на понятие **универсального свойства**. Уникальность универсального свойства позволяет выбрать лучшего представителя этих понятий среди похожих.

Расселовские парадоксы (вроде "брадобрея") проявляются и для типов.
Например, парадокс Жерара демонстрирует, что **тип всех типов невозможно построить**.
Один из способов избегания такого рода парадоксов - введение **кумулятивной вселенной типов**.
(В теории множеств есть аналогичная идея - вселенные Гротендика, но это другая история)

* Каждый терм вводится с указанием своего типа.
* Следовательно, каждый тип, будучи термом, имеет свой тип.
* Но тип типа уже не будет принадлежать той же вселенной типов, что исходный тип - он будет принадлежать следующей вселенной типов.
* Таким образом, вселенные типов образуют совокупность, индексированную натуральными числами.
* Каждый тип принадлежит не только своей вселенной, но и всем вселенным с более высоким индексом (**кумулятивность**).
Например, в программировании обобщённые типы (`list`, `option`, `Task`) относятся к вселенным более высоких индексов чем простые типы (`integer`, `boolean`, `string`, пользовательские простые типы и т.п.).
