[[Типы в языках прогарммирования.pdf]]

[Система типов в математике](https://habr.com/ru/post/347294/)

[Теория категорий позволяет математике отказаться от равенств](https://habr.com/ru/post/476372/)

[[Высшие индуктивные типы]]


## Аннотация

Мы так привыкли к типам, что редко задаёмся вопросом, что же они такое на самом деле?
А главное - **почему возникла необходимость в их использовании**?
Этот поверхностный обзор сделан для того, чтобы продемонстрировать, как типы и другие связанные абстракции являются следствием из обобщения условий различных задач.

## Предисловие

Не секрет, что программирование основывается на глубокой математической теории.
Многие ключевые понятия, которые встречаются в различных областях компьютерных наук, пришли именно из математики.
Поэтому для всех, кто хочет быть программистом, было бы здорово получить более широкое видение предмета - разобраться в самой математической основе программирования.

Но, зачастую, это возвышенное намерение наталкивается на высокий порог вхождения в высшую математику.
Основная проблема заключается в традиционных особенностях математической литературы - нарочитой оторванности от реальности, от практических задач.
Типичный математический текст начинается со знакомства со "взятой с потолка" абстракцией, и потом рассматриваются её "удивительной красоты" свойства.
И только в редких работах где-то в конце можно увидеть коротенькую заметку, что, мол, какие-то физики нашли как применить эту "красоту" для каких-то там своих нужд.

Порог вхождения снижают различные блоги, в которых рассказывается, как те или иные математические абстракции применяются для решения конкретных задач, в частности, в программировании.
Но при объяснении полезности абстракции часто упускается важный аспект - **неизбежность** появления именно этой абстракции как **наилучшего** инструмента для решения целого класса задач.
Дело в том, что сами условия обобщённой задачи приводят к появлению наилучшей абстракции для её решения.
Понимание связи абстракции с условиями задачи расширяет горизонты, позволяет в дальнейшем находить оптимальные реализации этой абстракции для каждого конкретного случая, подпадающего под указанные условия.
Именно на этот аспект сделан основной упор в этом обзоре теории типов.

Я дилетант в математике, да и в области компьютерных наук не довелось получить системных знаний. Немного печально, но я этого не стыжусь)).
Ожидаю, что знающие люди в комментариях будут посылать в правильных направлениях, но всё же надеюсь, что этот обзор приоткроет завесу тайны над типами с не самой известной стороны и окажется интересен широкому классу читателей.

## Множества и классы

### Предпосылки

С давних времён люди находили нечто общее в решаемых задачах из самых разных сфер жизни.
Например, если одна корова да ещё одна корова - это две коровы, то такое же рассуждение справедливо и для яблок.
В этом рассуждении ключевую роль играют не коровы (и, тем более, не яблоки), а [**числа**](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE) - одна из первых математических абстракций.

Ещё в древнем Междуречье, более четырёх тысяч лет назад, люди [умели вычислять](https://elementy.ru/nauchno-populyarnaya_biblioteka/434752/Matematika_v_Mesopotamii) объёмы крепостных стен, площади земельных участков, динамику численности стад и проч. Тогда на примере конкретных житейских проблем были описаны **способы вычисления**, которые применимы для широкого спектра задач, достаточно лишь заменить числа в условии.
Но лишь в средние века в Европе в обиход вошло понятие «[алгоритм](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC "Алгоритм")» (по имени [учёного IX века](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C-%D0%A5%D0%BE%D1%80%D0%B5%D0%B7%D0%BC%D0%B8)).
Для описания процедуры решения таких классов задач необходимо использование новой абстракции - [**переменной**](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD%D0%B0).
Алгоритм описывает, что мы должны сделать с переменными, не зависимо от того, какие значения (из некоторого **набора** возможных значений) будут **подставлены** вместо неё при решении конкретной задачи.
Таким образом, "переменная" представляет собой значение из некоторого **набора** возможных значений.

Свойства таких наборов-множеств, их взаимоотношений исследуются веками.
В XIX веке активно ищутся способы нахождения корней многочленов (см. [алгебраические замыкания](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8_%D0%B7%D0%B0%D0%BC%D0%BA%D0%BD%D1%83%D1%82%D0%BE%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B5)), для упрощения сложных задач изучается разделение множеств на классы эквивалентности (см. например, [классы вычетов](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_%D0%B2%D1%8B%D1%87%D0%B5%D1%82%D0%BE%D0%B2)) и многое другое.
Внезапно оказалось, что четкое понимание множества просто категорически необходимо в самых разных областях математики, которые развиваются зачастую независимо друг от друга узкими специалистами.
Множества представляются потенциальным фундаментом, на котором можно построить **единый способ проверки корректности любых алгоритмов**!

Ближе к XX веку в научном сообществе накопилась необходимость к формализации понятия "множество".
Это было исторически неизбежно, и не так важно, кого бы назвали первым.

### Множества

Перечислим основные свойства множеств.

Множество определяется условием **принадлежности** к нему какого-либо элемента (которое, например, может быть другим множеством): $a\in A$.

Существует выделенное пустое множество $\emptyset$, такое что для любого $a$ утверждение $a\in\emptyset$ ложно.

Множество можно задать двумя способами:
* **экстенсионально** - просто перечислив его элементы - $\{a, b, c\}$;
* **интенсионально** - указав условие, по которому можно выбрать некоторые элементы существующего множества - $\{$*множество всех людей, кто сейчас это читает*$\}$.

Интенсионально определяются основные операции над множествами.

Также важно понятие отношения между множествами, в частности, равенство множеств.

### Парадоксы

Оказывается, что некоторые предикаты не позволяют определить множество.
Возникают разного рода [парадоксы](https://habr.com/ru/post/197578/):
* не существует множества всех множеств,
* не существует множества элементов, не равных самим себе,
* и т.п.

Вводится понятие **класса** - совокупности, определяемой через предикат. Каждый класс может быть
* либо множеством,
* либо **собственным классом** (больше чем множество).

### Неразличимость

Философская муть: [Понятия: множество, тип, атрибут](https://habr.com/ru/post/330196/)

[_Гугология_ (это не _опечатка_) для _программистов_](https://habr.com/ru/post/445398/)
[_Виды_ _бесконечностей_ и _вынос_ _мозга_](https://habr.com/ru/post/445904/)


Множества, связанные биекцией (взаимно-однозначным отображением) имеют одинаковую мощность (кардинальное число).
Такие множества фактически неразличимы.
Предикат, проверяющий соответствие заданной мощности, определяют **класс эквивалентности множеств**.
Классы эквивалентности не являются множествами (собственный класс).

### Вычисления
Вычисления (алгоритмы, программы) строятся как логическая композиция отображений одних множеств на другие.
Иными словами, множества снабжаются дополнительными структурами - совокупностью отображений **из** этих множеств или, наоборот, **на** них.
Множества с одинаковой мощностью, снабженные такими структурами, теряют неразличимость.
Например, восьмибайтовая ячейка памяти может хранить в себе значения как из множества Int64, так и из double.
Эти множества имеют одинаковую мощность, но для значений из этих множеств предоставляется **разный набор возможностей**.
Так появляется концепция типа.

## Типы

### Определение типа
Тип (объекта) определяется совокупностью связанных с ним морфизмов (с их помощью объект отображается в объекты других типов).
Это можно считать предикатом, определяющим совокупность объектов, следовательно, тип может соответствовать не только множествам, но и собственным классам.
Тип не имеет внутренней структуры - его не всегда можно описать поэлементно - но зачастую структуру можно привязать снаружи, как совокупность морфизмов в элементы некоторого множества.
Но это возможно не всегда.

### Базовые понятия
Тип не имеет смысла сам по себе, если для него нет морфизмов.
Суть типа определяется только его положением на **диаграмме типов**, его отношением к другим типам на этой диаграмме. 
Через положение типа на диаграмме определяются такие базовые понятия, как, например,
* подтипизация (по сути, морфизм от супертипа к подтипу),
* сумма типов (определяется морфизмами **в** тип-сумму),
* произведение типов (определяется морфизмами **из** типа-произведения),
* функция (морфизм из произведения функции с типом кодомена в тип домена),
* эквивалентность (тут сложнее, но, как минимум, морфизмы эквивалентных типов образуют циклы на диаграмме).


### Универсальное свойство
Большинство перечисленных выше понятий опираются на понятие **универсального свойства**. Уникальность универсального свойства позволяет выбрать лучшего представителя этих понятий среди похожих.

### SKI - язык бестиповых вычислений
SKI - как пример языка для бестипового исчисления


## Вселенные типов
Парадоксы, характерные для множеств, проявляются и для типов.
Например, парадокс Жерара демонстрирует, что **тип всех типов невозможно построить**.
Один из способов избегания такого рода парадоксов - введение **кумулятивной вселенной типов**.
(В теории множеств есть аналогичная идея - вселенные Гротендика, но это другая история)

* Каждый терм вводится с указанием своего типа.
* Следовательно, каждый тип, будучи термом, имеет свой тип.
* Но тип типа уже не будет принадлежать той же вселенной типов, что исходный тип - он будет принадлежать следующей вселенной типов.
* Таким образом, вселенные типов образуют совокупность, индексированную натуральными числами.
* Каждый тип принадлежит не только своей вселенной, но и всем вселенным с более высоким индексом (**кумулятивность**).
Например, в программировании обобщённые типы (`list`, `option`, `Task`) относятся к вселенным более высоких индексов чем простые типы (`integer`, `boolean`, `string`, пользовательские простые типы и т.п.).

### Обобщённые типы

### Сорта

### Зависимые типы

### Полиморфизм сортов и вселенных

## Перспективы

### Теория категорий

Теория категорий появилась как развитие идей теории типов - не все интересные штуки удавалось описать в рамках теории типов.
Стрелки - это не только морфизмы, которые позволяют перейти от $A$ к $B$.
Но сейчас (HoTT?) известно, что теорию категорий (также как и теорию множеств) можно вывести из теории типов.

### Гомотопическая теория типов

### Теория типов с учётом стоимости



