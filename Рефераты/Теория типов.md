[[Типы в языках прогарммирования.pdf]]

[Система типов в математике](https://habr.com/ru/post/347294/)

[Теория категорий позволяет математике отказаться от равенств](https://habr.com/ru/post/476372/)

[[Высшие индуктивные типы]]


## Аннотация

Мы так привыкли к типам, что редко задаёмся вопросом, что же они такое на самом деле?
А главное - **почему возникла необходимость в их использовании**?
Этот поверхностный обзор сделан для того, чтобы продемонстрировать, как типы и другие связанные абстракции являются следствием из обобщения условий различных задач.

## Предисловие

Не секрет, что программирование основывается на глубокой математической теории.
Многие ключевые понятия, которые встречаются в различных областях компьютерных наук, пришли именно из математики.
Поэтому для всех, кто хочет быть программистом, было бы здорово получить более широкое видение предмета - разобраться в самой математической основе программирования.

Но, зачастую, это возвышенное намерение наталкивается на высокий порог вхождения в высшую математику.
Основная проблема заключается в традиционных особенностях математической литературы - нарочитой оторванности от реальности, от практических задач.
Типичный математический текст начинается со знакомства со "взятой с потолка" абстракцией, и потом рассматриваются её "удивительной красоты" свойства.
И только в редких работах где-то в конце можно увидеть коротенькую заметку, что, мол, какие-то физики нашли как применить эту "красоту" для каких-то там своих нужд.

Порог вхождения снижают различные блоги, в которых рассказывается, как те или иные математические абстракции применяются для решения конкретных задач, в частности, в программировании.
Но при объяснении полезности абстракции часто упускается важный аспект - **неизбежность** появления именно этой абстракции как **наилучшего** инструмента для решения целого класса задач.
Дело в том, что сами условия обобщённой задачи приводят к появлению наилучшей абстракции для её решения.
Понимание связи абстракции с условиями задачи расширяет горизонты, позволяет в дальнейшем находить оптимальные реализации этой абстракции для каждого конкретного случая, подпадающего под указанные условия.
Именно на этот аспект сделан основной упор в этом обзоре теории типов.

Я дилетант в математике, да и в области компьютерных наук не довелось получить системных знаний. Немного печально, но я этого не стыжусь)).
Ожидаю, что знающие люди в комментариях будут посылать в правильных направлениях, но всё же надеюсь, что этот обзор приоткроет завесу тайны над типами с не самой известной стороны и окажется интересен широкому классу читателей.

## Множества и классы

### Предпосылки

С давних времён люди находили нечто общее в решаемых задачах из самых разных сфер жизни.
Например, если одна корова да ещё одна корова - это две коровы, то такое же рассуждение справедливо и для яблок.
В этом рассуждении ключевую роль играют не коровы (и, тем более, не яблоки), а [**числа**](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE) - одна из первых математических абстракций.

Задолго до того, как [Мухаммад Мусаевич Хорезмский](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C-%D0%A5%D0%BE%D1%80%D0%B5%D0%B7%D0%BC%D0%B8) подарил миру (прежде всего, Европе) понятие «[Алгоритм](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC "Алгоритм")», древние [Шумеры умели вычислять](https://elementy.ru/nauchno-populyarnaya_biblioteka/434752/Matematika_v_Mesopotamii) объёмы **разных** крепостных стен, площади земельных участков **разной** формы, динамику численности **разных** стад и проч.
Для описания процедуры решения таких классов задач необходимо использование новой абстракции - [**переменной**](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD%D0%B0).
Алгоритм описывает, что мы должны сделать с переменными, не зависимо от того, какие значения (из некоторого **набора** возможных значений) будут **подставлены** вместо неё при решении конкретной задачи.

### Множества

В XI веке активно исследуются [алгебраические замыкания](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8_%D0%B7%D0%B0%D0%BC%D0%BA%D0%BD%D1%83%D1%82%D0%BE%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B5), изучаются вопросы факторизации (разделение на классы эквивалентности) бесконечных множеств (см. например, [классы вычетов](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_%D0%B2%D1%8B%D1%87%D0%B5%D1%82%D0%BE%D0%B2)).
Но только ближе к XX веку [Георг Кантор](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BD%D1%82%D0%BE%D1%80,_%D0%93%D0%B5%D0%BE%D1%80%D0%B3) формализует понятие "множество".
![[Pasted image 20230127135819.png]]

Внезапно оказывается, что четкое понимание множества просто категорически необходимо в самых разных областях математики (да как же без этого раньше жили?!).

**Множества** можно задавать двумя способами:
* **экстенсионально** - через операции с существующими множествами (объединение, пересечение, вычитание и т.п.) или прямым перечислением его элементов;
* **интенсионально** - через некое условие, определяющее принадлежность объекта к этому множеству.

### Парадоксы

[Парадоксы теории множеств и их философская интерпретация](https://habr.com/ru/post/197578/)

Оказывается, что некоторые предикаты не позволяют определить множество.
Возникают разного рода **парадоксы** (не только Расселовские):
* не существует множества всех множеств,
* не существует множества элементов, не равных самим себе,
* "парадокс брадобрея" (он стрижёт всех жителей своего города кроме тех, кто не стрижёт сам себя),
* и т.п.

### Классы
Вводится понятие **класса** - совокупности, определяемой через предикат. Каждый класс может быть
* либо множеством,
* либо **собственным классом** (больше чем множество).

### Неразличимость

Философская муть: [Понятия: множество, тип, атрибут](https://habr.com/ru/post/330196/)

[_Гугология_ (это не _опечатка_) для _программистов_](https://habr.com/ru/post/445398/)
[_Виды_ _бесконечностей_ и _вынос_ _мозга_](https://habr.com/ru/post/445904/)


Множества, связанные биекцией (взаимно-однозначным отображением) имеют одинаковую мощность (кардинальное число).
Такие множества фактически неразличимы.
Предикат, проверяющий соответствие заданной мощности, определяют **класс эквивалентности множеств**.
Классы эквивалентности не являются множествами (собственный класс).

### Вычисления
Вычисления (алгоритмы, программы) строятся как логическая композиция отображений одних множеств на другие.
Иными словами, множества снабжаются дополнительными структурами - совокупностью отображений **из** этих множеств или, наоборот, **на** них.
Множества с одинаковой мощностью, снабженные такими структурами, теряют неразличимость.
Например, восьмибайтовая ячейка памяти может хранить в себе значения как из множества Int64, так и из double.
Эти множества имеют одинаковую мощность, но для значений из этих множеств предоставляется **разный набор возможностей**.
Так появляется концепция типа.

## Типы

### Определение типа
Тип (объекта) определяется совокупностью связанных с ним морфизмов (с их помощью объект отображается в объекты других типов).
Это можно считать предикатом, определяющим совокупность объектов, следовательно, тип может соответствовать не только множествам, но и собственным классам.
Тип не имеет внутренней структуры - его не всегда можно описать поэлементно - но зачастую структуру можно привязать снаружи, как совокупность морфизмов в элементы некоторого множества.
Но это возможно не всегда.

### Базовые понятия
Тип не имеет смысла сам по себе, если для него нет морфизмов.
Суть типа определяется только его положением на **диаграмме типов**, его отношением к другим типам на этой диаграмме. 
Через положение типа на диаграмме определяются такие базовые понятия, как, например,
* подтипизация (по сути, морфизм от супертипа к подтипу),
* сумма типов (определяется морфизмами **в** тип-сумму),
* произведение типов (определяется морфизмами **из** типа-произведения),
* функция (морфизм из произведения функции с типом кодомена в тип домена),
* эквивалентность (тут сложнее, но, как минимум, морфизмы эквивалентных типов образуют циклы на диаграмме).


### Универсальное свойство
Большинство перечисленных выше понятий опираются на понятие **универсального свойства**. Уникальность универсального свойства позволяет выбрать лучшего представителя этих понятий среди похожих.

### SKI
SKI - как пример языка для бестипового исчисления


## Вселенные
Расселовские парадоксы (вроде "брадобрея") проявляются и для типов.
Например, парадокс Жерара демонстрирует, что **тип всех типов невозможно построить**.
Один из способов избегания такого рода парадоксов - введение **кумулятивной вселенной типов**.
(В теории множеств есть аналогичная идея - вселенные Гротендика, но это другая история)

* Каждый терм вводится с указанием своего типа.
* Следовательно, каждый тип, будучи термом, имеет свой тип.
* Но тип типа уже не будет принадлежать той же вселенной типов, что исходный тип - он будет принадлежать следующей вселенной типов.
* Таким образом, вселенные типов образуют совокупность, индексированную натуральными числами.
* Каждый тип принадлежит не только своей вселенной, но и всем вселенным с более высоким индексом (**кумулятивность**).
Например, в программировании обобщённые типы (`list`, `option`, `Task`) относятся к вселенным более высоких индексов чем простые типы (`integer`, `boolean`, `string`, пользовательские простые типы и т.п.).

### Обобщённые типы

### Сорта

### Зависимые типы

### Полиморфизм сортов и вселенных



