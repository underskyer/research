[Очень зависимые типы](https://akuklev.livejournal.com/1194050.html)
[Understanding Scala's Path-Dependent Types](https://reintech.io/blog/understanding-scalas-path-dependent-types)


- интуиционизм и конструктивизм
- зависимые типы;
- применение в Scala;
	- shapeless
	- refined
- индуктивные типы;
- ГоТТ
	- типы эквивалентности и унивалентность;
	- многомерные пути в топологическом пространстве типов;
	- определение действительных чисел;
- "экономичная" теория типов и проблема останова.

Термы в Scala классифицируются на типы и значения. Трудности возникают, когда появляется необходимость стыковать эти вселенные. Ведь, по сути, полиморфная функция - это отображение **из типов в значения** (функционального типа), т.е. из одной *вселенной* в другую. Не легко честно реализовать концепцию вселенных (единый синтаксис для работы со значенями, простыми *и не только простыми* типами), тем более, когда у языка программирования уже есть тяжёлое наследие... Поэтому разработчики Scala решили выбрать *путь проще - всё усложнить* введением нового синтаксиса для типов полиморфнх фукнций (`[X] => ARGS => RESULT`). 

#### Семейства типов

Тут написано, как аналогичного результата добиться в Scala 2: [Match Types in Scala 3 (Baeldung)](https://www.baeldung.com/scala/match-types)

В третьей версии Scala появилась возможность использовать в выражениях типов [сопоставления с шаблонами](https://docs.scala-lang.org/scala3/reference/new-types/match-types.html). 

[Что не понравилось в Match Types](https://chugunkov.dev/2021/06/29/match-types-problems.html)
