Для любых типов (суммы, произведения) можно построить представление в "комбинаторном стиле", в виде функций, принимающих и возвращающих другие функции. Для этого достаточно построить функцию, которая характеризует *пользу* исходного типа - возможности получить из его значения что-то другое. К примеру, рассмотрим упомянутый ранее моноид, необходимый для "сворачивания" списков:
```scala
trait MonoidA {
  def binOp(a: A, b: A): A // бинарная операция
  def neutral: A           // нейтральный элемент
}
```
Этот трейт соответствует типу
$$MonoidA=A\times A^{A\times A}$$
Смысл любого типа определяется возможностью вычислить на основе его значения некое другое значение. Для списка есть только одна ключевая возможность, определяемая функцией свертки, которая принимает на вход моноид, и возвращает простое значение:
$$LstA=A^{MonoidA}=A^{A\times A^{A\times A}}.$$
Продемонстрируем это:
```scala
trait MonoidA {
  def binOp(a: A, b: A): A // бинарная операция
  def neutral: A           // нейтральный элемент
}
```
