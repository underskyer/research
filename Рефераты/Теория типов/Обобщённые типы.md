
### Аннотация

В предыдущей статье рассказывалось о том, что теория типов разрабатывалась для формализации вычислений, обеспечения корректной декомпозиции сложных алгоритмов на небольшие функции, образующие ориентированный граф, вершинами которого являются типы. В этот раз мы рассмотрим необходимость появления такой абстракции, как обобщённые типы (generics).

### Предисловие

Однажды я делал доклад для сотрудников о технических решениях на одном из наших Scala-проектов. Там рассказывалось про применение монадических трансформеров, Tagless Final и прочих ФП-шных вкусностей. После доклада по обратной связи я получил разные замечания, в том числе и вопрос, который звучал примерно так: "а зачем вообще нужны обобщённые типы?". Вопрос неожиданный, но стало понятно что доклад слушали и разработчики на языках c динамической типизацией, вроде JScript или Python. Тогда я пообещал, что в следующий раз обязательно раскрою эту тему.

Тем не менее, быстро не получалось ответить на поставленный вопрос. Ответы, которые подсказывал интернет, даже если бы и удовлетворили любопытство спросившего, но не убеждали меня. Обычно там говорятся общее слова, мол, обобщённые типы дают "типобезопасность", "оптимизацию" (не требуется явное приведение к типам-значений и т.п.), "переиспользумеость" и прочая бессодержательная "вода". Зачастую, далее приводится пример, в котором раскрываются преимущества типизированных (обобщённых) *списков* над нетипизированными... И есть люди, которые считают это достаточным обоснованием для введения концепции обобщённых типов!

Во многих языках программирования со строгой типизацией уже есть встроенные типизированные коллекции, например, массивы со своими методами. Выглядит так, что нет необходимости давать программистам возможность создавать свои обобщённые типы?

На самом деле, полезными бывают, конечно же, не только обобщённые списки и методы для работы с ними. В этой статье попробуем раскрыть, что для решения целого класса задач концепция обобщённых (универсальных, параметризированных) типов является **необходимой**, рассмотрим ключевые особенности этих типов и различные сценарии их использования в программировании.

### Конструкторы типов

В предыдущей статье показывалось, что сущность типов определяется его отношениями с другими типами. Формулируя новый тип мы должны указать, как сконструировать связанные с ним значения, и как их потом деконструировать (eliminate) в значения других типов. Например, тип произведения $C=A\times B$ определяется наличием двух проекторов - функций из $C$ в $A$ и из $C$ в $B$. С типами суммы и экспоненциала ситуация аналогичная - объявляя тип как некое алгебраическое выражение от существующих типов, мы _автоматически_ определяем функции, связывающий новый тип **с типами, используемыми в этом выражении**! И часто оказываетя, что система функций, определяемая **формой** алгебраического выражения типа, может быть полезна сразу для нескольких типов, котрых можно подставить в это выражение. Рассмотрим типичные ситуации.

Практически любые вычисления декомпозируются на последовательные шаги - более мелкие вычисления, выполняемые друг за другом. Каждые такие шаги разеделены состояниями - в нашем случае это значения конкретных типов. Например, имея значение $a: A$ и функции $f: A\LeftArrow B$, g: B\LeftArrow C$ мы можем на первом шаге вычислить значение $b: B$, а из него уже на втором шаге получить результирующее значение $c: C$. Получаем _конечный автомат_ с начальным состоянием $A$, промежуточным $B$ и конечным $C$. Таким образом, из всего разветвлённого графа диагрммы типов выбирается единствыенный путь, связывающий тип начального значения с типом конечного $A \leftArrow B \leftArrow C$.

```scala
type Error   = String
type Context = String
```

### Классы типов

### Параметрический полиморфизм

### Обобщённые типы и подтипизация

В прочем, в Scala всё же есть различие в работе с подтипизацией между ООП-шным наследованием и прочим неявным приведением типов - для ограничений параметров обобщённых типов использовался разный синтаксис. А в новых версиях языка второй вариант сочли небезопасным и вообще запретили - параметры обобщённых типов можно ограничивать подтипизацией, определённой *только* через наследование.

### Сорта и вселенные типов

Парадоксы, характерные для множеств, проявляются и для типов.
Например, парадокс Жерара демонстрирует, что **тип всех типов невозможно построить**.
Один из способов избегания такого рода парадоксов - введение **кумулятивной вселенной типов**.
(В теории множеств есть аналогичная идея - вселенные Гротендика, но это другая история)

* Каждый терм вводится с указанием своего типа.
* Следовательно, каждый тип, будучи термом, имеет свой тип.
* Но тип типа уже не будет принадлежать той же вселенной типов, что исходный тип - он будет принадлежать следующей вселенной типов.
* Таким образом, вселенные типов образуют совокупность, индексированную натуральными числами.
* Каждый тип принадлежит не только своей вселенной, но и всем вселенным с более высоким индексом (**кумулятивность**).
Например, в программировании обобщённые типы (`list`, `option`, `Task`) относятся к вселенным более высоких индексов чем простые типы (`integer`, `boolean`, `string`, пользовательские простые типы и т.п.).

`<div style="page-break-after: always;"/>`

### Теория категорий

Теория категорий появилась как развитие идей теории типов - не все интересные штуки удавалось описать в рамках теории типов.
Стрелки - это не только морфизмы, которые позволяют перейти от $A$ к $B$.
Но сейчас (HoTT?) известно, что теорию категорий (также как и теорию множеств) можно вывести из теории типов.


[Теория категорий позволяет математике отказаться от равенств](https://habr.com/ru/post/476372/)

[[Высшие индуктивные типы]]

- теория категорий;
- конструкторы типов;
- вариантность;
- классы типов;
- функторы и лемма Йонеды;
- сопряжения, расширения Кана, монады;
- полиморфизм сортов (вселенных) типов;
