
### Аннотация

В предыдущей статье рассказывалось о том, что теория типов разрабатывалась для формализации вычислений, обеспечения корректной декомпозиции сложных алгоритмов на небольшие функции, образующие ориентированный граф, вершинами которого являются типы. В этот раз мы рассмотрим необходимость появления такой абстракции, как обобщённые типы (generics).

### Предисловие

Однажды я делал доклад для сотрудников о технических решениях на одном из наших Scala-проектов. Там рассказывалось про применение монадических трансформеров, Tagless Final и прочих ФП-шных вкусностей. После доклада по обратной связи я получил разные замечания, в том числе и вопрос, который звучал примерно так: "а зачем вообще нужны обобщённые типы?". Вопрос неожиданный, но стало понятно что доклад слушали и разработчики на языках c динамической типизацией, вроде JScript или Python. Тогда я пообещал, что в следующий раз обязательно раскрою эту тему.

Тем не менее, быстро не получалось ответить на поставленный вопрос. Ответы, которые подсказывал интернет, даже если бы и удовлетворили любопытство спросившего, но не убеждали меня. Обычно там говорятся общее слова, мол, обобщённые типы дают "типобезопасность", "оптимизацию" (не требуется явное приведение к типам-значений и т.п.), "переиспользумеость" и прочая бессодержательная "вода". Зачастую, далее приводится пример, в котором раскрываются преимущества типизированных (обобщённых) *списков* над нетипизированными... И есть люди, которые считают это достаточным обоснованием для введения концепции обобщённых типов!

Во многих языках программирования со строгой типизацией уже есть встроенные типизированные коллекции, например, массивы со своими методами. Выглядит так, что нет необходимости давать программистам возможность создавать свои обобщённые типы?

На самом деле, полезными бывают, конечно же, не только обобщённые списки и методы для работы с ними. В этой статье попробуем раскрыть, что для решения целого класса задач концепция обобщённых (универсальных, параметризированных) типов является **необходимой**, рассмотрим ключевые особенности этих типов и различные сценарии их использования в программировании.

### Конструкторы типов

В предыдущей статье показывалось, что сущность типов определяется его отношениями с другими типами. Формулируя новый тип мы должны указать, как сконструировать связанные с ним значения, и как их потом деконструировать (eliminate) в значения других типов. Например, тип произведения $C=A\times B$ определяется наличием двух проекторов - функций из $C$ в $A$ и из $C$ в $B$. С типами суммы и экспоненциала ситуация аналогичная - объявляя тип как некое алгебраическое выражение от существующих типов, мы _автоматически_ определяем функции, связывающий новый тип **с типами, используемыми в этом выражении**! И часто оказываетя, что система функций, определяемая **формой** алгебраического выражения типа, может быть полезна сразу для нескольких типов, котрых можно подставить в это выражение. Рассмотрим типичные ситуации.

Практически любые вычисления декомпозируются на последовательные шаги - более мелкие вычисления, выполняемые друг за другом. Каждые такие шаги разеделены состояниями - в нашем случае это значения конкретных типов. Например, имея значение $a: A$ и функции $f: A\Rightarrow B$, $g: B\Rightarrow C$ мы можем на первом шаге $f$ вычислить значение $b: B$, а из него уже на втором шаге $g$ получить результирующее значение $c: C$. Получаем _конечный автомат_ с начальным состоянием $A$, промежуточным $B$ и конечным $C$. Таким образом, из всего разветвлённого графа диагрммы типов выбирается единствыенный путь, связывающий тип начального значения с типом конечного: $$A \rightarrow B \rightarrow C.$$

Но что если мы хотим по ходу этих вычислений вести некий контекст (типа $Context$), задаваемый в самом начале, возможно, изменяющийся в процессе и требуемый вместе с результатом? Такой конечный автомат можно было бы описать как $$A\times Context \rightarrow B\times Context \rightarrow C\times Context.$$

Если же нужно при вычислениях отслеживать возможные сбои, ошибки (типа $Error$), которые могут происходить на каждом шаге, то можно использовать такой конечный автомат: $$A+Error \rightarrow B+Error \rightarrow C+Error.$$

Прорисовывается закономерность, не так ли? Теперь становится очевидным, что если нам нужно и пробрасывать контекст, и отслеживать ошибки, то состояния конечого автомата вычислений будет описываться типами такой формы: $$(X + Error)\times Context.$$

Конечно, не всегда нужно все вычисления вести в какой-то единственной форме алгебраических типов. Иногда бывает полезным перейти к другой форме, в частности, к нейтральной, где нет никаких алгебраических операций. Например, имея значение типа $X_A=A+Error$, в котором хранится либо значение типа $A$, либо ошибка, мы можем захотеть _в любом случае_ получить значение некого типа $B$. Но для этих целей у нас уже _автоматически_ имеется нужный изоморфизм: $B^{X_A}\cong B^A \times B^{Error}$ - механизм сопоставления с шаблонами! Таким образом, имея $xa: X_A$ и предоставив функции $f: A\Rightarrow B$ и $g: Error\Rightarrow B$, мы можем получить значение типа $B$ просто воспользовавшись какой-то (библиотечной) реализацией стандартного изоморфизма.

Описывать все возможности для подобного рода алгебраических типов в случае каждого требуемого в программе $A$ - неблагодарное занятие, приводящее к тоннам копипасты. Тем более не получиться реализовать в библиотеках изоморфизмы единообразно для всех возможных типов (разве что некторые изоморфизмы поддерживаются на уровне языка). Вот тут-то и появляются на сцене **обобщённые типы** - описание алгебраической формы, в которую при использовании нужно подставить конкретные типы, чтобы получить новые, с функциями, задаваемые этой формой и используемым типом.

Рассмотрим пару примеров на Scala:
```scala
// обобщённый тип OrError, параметризированный параметром-типом A
sealed trait OrError[A] // OrError[A] ≅ A + Throwable
final case class Success[A](val: A) extends OrError[A]
final case class Error(error: Throwable) extends OrError[Nothing]
// Nothing тут нужен для корректных отношений подтипизации, об этом будет далее

// обобщённая "библиотечная" функция для формы OrError, аж с двумя параметрами-типами
def foldOrError[A, B](aOrError: OrError[A], f: A => B, g: Throwable => B): B
  = aOrError match
    case Success(a) => f(a)
    case Error(err) => g(err)


// обобщённый тип WithContext, параметризированный параметром-типом A
case class WithContext[A](val: A, context: String) // WithContext[A] ≅ A × String

// обобщённая "библиотечная" функция для формы WithContext, аж с двумя параметрами-типами
def foldWithContext[A, B](aWithContext: WithContext[A], f: A => String => B): B
  = Function.uncurried(f)(Tuple.fromProductTyped(aWithContext)) // кортеж передаём в деКАРРИрованную функцию
```
Пусть вас не смущает, что сперва мы говорим об обобщённых типах, а затем сразу же пишем обобщённые функции свёртки. Во-первых, обобщённые типы как раз и нужны, чтобы определить обобщённые функции (конструтор `Success` принимает, а проектор `WithContext.val` возвращает значение типа-параметра). Во-вторых, единственность _универсальной_ реализации обеих функций `fold` однозначно опредляется алгебраическим выражением типа и можно было бы ожидать их поддержку на уровне языка. В-третьих, здесь продемонстрировано, что такие функции и так уже реализованы в языке (механизм сопоставления с шаблонами и метод `Function.uncurried`). Кроме того, обобщённые функции - это, по сути, значения некого обобщённого функционального типа и позднее мы посмотрим, что для этого нам предлагает Scala.

### Функции от типов

Упомянутое выше выражение $(X + Error)\times Context$ при фиксированных $Error$ и $Context$ имеет одну неизвестную - _свободную_ переменную $X$. Если мы определяем это выражение _для любого_ $X$, то получаем _функцию_, которая принимает значение и связывает его с идентификатором $X$. С этой точки зрения удобно рассматривать и **обобщённые типы - это функции, отображающие из одного или нескольких типов в тип**.

Приведённые выше примеры обобщённых типов `WithContext[A]` и `OrError[A]` - это эндоморфизмы - отображение из типов в типы. Аналогия обобщённыйх типов Scala с обычними функциями нагляднее прослеживается в обявлениях с помощью ключевого слова `type` _псевдонимов типов_:
```scala
type Union[A, B]          = A | B    // объединение типов в Scala 3
type Product[A, B]        = (A, B)   // кортеж - произведение двух типов
type OrErrorAndContext[x] = WithContext[OrError[X]] // внутри "вызываются" другие "функции"
```
Действительно, похоже на определения обычных функций, только "тип" аргументов и результата нигде не указывается. У них у всех одинаковый "тип" - это тип!)))

В Scala 3 также есть возможность использовать литералы обобщённых типов - λ-выражения типов:
```scala
type WithContext = [A] =>> (A, String)                 // псевдоним типа, опеределённый через λ-выражение 
```
Опять же, синтаксис похож на λ-выражения обычных функций.

Ещё в Scala 3 добавлен специальный синтаксис для типов полиморфных (обобщённых) функций:
```scala
val foldWithContextVal                                  // значение обобщённого типа функции
  : [A, B] => WithContext[A] => (A => String => B) => B // тип обобщённой функции
  = foldWithContext                                     // передаём сюда метод, определённый выше
```
Такие значения можно передавать в методы, в которых будет решаться, какие типы подставить для этих обобщённых функций. Эта возможность может быть весьма полезна, но различие видов стрелочек, на мой взгляд, вносит излишние сложности в изночально простую концепцию.

### Классы типов

Для обобщённых типов есть ещё одна любопытная трактовка

### Параметрический полиморфизм

Сравнение с полиморфизмом подтипов.

### Рекурсивные типы

### Подтипизация и вариантность

В прочем, в Scala всё же есть различие в работе с подтипизацией между ООП-шным наследованием и прочим неявным приведением типов - для ограничений параметров обобщённых типов использовался разный синтаксис. А в новых версиях языка второй вариант сочли небезопасным и вообще запретили - параметры обобщённых типов можно ограничивать подтипизацией, определённой *только* через наследование.

### Сорта и вселенные типов

Парадоксы, характерные для множеств, проявляются и для типов.
Например, парадокс Жерара демонстрирует, что **тип всех типов невозможно построить**.
Один из способов избегания такого рода парадоксов - введение **кумулятивной вселенной типов**.
(В теории множеств есть аналогичная идея - вселенные Гротендика, но это другая история)

* Каждый терм вводится с указанием своего типа.
* Следовательно, каждый тип, будучи термом, имеет свой тип.
* Но тип типа уже не будет принадлежать той же вселенной типов, что исходный тип - он будет принадлежать следующей вселенной типов.
* Таким образом, вселенные типов образуют совокупность, индексированную натуральными числами.
* Каждый тип принадлежит не только своей вселенной, но и всем вселенным с более высоким индексом (**кумулятивность**).
Например, в программировании обобщённые типы (`list`, `option`, `Task`) относятся к вселенным более высоких индексов чем простые типы (`integer`, `boolean`, `string`, пользовательские простые типы и т.п.).

`<div style="page-break-after: always;"/>`
