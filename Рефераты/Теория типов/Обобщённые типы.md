
### Аннотация

В предыдущей статье раскрывались некоторые основные понятия теории типов. В этот раз мы рассмотрим необходимость появления такой абстракции, как обобщённые типы (*generics*), рассмотрим их ключевые особенности и различные сценарии использования в программировании.

### Предисловие

Однажды я делал доклад для наших сотрудников о технических решениях на одном из наших Scala-проектов. Там рассказывалось про применение монадических трансформеров, Tagless Final и прочих ФП-шных вкусностей. После доклада по обратной связи я получил разные замечания, в том числе и вопрос, который звучал примерно так: "а зачем вообще нужны обобщённые типы?". Вопрос был для меня неожиданный, но я пообещал, что в следующий раз обязательно раскрою эту тему.

Тем не менее, быстро не получалось ответить на поставленный вопрос. Ответы, которые подсказывал интернет, даже если бы и удовлетворили любопытство спросившего, но не убеждали меня. Обычно там говорятся общее слова, мол, обобщённые типы дают "типобезопасность", "оптимизацию" (не требуется явное приведение к типам-значений и т.п.), "переиспользумеость" и прочая бессодержательная "вода". Зачастую, далее приводится пример, в котором раскрываются преимущества типизированных (обобщённых) *коллекций* над нетипизированными...

Однако, во многих языках программирования со строгой типизацией уже есть встроенные типизированные коллекции со своими методами, например, массивы. Выглядит так, что будто бы и нет необходимости давать программистам возможность создавать свои обобщённые типы?

На самом деле, полезными бывают, конечно же, не только обобщённые списки и методы для работы с ними. В этой статье попробуем раскрыть, что для решения целого класса задач концепция обобщённых (универсальных, параметризированных) типов является *необходимой*, рассмотрим ключевые особенности этих типов и различные сценарии их использования в программировании.

### Мотивация

[В предыдущей статье](ссылка!) показывалось, что сущность типа определяется его отношениями с другими типами. Формулируя новый тип мы должны указать, как сконструировать связанные с ним значения, и как их потом деконструировать (eliminate) в значения других типов. Например, тип произведения $C=A\times B$ определяется наличием двух проекторов - функций из $C$ в $A$ и из $C$ в $B$. С типами суммы и экспоненциала ситуация аналогичная - объявляя тип как некое алгебраическое выражение от существующих типов, мы _автоматически_ определяем функции, связывающий новый тип **с типами, используемыми в этом выражении**! И часто оказывается, что система функций, определяемая **формой** алгебраического выражения типа, может быть полезна сразу для нескольких типов, которых можно подставить в это выражение. Рассмотрим типичные ситуации.

Сперва представим, что у нас есть функция, которая может завершится ошибкой, которую в дальнейшем можно будет обработать. Это может быть поиск элемента в коллекции (искомого значения может не найтись), или запрос на web-сервер (тут может быть много разных ошибок). В привычном императивном программировании это обычно решается с применением механизмов выброса исключений и их отловом. Такой подход, как правило, недекларативен - по сигнатуре функции нет возможности понять, какие "несчастливые" исходы возможны. В любом случае, это усложняет язык, вводя новые синтаксические конструкции, вроде конструкций `try/catch`. В то же время, задача очевидным образом решается благодаря естественному понятию теории типов - сумме типов:
$$findItem: RegEx => ItemType + NotFound$$
$$getSmthFromWeb: Request => Response + Unaccessable + BadRequest + InternalError$$
Благодаря очевидному алгебраическому изоморфизму, описанного в предыдущей статье, для каждой такой суммы типов однозначно определяется функция, которая из значений этого типа вычисляет значения произвольного типа $X$ - механизм сопоставления с шаблонами проверяет, чтобы программист предоставил функции в тип $X$ из всех типов-слагаемых:
```scala
def foldToString(itemOrNot: ItemType | NotFound)( // ItemType + NotFound
  itemToString: ItemType => String,  // на вход приходят две функции
  notFoundResult:   Unit => String   // по количеству слагаемых типа
): String = 
  itemOrNot match     // тело функции не зависит от конкретного ItemType!
    case it: ItemType => itemToString(it)
    case _: NotFound  => notFoundResult()
```
Здесь пересечение типов `ItemType | NotFound` можно считать суммой типа `ItemType` и [единичного типа]() `NotFound`.

И поиск элемента в коллекции, и загрузка контента из веб-сервиса являются весьма распространёнными сценариями, которые неоднократно встречаются во многих приложениях. При этом, конкретные типы `ItemType`, или `Response` будут различаться в разных местах, но *способы использования* результирующих значений типов суммы - реализации методов `fold` - не будут зависеть ни от `ItemType`, или `Response`! Более того, различные реализации метода `fold` будут отличаться только заменой типа `ItemType` (или, аналогично, `Response`) на какой-нибудь другой. Можно сказать, что этот тип является *параметром* метода! Многократное дублирование этого кода для каждого такого конкретного "типа-параметра" выглядело бы весьма неудачным решением...

Помимо сценариев с суммами типов, рассмотрим и другие. Например, если какой-либо метод ищет некий контент на разных ресурсах, было бы полезно вместе с результатом вернуть и сведения об источнике, откуда этот контент был получен. Тут уже поможет произведение типов вида `Content × Source`, где тип `Content` может отличаться в разных конкретных случаях, а `Source` - это всегда один и тот же тип, например, `String`. В таких случаях способы использования такого кортежа на основе проекторов в типы `Content` и `Source` не будут зависеть от того, какой именно тип-параметр `Content` будет там использоваться.

```scala
def foldToInt(contentWithSource: Conent & Source)( // Conent × Source
  handler: Conent => Source => Int  // на вход приходит каррированная функция
): Int = 
  // обраотчик handler вполне может игнориовать свой второй параметр source
  handler(contentWithSource: Conent)(contentWithSource: Source)
```

Ещё один популярный сценарий - "избавление от зависимостей". Если в неком методе требуется использование какого-то сервиса типа `Service`, то обычно его называют зависимостью и передают в самом начале, например, вместе "бизнесовыми" параметрами метода (или же по-ООПшному, чуть раньше - в конструктор класса, где расположен метод). Получается, так называемый, "жадный" захват зависимости ("утром деньги, вечером стулья"). Сигнатура получается примерно такая: `(Service, BusinessParam) => Result`. "Жадному" механизму противопоставляется "ленивый", когда метод не требует предоставление зависимости в самом начале, но возвращает функцию, которая на вход требует только значение `Service`: `BusinessParam => (Service => Result)`. Получается, что метод "избавился от зависимости"! Таким образом всю бизнес-логику можно описать чисто, **вынеся всю возню с зависимостями в самый конец приложения** (для обработки библиотечными методами или средой исполнения). В такого рода сценариях наблюдается знакомая закономерность - способ использования значений экспоненциального типа `Service => Result` не зависит от типа `Result` - он является параметром метода.

```scala
def foldToBoolean(resultByService: Service => Result)( // Resultˢᵉʳᵛⁱᶜᵉ
  service: Service,            // на вход приходят сервис
  mapToBoolean: Result => Int  // и "преобразователь" Result в Int
): Boolean = 
  mapToBoolean(resultByService(service)) // что такое Result - не важно!
```

Можно привести и другие аналогичные сценарии, в которых конкретизация некоторых типов (вроде `Result`, `Content`, `Response`, `ItemType`) не нужна - в разных вариантах это могут быть самые разные типы, но сам алгоритм сценария остаётся тем же самым! Было бы весьма расточительно многократно копипастить такие функции, отличающиеся только своей сигнатурой, но имеющие одинаковую реализацию.

Для решения такой проблемы необходима новая абстракция -
### Обобщённые методы

Идея простая - достаточно описать единственную обобщённую функцию, которая будет описывать все варианты сценария с различными конкретными типами, передаваемыми ей как параметры. В Scala параметры-типы передаются не в круглых скобках, как обычные аргументы, а в квадратных. Перепишем функции `fold`, объявленные в предыдущем примере, в обобщённой форме:
```scala
def foldToString[ItemType](itemOrNot: ItemType | NotFound)( // ItemType + NotFound
  itemToString: ItemType => String,  // на вход приходят две функции
  notFoundResult:   Unit => String   // по количеству слагаемых типа
): String = ???                      // реализация такая же, как и раньше

def foldToInt[Conent](contentWithSource: Conent & Source)( // Conent × Source
  handler: Conent => Source => Int  // на вход приходит каррированная функция
): Int = ???                        // реализация такая же, как и раньше

def foldToBoolean[Result](resultByService: Service => Result)( // Resultˢᵉʳᵛⁱᶜᵉ
  service: Service,                 // на вход приходят сервис
  mapToBoolean: Result => Int       // и "преобразователь" Result в Int
): Boolean = ???                    // реализация такая же, как и раньше
```
Использовать их можно так:
```scala
val doubleOrNot: Double | NotFound = ??? // какое-то значение
val str = foldToString[Double](doubleOrNot)(d => s"double: $d", _ => "no double found")
//                     ^^^^^^ - тип-параметр указан явно (но это не обязательно)

val intOrNot: Int | NotFound = ??? // какое-то значение
val str = foldToString(intOrNot)(i => s"int: $i", _ => "no int found")
//                   ^^ - зачастую, тип-параметр компилятор и сам может вывести
```

Изоморфизмы типов
### Конструкторы типов

Упомянутое выше выражение $(X + Error)\times Context$ при фиксированных $Error$ и $Context$ имеет одну неизвестную - _свободную_ переменную $X$. Если мы определяем это выражение _для любого_ $X$, то получаем _функцию_, которая принимает значение и связывает его с идентификатором $X$. С этой точки зрения удобно рассматривать и **обобщённые типы - это функции, отображающие из одного или нескольких типов в тип**.

![[обобщённое встраивание диаграмм.png]]

Приведённые выше примеры обобщённых типов `WithContext[A]` и `OrError[A]` - это эндоморфизмы - отображение из типов в типы. Аналогия обобщённыйх типов Scala с обычними функциями нагляднее прослеживается в обявлениях _псевдонимов типов_ с помощью ключевого слова `type`:
```scala
type Union[A, B]          = A | B    // объединение типов в Scala 3
type Product[A, B]        = (A, B)   // кортеж - произведение двух типов
type OrErrorAndContext[x] = WithContext[OrError[X]] // внутри "вызываются" другие "функции"
```
Действительно, похоже на определения обычных функций, только "тип" аргументов и результата нигде не указывается. У них у всех одинаковый "тип" - это тип!)))

В Scala 3 также есть возможность использовать литералы обобщённых типов - λ-выражения типов:
```scala
type WithContext = [A] =>> (A, String)                 // псевдоним типа, опеределённый через λ-выражение 
```
Опять же, синтаксис похож на λ-выражения обычных функций.

Ещё в Scala 3 добавлен специальный синтаксис для типов полиморфных (обобщённых) функций:
```scala
val foldWithContextVal                                  // значение обобщённого типа функции
  : [A, B] => WithContext[A] => (A => String => B) => B // тип обобщённой функции
  = foldWithContext                                     // передаём сюда метод, определённый выше
```
Такие значения можно передавать в методы, в которых будет решаться, какие типы подставить для этих обобщённых функций. Эта возможность может быть весьма полезна, но различие видов стрелочек, на мой взгляд, вносит излишние сложности в изначально простую концепцию.

### Классы типов

Для обобщённых типов есть ещё одна любопытная трактовка

### Параметрический полиморфизм

Сравнение с полиморфизмом подтипов.

### Ограничения подтипизации

Про совмещение полиморфизмов.
Параметры обобщённых типов можно ограничивать подтипизацией, определённой *только* через наследование.

### Вариантность

Про то, как конструкторы типов транслируют отношения подтипизации.
### Семейства типов

### Рекурсивные типы

- списки, деревья, натуральные числа
- корни многочленов и ряд тейлора
- (ката- и прочие морфизмы в следующей главе)

### Кодировки Чёрча
### Экзистенциальные типы

### Типы высокого рода

различные примеры, вроде функтора, алгебры, катаморфизма

### Рода и вселенные типов

Парадоксы, характерные для множеств, проявляются и для типов.
Например, парадокс Жерара демонстрирует, что **тип всех типов невозможно построить**.
Один из способов избегания такого рода парадоксов - введение **кумулятивной вселенной типов**.
(В теории множеств есть аналогичная идея - вселенные Гротендика, но это другая история)

* Каждый терм вводится с указанием своего типа.
* Следовательно, каждый тип, будучи термом, имеет свой тип.
* Но тип типа уже не будет принадлежать той же вселенной типов, что исходный тип - он будет принадлежать следующей вселенной типов.
* Таким образом, вселенные типов образуют совокупность, индексированную натуральными числами.
* Каждый тип принадлежит не только своей вселенной, но и всем вселенным с более высоким индексом (**кумулятивность**).
Например, в программировании обобщённые типы (`list`, `option`, `Task`) относятся к вселенным более высоких индексов чем простые типы (`integer`, `boolean`, `string`, пользовательские простые типы и т.п.).

