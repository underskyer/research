
В [предыдущей статье](https://habr.com/ru/articles/758542/) раскрывались некоторые основные понятия теории типов. В этот раз мы рассмотрим необходимость появления такой абстракции, как обобщённые типы (*generics*), рассмотрим их ключевые особенности и различные сценарии использования в программировании.

## Оглавление

- [[#К обобщённым типам|К обобщённым типам]]
- [[#Конструкторы типов|Конструкторы типов]]
- [[#Полиморфизм|Полиморфизм]]
- [[#Типы высокого рода|Типы высокого рода]]
- [[#Классы типов|Классы типов]]
- [[#Типы-контейнеры|Типы-контейнеры]]

## Предисловие

Однажды я делал доклад для наших сотрудников о технических решениях на одном из наших Scala-проектов. Там рассказывалось про применение монадических трансформеров, Tagless Final и прочих ФП-шных вкусностей. После доклада по обратной связи я получил разные замечания, в том числе и вопрос, который звучал примерно так: "а зачем вообще нужны обобщённые типы?". Вопрос был для меня неожиданный, но я пообещал, что в следующий раз обязательно раскрою эту тему.

Тем не менее, быстро не получалось подготовить ответ на поставленный вопрос. Собственных знаний не хватало, чтобы объяснить эту тему самому себе. То, что подсказывал интернет, даже если бы и удовлетворило любопытство спросившего, но не убеждало меня. Обычно там говорятся общее слова, мол, обобщённые типы дают "типобезопасность", "оптимизацию" (не требуется явное приведение к типам-значений и т.п.), "переиспользумеость" и прочая бессодержательная "вода". Зачастую, далее приводится пример, в котором раскрываются преимущества типизированных (обобщённых) *коллекций* над нетипизированными...

Однако, во многих языках программирования со строгой типизацией уже есть встроенные типизированные коллекции со своими методами, например, массивы. Выглядит так, что будто бы и нет необходимости давать программистам возможность создавать свои обобщённые типы?

На самом деле, полезными бывают, конечно же, не только обобщённые списки и методы для работы с ними. Здесь мы рассмотрим, какими задачами обусловлена необходимость появления концепции обобщённых типов, рассмотрим ключевые особенности этих типов и различные сценарии их использования в программировании.

Так же как и предыдущая статья, эта не является подробным учебником с систематическим изложением материала. Основная задача - поверхностный обзор темы с самых разных точек зрения, с тем, чтобы заинтересовавшийся каким-либо аспектом читатель смог самостоятельно найти его детальное описание, например, в интернете.

Далее предполагается, что читатель уже знаком с базовыми понятиями теории типов, освещёнными в [первой статье](https://habr.com/ru/articles/758542/).
## Обобщённые типы
### Мотивация

Представим, что у нас есть функция, которая может завершится ошибкой, которую в дальнейшем можно будет обработать. Это может быть поиск элемента в коллекции (искомого значения может не найтись), или запрос на web-сервер (тут может быть много разных ошибок). В привычном императивном программировании это обычно решается с применением механизмов выброса исключений и их отловом. Такой подход, как правило, недекларативен - по сигнатуре функции нет возможности понять, какие "несчастливые" исходы возможны. В любом случае, это усложняет язык, вводя новые синтаксические конструкции, вроде `try/catch`. В то же время, задача решается благодаря естественному понятию теории типов - сумме типов:
$$findItem: RegEx => ItemType + NotFound$$
$$getSmthFromWeb: Request => Response + Unaccessable + BadRequest + InternalError$$
Благодаря очевидному алгебраическому изоморфизму, описанного в предыдущей статье, для каждой такой суммы типов однозначно определяется функция, которая из значений этого типа вычисляет значения произвольного типа $X$ - механизм сопоставления с шаблонами проверяет, чтобы программист предоставил функции в тип $X$ из всех типов-слагаемых:
```scala
def foldToString(itemOrNot: ItemType | NotFound)( // ItemType + NotFound
  itemToString: ItemType => String,  // на вход приходят две функции
  notFoundResult:   Unit => String   // по количеству слагаемых типа
): String = 
  itemOrNot match     // тело функции не зависит от конкретного ItemType!
    case it: ItemType => itemToString(it)
    case _: NotFound  => notFoundResult()
```
Здесь пересечение типов `ItemType | NotFound` можно считать суммой типа `ItemType` и [единичного типа]() `NotFound`.

И поиск элемента в коллекции, и загрузка контента из веб-сервиса являются весьма распространёнными сценариями, которые неоднократно встречаются во многих приложениях. При этом, конкретные типы `ItemType`, или `Response` будут различаться в разных местах, но *способы использования* результирующих значений типов суммы - реализации методов `fold` - не будут зависеть ни от `ItemType`, или `Response`! Более того, различные реализации метода `fold` будут отличаться только заменой типа `ItemType` (или, аналогично, `Response`) на какой-нибудь другой. Можно сказать, что этот тип является *параметром* метода! Многократное дублирование этого кода для каждого такого конкретного "типа-параметра" выглядело бы весьма неудачным решением...

Помимо сценариев с суммами типов, рассмотрим и другие. Например, если какой-либо метод ищет некий контент на разных ресурсах, было бы полезно вместе с результатом вернуть и сведения об источнике, откуда этот контент был получен. Тут уже поможет произведение типов вида `Content × Source`, где тип `Content` может отличаться в разных конкретных случаях, а `Source` - это всегда один и тот же тип, например, `String`. В таких случаях способы использования такого кортежа на основе проекторов в типы `Content` и `Source` не будут зависеть от того, какой именно тип-параметр `Content` будет там использоваться.

```scala
def foldToInt(contentWithSource: Conent & Source)( // Conent × Source
  handler: Conent => Source => Int  // на вход приходит каррированная функция
): Int = 
  // обраотчик handler вполне может игнориовать свой второй параметр source
  handler(contentWithSource: Conent)(contentWithSource: Source)
```

Ещё один популярный сценарий - "избавление от зависимостей". Если в неком методе требуется использование какого-то сервиса типа `Service`, то обычно его называют зависимостью и передают в самом начале, например, вместе "бизнесовыми" параметрами метода (или же по-ООПшному, чуть раньше - в конструктор класса, где расположен метод). Получается, так называемый, "жадный" захват зависимости ("утром деньги, вечером стулья"). Сигнатура получается примерно такая: `(Service, BusinessParam) => Result`. "Жадному" механизму противопоставляется "ленивый", когда метод не требует предоставление зависимости в самом начале, но возвращает функцию, которая на вход требует только значение `Service`: `BusinessParam => (Service => Result)`. Получается, что метод "избавился от зависимости"! Таким образом всю бизнес-логику можно описать чисто, **вынеся всю возню с зависимостями в самый конец приложения** (для обработки библиотечными методами или средой исполнения). В такого рода сценариях наблюдается знакомая закономерность - способ использования значений экспоненциального типа `Service => Result` не зависит от типа `Result` - он является параметром метода.

```scala
def foldToResult(resultByService: Service => Result)( // Resultˢᵉʳᵛⁱᶜᵉ
  service: Service         // на вход приходит сервис
): Result = 
  resultByService(service) // что такое Result - не важно!
```

Можно привести и другие аналогичные сценарии, в которых конкретизация некоторых типов (вроде `Result`, `Content`, `Response`, `ItemType`) не нужна - в разных вариантах это могут быть самые разные типы, но сам алгоритм сценария остаётся тем же самым! Было бы весьма расточительно многократно копипастить такие функции, отличающиеся только своей сигнатурой, но имеющие одинаковую реализацию.

Для решения такой проблемы необходима новая абстракция -
### Обобщённые методы

Идея простая - достаточно описать единственную обобщённую функцию, которая будет описывать все варианты сценария с различными конкретными типами, передаваемыми ей как параметры. В Scala параметры-типы передаются не в круглых скобках, как обычные аргументы, а в квадратных. Перепишем методы `fold`, объявленные в предыдущем примере, в обобщённой форме:
```scala
def foldToString[ItemType](itemOrNot: ItemType | NotFound)( // ItemType + NotFound
  itemToString: ItemType => String,  // на вход приходят две функции
  notFoundResult:   Unit => String   // по количеству слагаемых типа
): String = ???                      // реализация такая же, как и раньше

def foldToInt[Conent](contentWithSource: Conent & Source)( // Conent × Source
  handler: Conent => Source => Int  // на вход приходит каррированная функция
): Int = ???                        // реализация такая же, как и раньше

def foldToResult[Result](resultByService: Service => Result)( // Resultˢᵉʳᵛⁱᶜᵉ
  service: Service                  // на вход приходит сервис
): Result = ???                     // реализация такая же, как и раньше
```
Использовать их можно так:
```scala
val doubleOrNot: Double | NotFound = ??? // какое-то значение
val str = foldToString[Double](doubleOrNot)(d => s"double: $d", _ => "no double found")
//                     ^^^^^^ - тип-параметр указан явно (но это не обязательно)

val intOrNot: Int | NotFound = ??? // какое-то значение
val str = foldToString(intOrNot)(i => s"int: $i", _ => "no int found")
//                   ^^ - зачастую, тип-параметр компилятор и сам может вывести
```
Тут обобщённый метод `foldToString`, определённый единообразно **для любого** конкретного типа `ItemType`, используется со значениями разных типов: `Double` и `Int`. Причём во втором случае тип не указан явно - компилятор сам определяет его по типу первого параметра метода.

Телом обобщённых методов являются выражения, в которых некоторые используемые там термы могут быть любого типа. Такие типы участвуют в выражении *свободно* - они могут меняться в зависимости от контекста использования этого выражения. Метод же образуется путём *связывания* всех свободных параметров выражения с аргументами, которые нужно передать в метод (замыкания сейчас не рассматриваем). В случае обобщённых методов некоторыми из таких аргументов будут типы.

Приведённые выше обобщённые методы являются примерами гомоморфизма типов ("одной половинкой [изоморфизма]()"). В таком случае их реализация определяется типами аргументов и результата метода. Но, конечно же, можно написать и свои обобщённые методы, которые будут связывать бизнес-логикой типы модели конкретной предметной области.

Внимательный читатель обратит внимание на типы аргументов представленных выше обобщённых методов - в типах `ItemType | NotFound`, `Conent & Source`, `Service => Result` упоминаются неопределённые типы-параметры `ItemType`, `Conent` и `Result`. То есть, параметризация методов типами отразилась прежде всего на типах их аргументов и результата. С другой стороны, тип функции, соответствующий сигнатуре этих методов, так же оказывается параметризирован типом!

Для таких типов есть разные названия, в частности,
- **обобщённые типы**, или генерики (generics),
- конструкторы типов,
- полиморфные типы,
- типы высокого рода,
- классы типов,
- типы-контейнеры.

Идея "обобщения" (функций/методов) была уже упомянута выше, а далее будет раскрыт смысл остальных названий из этого списка.
### Обобщённые классы

Scala позиционируется как мульти-парадигменный язык, поэтому в нём есть ОПП-шные классы. В определнии класса описан именованный набор ограничений, которые позволяют отфильтровать только те значения, для которых заданы соответствующие методы, свойства, поля и т.п. С классом ассоциируется определёный тип данных (тип-произведение проекторов-методов). И, как и во многих популярных языках, в Scala классы можно параметризировать типами - объявлять обобщённые классы:
```scala
case class ContentAndSource[Content](content: Content, source: String)

trait ContentHandler[Content, Result] {
  def handleContent(contentAndSource: ContentAndSource[Content]): Result
}
```
Типы-параметры обобщённых классов указываются в квадратных скобках сразу после имени класса.

Чтобы создать экземпляр обобщённого класса, помимо значений-параметров конструктора, нужно конкретизировать и типы-параметры:
```scala
case class MyContent(test: String) // будем подставлять его как тип-параметр

val contentHandler = new ContentHandler[MyContent, String] {
  def handleContent(contentAndSource: ContentAndSource[Content]) =
	  s"Из источника '${contentAndSource.source}' получено содержимое: ${contentAndSource.content.text}"
	  //                                                                                         ^^^^^
}     //                                         используем проектор конкретного класса MyContent.text

val myContentAndSource = ContentAndSource(MyContent("text"), "hardcoded")
//                                      ^^
//        тут необязательно явно указывать тип - он будет конкретизирован на основе типа аргумента

val str = contentHnadler.handleContent(myContentAndSource) // String
// "Из источника 'hardcoded' получено содержимое: text"
```

Далее мы рассмотрим другие, более ФП-ориентированные способы определения обобщённых типов.

## Конструкторы типов

Термин "конструкторы типов" буквально отражает идею возможности построения новых типов из существующих. Единожды описав такой конструктор (или используя уже встроенные в язык) можно создавать новые типы, подставляя разные известные типы в этот конструктор. Термин отражает функциональную природу обобщённых типов - это, по сути, отображения из типов в тип (а не из значений в значения, как обычные функции!).

Любая функция строится вокруг некоторого выражения, которое становится её телом. Поэтому в первою очередь рассмотрим, какие выражения над типами можно использовать в языке Scala.

### Встроенные операции над типами в Scala

В Scala 3 есть встроенные конструкции для построения новых типов из существующих:
- просто тип `A` - случай настолько тривиальный, что легко упустить его полезность,
- кортеж `(A, B, C)` - суть тип-произведение,
- объединение типов `A | B` - если типы разные, то это аналогично их сумме,
- пересечение `A & B` - если типы разные, то это аналогично их произведению,
- "вызов" другого конструктора типов, например,
	- `A => B` - тут используется псевдоним для `Function[A, B]`,
	- `A Either B` - синоним для `Either[A, B]`,
	- `Option[A]`,
	- `Map[K, V]`,
	- `MySupperClass[A, B, C]` - конечно, можно вызывать и конструкторы типов, связанных с классами (или трейтами), не определёнными в стандартной библиотеке Scala.
- сопоставление с шаблонами для типов - будет рассмотрено ниже в разделе "**Семейства типов**".

Комбинируя эти конструкции можно определять типы произвольной сложности:
```scala
type NoAction = Unit   // Unit - встроенный единичный тип
type Log      = String // также вполне корректное выражение
type NewType  = NoAction | ((Service1 & Service2) => MyIO[(SingleResult Either List[AltResult], Log)])
//              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//                       Вот такое кучерявое выражение получилось. Конечно, можно и длиннее))
```

### Функции над типами

Идентификаторы, которые используются в выражении, могут относится как к известным в текущем контексте конструкциями, так быть неопределёнными, *свободными* переменными. Чтобы иметь возможность вычислить выражение, можно построить функцию, *связать все свободные переменные* выражения с параметрами, которые требуется передать при вызове этой функции.

С этой точки зрения удобно рассматривать и **обобщённые типы - это функции, отображающие из одного или нескольких типов в тип**. Аналогия обобщённых типов Scala с обычными функциями нагляднее прослеживается в объявлениях _псевдонимов типов_ с помощью ключевого слова `type`:
```scala
type Union[A, B]          = A | B                     // объединение типов
type OrErrorAndContext[x] = Union[(X, String), Error] // "вызывается" функция (конструктор типов) Union
```
Действительно, похоже на определения обычных функций, только "тип" аргументов и результата нигде не указывается. У них у всех одинаковый "тип" - это тип!)))

В Scala 3 также есть возможность использовать литералы обобщённых типов - λ-выражения типов:
```scala
type WithContext = [A] =>> (A, String)                // псевдоним типа, опеределённый через λ-выражение 
```
Опять же, синтаксис похож на λ-выражения обычных функций.

Для обобщённых типов, принимающий ровно два аргумента возможна инфиксная запись, которая иногда бывает полезна, а иногда - не очень:
```scala
// если такой код компилируется, значит использованы эквивалентные типы по обе стороны =:= 
summon[(Either[String, Int]) =:= (String Either Int)]     // близко к естественному языку "строка или целое число"
//      ^^^^^^                           ^^^^^^
//   обычная запись                  инфиксная запись 
summon[(Function[String, Int]) =:= (String Function Int)] // а с таким типом инфиксная запись читается хуже
```
С другой стороны, Scala позволяет объявлять идентификаторы, состоящие из специальных символов, что может повысить читаемость:
```scala
type =>[A, B] = Function[A, B] // такой псевдоним уже есть в стандартной библиотеке
type  ×[A, B] = (A, B)         // новый псевдоним для типа произведения

// используем псевдонимы из спец-сиволов в инфиксной форме:
val func: Int  => String = _.toString
val pair: Int  ×  String = (5, "пять")
```

Каждый тип характеризуется набором функций-стрелок, связывающих одни типы с другими. Обобщённые типы позволяют связывать между собой любые такие наборы стрелок с помощью функций, определяемых телом обобщённого типа (комбинации сумм, произведений, экспоненциалов и т.п.):
![[обобщённое встраивание диаграмм.png|Обобщённый тип F[_] связывает с помощью проекторов произведения типов фиксированный тип B с типом, который может быть подставлен в тело F вместо A.]]

### Обобщённые рекурсивные типы

Особого внимания заслуживает возможность объявлять типы рекурсивно, когда в теле выражения используется идентификатор объявляемого типа. 

В Scala рекурсивные типы зачастую описываются в ООП-стиле, например,
```scala
sealed trait List[A]
case object Nil                                  extends List[Nothing] // почему Nothing - будет рассказано далее
final case class Cons[A](head: A, tail: List[A]) extends List[A]

val myList: List[Int] = Cons(1, Cons(2, Cons(3, Cons(2, Cons(1, Nil))))) // 1, 2, 3, 2, 1
```
Рекурсивность `List` с первого взгляда, возможно, незаметна. Она спрятана за наследованием классов (`extends`). Соответствующие объявленным классам типы можно записать так:
$$\begin{align} 
List[A] &= Nil + Cons[A],\\
Cons[A] &= A \times List[A],\\
Nil &\cong 1.\\
\end{align}$$
В итоге получается равенство, в котором рекурсия видна явно:
$$List[A] \cong 1 + A \times List[A].$$
(Если вместо $A$ подставить тип $Nothing \cong 0$, то можно убедиться, что $List[Nothing] \cong 1 \cong Nil$.)
Таким образом, список - это либо пустой список, либо элемент (голова) и другой список (хвост).

Просуммируем такой список:
```scala
def sum(list: List[Int]): Int = list match
  case Nil              => 0
  case Cons(head, tail) => head + sum(tail) // тут рекурсия!
```
Прослеживается очевидная закономерность - для рекурсивных типов нужны рекурсивные методы!

Пользуясь только суммой и произведением типов с помощью рекурсии можно построить любые древовидные структуры, например,
```scala
sealed trait NonEmptyTree[A]
final case class Leaf[A](value: A) extends NonEmptyTree[A]
final case class Node[A](left: NonEmptyTree[A], right: NonEmptyTree[A]) extends NonEmptyTree[A]
```
Трейту `NonEmptyTree` соответствует такой тип:
$$NonEmptyTree[A] \cong A + NonEmptyTree[A] \times NonEmptyTree[A].$$

Объявить рекурсивный тип в актуальной версии Scala без привлечения ООП несколько затруднительно. Например, такая конструкция не скомпилируется:
```scala
type List[A] = Unit + (A, List[A]) // illegal cyclic type reference...
```
Компилятор пытается "жадно" вычислить тип, спрятанный за псевдонимом, но, определив бесконечную рекурсию, сообщает об ошибке. Выглядит как недоработка компилятора, так как есть обходной путь с использованием механизма сопоставления с шаблонами на уровне типов - там типы вычисляются "лениво" и проблем с рекурсией не возникает. Этот механизм будет рассмотрен в разделе "**Семейства типов**".

Такие обобщённые древовидные типы иногда называются *абстрактными типами данных* (неизменяемыми). Они описывают коллекции определённой структуры, которые могут "хранить" любое количество элементов любого типа. В частности, обычный список является вырожденной разновидностью дерева.

Нетривиальность концепции рекурсивных типов можно ощутить, если для построения задействовать экспоненциал типов. Например, давайте посмотрим на два симметричных друг другу типа:
```scala
case class SelfModifyingHandler[A](f: A      => SelfModifyingHandler[A])
case class Wtf[A]                 (f: Wtf[A] => A)
```
Попробуйте самостоятельно создать значения этих типов и в комментариях описать сценарии их использования (названия толсто намекают...).

Тема рекурсивных типов и рекурсии в целом настолько богата, что статья о ней может оказаться даже больше чем эта. В ней хотелось бы рассказать о таких вкусностях, как
- ограничения на рекурсию (или "что не так с типом `Wtf`");
- хвостовая рекурсия, трамплины;
- ряд Тейлора и корни многочленов для обобщённых рекурсивных типов ;
- производные от обобщённых рекурсивных типов;
- комбинаторы неподвижной точки;
- схемы рекурсии (ката-, ана- и прочие морфизмы).
Очень надеюсь, что найдётся возможность подготовить и этот обзор.

## Полиморфные типы

### Разновидности полиморфизма

Пожалуй, наиболее общее, что я когда-либо слышал, определение *полиморфизма в программировании* - это свойство фрагмента кода, описывающего некую фиксированную семантику, приобретать разные смысловые оттенки в различных контекстах. Таким образом, в зависимости от контекста, этот код описывает целое "множество смысловых форм", то есть, является *полиморфным*.

В Википедии [приводится](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) каноническое определение полиморфизма - это способность функции обрабатывать данные разных типов. Там говорится о двух основных разновидностях полиморфизма - универсальном (параметрическом) и специальном (ad-hoc). Такая классификация опирается на понятие *дуализма* в теории ~~типов~~ категорий.

Разные исследовали приводят множество разновидностей полиморфизма. Если собрать их все вместе, то наберётся целая дюжина. Но, так или иначе, любой такой подвид можно притянуть за уши либо к универсальному, либо к специальному (или же к их сочетаниям). Они будут рассмотрены в соответствующих разделах статьи.

Отдельно стоит сказать про полиморфизм в языках с динамической типизацией. Как правило, в таких языках явно типизированными остаются лишь некоторые функции, например, встроенные арифметические операции. В остальных местах типы появляются у значений только в момент попытки их использования в типизированных функциях. Вне контекста выполнения типы термов просто не определены, что, в частности, не позволяет проводить статическую проверку корректности программы до её выполнения. Но теория типов создавалась больше для обеспечения корректности алгоритма в целом, *для любых начальных условий*, а не для проверки в некоторых частных случаев. Так что, не смотря на то, что при динамической типизации весь код является фактически полиморфным (может работать со значениями разных типов), не вижу смысла в дальнейших рассуждения о полиморфизме для этого случая.

При нынешнем засилье объектно-ориентированной парадигмы у многих программистов могло сложиться представление о полиморфизме, как лишь об одном из "столпов ООП". Например, перейдя [по одной](https://blog.skillfactory.ru/glossary/polimorfizm/) из первых ссылок в результатах поиска по слову "полиморфизм", можно прочесть:
> Полиморфизм (polymorphism) — это понятие из объектно-ориентированного программирования, которое позволяет разным сущностям выполнять одни и те же действия. При этом неважно, как эти сущности устроены внутри и чем они различаются.

Не уверен, что имеет смысл упрекать авторов подобных цитат в том, что они вводят в заблуждение читателя. Популярность какого-либо мнения превалирует в массовом сознании над его качеством, корректностью. Давайте лучше рассмотрим ООП-шный полиморфизм чуть подробнее.

### Полиморфизм подтипов

Рассмотрим конкретный пример:
```scala
trait Person { val name: String def sayHello(): String }
case class Français(name: String) extends Person { def sayHello() = "Bon après-midi!" }
case class Русский (name: String) extends Person { def sayHello() = "Здаров!" }

def dialogWith(person: Person) = {
  println("Привет, " + person.name)
  println(person.sayHello())              // 1
}

val Француа = Français("François")
val Василий = Русский("Вася")
dialogWith(Француа); dialogWith(Василий)  // 2
```
Возможно, у кого-то возникнет впечатление, что полиморфизм тут проявляется в строке с пометкой `1`, ведь именно там конкретное поведение метода `sayHello` определяется "типом значения", спрятанного за переменной `person`. Но проблема в том, что, по определению, типы привязываются к термам языка (литералам, переменным, выражениям), а не к значениям, размещённым в памяти компьютера. (У значения, зачастую, есть ссылка на описание класса, конструктором которого это значение создано, и класс связан с конкретным типом, который используется *во время выполнения* при проверке возможности использования значения в тех или иных операциях, но, как уже было сказано, основанный на этом динамический полиморфизм не помогает в проверке корректности алгоритма, и мы не будем его рассматривать.)

В данном же примере у переменной `person` тип `Person` фиксирован в сигнатуре метода, следовательно, по (более корректному) определению из Википедии, тут полиморфизма нет. Но, согласно тому же определению, он есть в строке с пометкой `2` - при вызовах метода, принимающих параметр типа `Person`, используются переменные других типов, `Français` и `Русский`. В этой строке срабатывает неявное приведение от подтипов к супертипу. Именно неявное приведение от подтипа к супертипу определяет ООП-шный *полиморфизм подтипов*! Например, если бы с помощью `dialogWith` обрабатывалась коллекция значений типа `Person`, то полиморфным было бы добавление значений классов `Français` и `Русский` в эту коллекцию.

"Чудо ООП-шного полиморфизма" - вызов по имени метода, перегруженного в неизвестном подклассе, который определяется по значению `person` - становится менее "чудесным", если вспомнить, что методы суть значения функционального типа. По ссылке `person` можно добраться до размещённой в памяти таблицы виртуальных методов, а уже в этой таблице лежат *ссылки на методы* именно того подкласса, конструктором которого это значение было создано. Т.е. в предыдущем примере достаточно просто переписать эти три строчки (и выкинуть классы-наследники)
```scala
case class Person(val name: String, val sayHello: Unit => String)
val Француа = Person(       "François",           ()   => "Bon après-midi!")
val Василий = Person(       "Вася",               ()   => "Здаров!")
```
и получить тот же самый результат, но уже без привлечения полиморфизма.

Следуя Википедии, полиморфизм подтипов относится к разновидности *универсального полиморфизма с ограничениями подтипизации* - об этом будет далее. Но с другой стороны, сами эти ограничения можно реализовать с помощью *специального полиморфизма*, о котором будет рассказано в разделе **Классы типов**.

### Универсальный полиморфизм и λ-исчисление

Само понятие универсального (параметрического) полиморфизма появилось в процессе развития **$\lambda$-исчисления**. Эта формальная система создавалось как фундаментальный язык, алгоритмы на котором можно было проверить на логическую корректность.

Изначально $\lambda$-исчисление было [безтипововым](https://ru.wikipedia.org/wiki/%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Там было введено понятие $\lambda$-абстракции с правилом аппликации (применения):
$$\begin{align}
f&:=\lambda x.\;2\cdot x+1;\\
f\;5\equiv f(5)&=2\cdot 5+1=11.
\end{align} $$

Затем появилось [просто-типизированная система](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5) $\lambda^{\rightarrow}$.  Здесь у каждой переменной, которая связывается квантором $\lambda$ фиксируется метка-тип (явно - в стиле Чёрча): 
$$\begin{align}
\lambda x:A.M;\\
\end{align} $$
Тип самого $\lambda$-выражения однозначно определяется по типу аргумента $x$ и телу выражения $M$.

Обозначение $\lambda^{\rightarrow}$ (стрелочка) возникло из того, что простые типы можно выразить [в кодировке Чёрча](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%A7%D1%91%D1%80%D1%87%D0%B0), т.е. как функции высшего порядка:
```scala
type Zero     = Any        // 𝟘 ≅ Any
type One      = Any => Any // 𝟙 ≅ Any => Any
type Bool     = Any => One // 𝟚 ≅ Any => Any => Any
type Natural  = One => One // ℕ ≅ (Any => Any) => Any => Any - натуральные числа по Пеано
```
Например:
```scala
val ifTrue: Bool = happyWay => unhappyWay => happyWay

val one  : Natural = suc => z =>         suc(z)
val three: Natural = suc => z => suc(suc(suc(z)))

val choose: Bool = ifTrue
val result = choose(one)(three) // one
```

Дальнейшее развитие - полиморфная система $\lambda2$ ([система F](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_F)). Теперь в $\lambda$-выражении стало возможно связывать не только обычные переменные, но и типовые:
$$\begin{align}
\lambda A:*.\; \lambda x:A.M;\\
\end{align} $$
Здесь $*$ - это "тип типа". Система $\lambda2$ позволяет определять *обобщённые функции*. В изоморфизме Карри-Ховарда типы соответствуют утверждениям, свойствам объектов, следовательно, система $\lambda2$ ассоциируется с [логикой второго порядка](https://en.wikipedia.org/wiki/Second-order_logic) (отсюда и двойка в названии).

В Scala 3 добавлен специальный синтаксис для типов обобщённых функций:
```scala
def foldWithContext[A, B](aWithContext: WithContext[A])(folder: (A, String) => B)
  = folder(aWithContext._1, aWithContext._2)
val foldWithContextVal                                  // переменная обобщённого функционального типа
  : [A, B] => WithContext[A] => ((A, String) => B) => B // тип      ∀A,B. WithContext[A] → ((A, String) → B) → B
  = foldWithContext                                     // значение λA,B. λa:WithContext[A]. λf:(A,String)→B. f(a._1, a._2)
```
Значения такого типа можно передавать в методы, в которых будет решаться, какие типы подставить для этих обобщённых функций.

Наконец ещё более продвинутая [система](https://en.wikipedia.org/wiki/Lambda_cube#%CE%BB%CF%89) $\lambda\omega$  (или $F\omega$) позволяет строить типы, используя $\lambda$-выражения
$$
List = \lambda A.\; \forall B.\; B\rightarrow(B\rightarrow A\rightarrow B)\rightarrow B;\\
$$
Именно тут появляются полиморфные (обобщённые) типы:
```scala
type List = [A] =>> [B] => B => (B => A => B) => B

def emptyList[A]: List[A] =
  [B] => (start: B) => (aggr: B => A => B) => start

def append[A](lst: List[A], a: A): List[A] =
  [B] => (start: B) => (aggr: B => A => B) => aggr(lst(start)(aggr))(a)

def fold[A, B](lst: List[A], start: B, aggr: B => A => B): B = lst(start)(aggr)

val myList = append(append(append(emptyList[Int], 1), 2), 3) // [1, 2, 3] 
fold(myList, "список:", s => i => s + " " + i)               // "список: 1 2 3"
```
Сами выражения, на которых строятся полиморфные типы, определяют способы их использования - связанные с ними полиморфные функции. Компилятор сам может (его можно научить) строить такие функции для полиморфных типов, что может значительно сократить количество кода, которого приходится писать программистам вручную.

Ввиду того, что в таких полиморфных типах параметр связывается через квантор "*для любого*", параметрический полиморфизм называется *универсальным*. Полиморфизм, где используется дуальный квантор "*существует*", называется *специальным* - он будет рассмотрен **позже**.

### Вариантность

Является ли список строк списком произвольных объектов? Конкретнее, можно ли передать терм типа `List[String]` в функцию, которая принимает аргумент типа `List[Any]`? Опытным путём можно убедиться, что в Scala (да и во многих других языках) это можно сделать. Но вот, наоборот, передать терм типа `List[Any]` в функцию, принимающую `List[String]` уже не получится. Получается, что `List[String]` является подтипом `List[Any]` и, очевидно, безо всякого наследования! Попробовав с другими простыми типами, можно заметить, что `List` транслирует отношения подтипизации для своих аргументов.

Но если мы попробуем провести аналогичные эксперименты с типами, скажем, `String => Int` и `Any => Int` то увидим прямо противоположную картину:
```scala
type Func[X] = X => Int // это не "новый тип", а всего лишь псевдоним!

// если скомпилируется, то такая подтипизация корректна
summon[     String  <:<      Any]
summon[List[String] <:< List[Any]]
summon[Func[Any]    <:< Func[String]]
```
Получается, что конструктор типов `[X] =>> X => Int` обращает подтипизацию в обратную сторону! (Для дуального типа `[X] =>> Int => X` подтипизация снова окажется прямой)))

А вот если мы наивно попробуем то же самое со своим классом, у нас ничего не получится:
```scala
class Test[A](val a: A)
summon[Test[String] <:< Test[Any]]    // ошибка!
summon[Test[Any]    <:< Test[String]] // ошибка!
```

Чтобы разобраться в чём причина, достаточно [~~просто прочесть документацию~~](https://docs.scala-lang.org/ru/tour/variances.html) посмотреть на определение типов `List` и `Function` (`=>`) в стандартной библиотеке:
```scala
type List    [+A]     = scala.collection.immutable.List[A]
type Function[-A, +B] = Function1[A, B]
```
Именно значки перед аргументами конструкторов типов определяют вид *вариантности*:
- `+` означает прямую *ковариантную* трансляцию подтипизации,
- `-` - инвертированную, *контравариантную*,
- нет значка - подтипизация блокируется - *инвариантность*.
(Псевдонимы типов по-умолчанию пробрасывают вариантность своих выражений без изменений.)

В представленном выше классе `Test` параметр `A` используется двояко - и как тип аргумента конструктора (контравариантно), и как тип проектора поля `a` (ковариантно). Следовательно, полиморфный тип, связанный с этим классом, является инвариантным. Попытки поставить в квадратных скобках перед `A` плюс или минус приведут к ошибке компиляции вида `contravariant type A occurs in covariant position in type A of value a` ("контравариантный тип A появляется в ковариантной *позиции* типа переменной a"). О какой же позиции тут идёт речь?

На первый взгляд может показаться, что имеется ввиду позиция "относительно стрелки" `=>`:
- отрицательная позиция (знак `-`), если слева от стрелки и
- положительная позиция (знак `+`), если справа.
Но не всё так просто))). Например, вот этот тип внезапно оказывается ковариантным:
```scala
type Func[+X] = (X => Int) => Int
summon[Func[String] <:< Func[Any]]
```
Аргумент `X` стоит левее сразу двух стрелок - дважды отрицательная позиция превращается в положительную! О причинах такого поведения знаков будет сказано в разделе **Контейнеры**.

Как уже не раз упоминалось, отношение подтипизации - это просто функция от одного типа к другому (неявное преобразование). Тогда, вариантность - это то, как подобные функции преобразуются "под действием" конструкторов типов. Такие преобразования описываются специальным классом типов - функтором (ковариантным или контравариантным). Про классы типов будет рассказано в **соответствующем разделе**.

![[Вариантность.png|Тип вариантности полиморфного типа F[_] проявляется в том, как отношения подтипизации (функции неявных преобразований) между A и B переносятся на типы F[A] и F[B]. Синими стрелками обозначены ключевые черты функтора: ковариантного или контравариантного, в зависимости от направления красной стрелки.]]

### Ограничения подтипизации

Привычный ООП-шный полиморфизм подтипов подразумевает, что в любую функцию мы можем передавать значения *любых типов*, являющихся подтипами к типу соответствующего параметра функции.

```scala
trait SupperClass { val i: Int }
case class SubClass(i: Int) extends SupperClass

def someFunc(x: SupperClass) =
  x.i + 3

val sub = SubClass(5)
someFunc(sub) // полиморфизм тут
```

Это эквивалентно ситуации, как если бы функция явно декларировала, что может принимать значения *разных типов* (т.е. имеет тип-параметр, превращающий её в обобщённую), но для которых задано определённое ограничение подтипизации.

Такая система типов (система $F_{<:}$), в которой универсальный полиморфизм сочетается с ограничениями подтипизации, реализуется во многих популярных языках, в том числе и в Scala. Например, во фрагменте кода выше достаточно изменить сигнатуру метода `someFunc`, чтобы продемонстрировать полиморфизм явно:
```scala
def someFunc[A <: SupperClass](x: A) =
  x.i + 3 // тело функции не меняется
```
Таким образом, система $F_{<:}$ позволяет относить полиморфизм подтипов к разновидности универсального полиморфизма.

Ограничения подтипизации для параметров обобщённых методов мощнее, чем полиморфизм подтипов. Рассмотрим пару примеров.

Следующий фрагмент кода показывает, что полиморфизм с ограничением подтипизации позволяет без потерь передать тип аргумента на выход функции:
```scala
trait SupperClass { val i: Int }
case class SubClass(i: Int, s: String) extends SupperClass
val sub: SubClass = SubClass(5, "string")

def extractInt1[A <: SupperClass](x: A): (A,           Int) = (x, x.i)
def extractInt2(x: SupperClass)        : (SupperClass, Int) = (x, x.i)

extractInt1(sub)._1.s // "string"
extractInt2(sub)._1.s // !!! Ахтунг !!! Тут нет никакого s!
```
В последней строке будет ошибка компиляции, так как функция `extractInt2` ничего не знает об исходном типе переданного ей аргумента - неявное преобразование подтипизации сработало *до того*, как значение было передано в функцию.

Выше были представлены такие ограничения, когда тип-параметр должен быть чьим-то подтипом - так называемые, *верхние границы типа*. Но существует также понятие *нижней границы типа*: запись `X >: SubType` означает, что тип-параметр `X` должен быть супертипом для некого фиксированного типа `SubType`. Наглядный пример использования такого ограничения можно подсмотреть [в официальной документации Scala](https://docs.scala-lang.org/ru/tour/lower-type-bounds.html).

В ранних версиях Scala была возможность использовать, так называемые, *ограничения представления*. Запись `A <% SomeType` означала, что известно некое неявное преобразование от типа `A` к типу `SomeType`, то есть, возможности типа `SomeType` применимы к значениям типа `A`. Такое преобразование вовсе не обязательно завязывалось на наследовании классов, вариантности обобщённых типов (`List[String] <: List[Any]`) или встроенной подтипизации (`Short <: Int`) - могут быть использованы в том числе и пользовательские неявные преобразования:
```scala
implicit def intToSubClass(i: Int) // объявляем неявное преобразование Int => SubClass
  = SubClass(i, "нечто") 
def getString[A <% SubClass](a: A) = a.s

getString(5) // "нечто"
```
В Scala 3 такой синтаксис убрали, но эффектов, аналогичных использованию ограничений `<%`, `<:` или `>:` можно достичь с помощью классов типов - об этом будет далее.

Отношения подтипизации можно ввести не только для простых типов, но и для полиморфных. Сделать это можно разными способами, но, пожалуй, самый очевидный из них - это *поточечная подтипизация*: считаем `F` подтипом `G`, если `F[X]` является подтипом `G[X]` для любого типа `X`. При подготовке статьи очень удивился, обнаружив, что такая подтипизация уже присутствует в Scala:
```scala
def headOption[F <: [X] =>> Iterable[X], A](fa: F[A]): Option[A] = fa.headOption
  
headOption(List(5))          // Some(5)
headOption(Option("строка")) // Some("строка")
headOption(Map(1.2 -> true)) // Some((1.2, true))
```
К сожалению, в актуальной на данный момент версии Scala в ограничении приходится явно указывать $\lambda$-выражение для типов, что выглядит коряво. Тем не менее, язык живёт, меняется, так что посмотрим что будет дальше.

Очевидно, поточечную подтипизацию по индукции можно распространить и на полиморфные типы более высокого рода. Так что давайте посмотрим на обобщённые типы с точки зрения их "высокородности".

## Типы высокого рода

### Higher Kinded Types

В математике существуют такие понятия, как
- функционал, превращающий функций в "простые" нефункциональные значения (например, интегральная свёртка),
- оператор, превращающий одни функции в другие (например, дифференцирование).
В отличие от обычных функций, такие отображения связывают не только простые множества, вроде действительных чисел, но и множества функций!

Отображения, из функций и/или в функции в информатике называются [*функциями высших порядков*](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%B2%D1%8B%D1%81%D1%88%D0%B5%D0%B3%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0) (higher-order functions). Такие функции могут оперировать не только "простыми" функциями (первого порядка), но и такими же функциями высших порядков. При этом, "порядок" новой функции будет выше чем, у тех, которые она принимает/возвращает.

>Функция, как набор инструкций, размещённых в памяти, представляет собой обычное значение, и даже в Ассемблере можно было передавать указатель на функцию в другую функцию, вызывать её по указателю, или возвращать его.  Но сам термин "функции высших порядков" вошёл в оборот, только кода в популярных высокоуровневых языках появилась *возможность использовать функции как значения* - "[функции первого класса](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)".

В свою очередь, конструкторы типов, как уже было замечено, представляют собой функции на уровне типов - отображают одни типы в другие. Имеющиеся в системе $F2$ "простые" конструкторы типов (переводящие один простой тип в другой) в системе $F\omega$ расширяются *функциями высших порядков на типах* - **higher kinded types** (HKT).

Слово "kind" вызывает известные трудности перевода. Часто встречаются такие варианты:
- **кайнд** - незамысловатая транслитерация, заимствование из английского, которое не все считают оправданным;
- **сорт** в русском языке привычно индексируется натуральными числами, что порождает эклектику вроде "типов третьего сорта";
- **род** также превносит в предметную область не очень уместную аристократическую "высокородность";
- **вид** типа кажется хорошим вариантом перевода, если опять же избегать словосочетания "типы высокого вида".
Далее будут рассмотрены *виды* типов высокого *рода*)), так что будут использоваться два варианта перевода слова "kind".

Рассмотрим такие примеры:
```scala
type Option = [A] =>> Unit | A
type Reader = [Dep] =>> [A] =>> Dep => A
type Functor = [F[_]] =>> [A, B] => (A => B) => (F[A] => F[B])
type TaglessFinalProgram = [Algebra[_[_]]] =>> [A] =>> [F[_]] => Algebra[F] => F[A]
```
Конструктор `Reader` принимает на вход тип зависимости и возвращает другой конструктор, принимающей тип результата и возвращающий тип функции. По сути, `Reader` является каррированной версией конструктора типов, принимающего два параметра. В свою очередь `Functor` принимает на вход уже не простой тип, а другой конструктор, и возвращает простой тип полиморфной функции.

Не каждый тип может быть подставлен в эти конструкторы типов:
```scala
type FOpt = Functor[Option]
//type FReader1 = Functor[Reader]       // нельзя!
type FReader2 = Functor[Reader[Int]]
//type FInt = Functor[Int]              // нельзя!
type OptInt = Option[Int]
//type OptReader1 = Option[Reader]      // нельзя!
//type OptReader2 = Option[Reader[Int]] // нельзя!
type OptReader3 = Option[Reader[Int][String]]
type OptF = Option[Functor[Option]]
//type Reader1 = Reader[Int]            // нельзя!
type Reader2 = Reader[Int][String]
```
Полиморфные типы добавляют красок в однообразие простых типов - теперь они не все одинаковые)). Но это приносит не только радость. Ведь даже для простых конструкторов типов вроде `Option` возникает вопрос: можно ли считать типы высокого рода, собственно, типами, если их нельзя приписать к значениям, как метки? Какой смысл может иметь запись `val opt: Option`?

Можно, конечно, пофантазировать, сказав, что подставив в значение `opt` конкретный тип, мы сможем получить новый тип, например `val intOpt: getType[Int](opt) = Some(42)`. Конечно, всё зависит от языка, и, хотя конкретно так Scala не умеет, но с помощью определённых костылей (основанных на полиморфных функциях и зависимых типах) можно добиться схожего результата, но…

Действительно, для типов высокого рода не предусмотрено использование в качестве меток термов, так что на самом деле **полиморфные типы не являются типами**! (См. также [тут](https://stackoverflow.com/questions/54620961/can-type-constructors-be-considered-as-types-in-functional-programming-languages).) Конструкторы типов называют типами скорее по аналогии с функциями высших порядков, которые все являются значениями (функции первого класса). В Scala есть синтаксис, использование которого позволяет трактовать конструкторы типов как метки, но уже не для значений, а для других типов - это будет рассмотрено при обсуждении классов типов.

Другие примеры использования типов высокого рода можно подсмотреть, например, тут:
- [Higher-kinded data in Scala](https://github.com/Michaelt293/higher-kinded-data),
- GitHub-проект [DataPrizm](https://github.com/Katrix/DataPrism) (и [статья об использовании типов высокого рода](https://bora.uib.no/bora-xmlui/bitstream/handle/11250/3073826/Generic-programming-using-Higher-Kinded-Data.pdf), в этом проекте).

### Вид типа

Приведённые выше примеры на Scala полиморфных типов и варианты их использования демонстрируют, что типы высокого рода могут относится к разным **видам типа** (type kinds). В определениях этих типов однозначно указывается, параметры какого вида типов они принимают: `A`, `F[_]`, `Algebra[_[_]]`. Такие параметры должны быть либо простыми типами, либо другими конструкторами типов - отображениями из типов в простые типы.

Для видов типов разработана своя система обозначений. Вид простых типов обозначается звёздочкой $\star$. Вид конструкторов типов, принимающих на вход простые типы, записывается как $\star\rightarrow\star$. Все остальные виды типов строятся по индукции. В языках семейства ML (том же Haskell) функции сразу записываются в каррированном виде, это же правило относится и к конструкторам типов. В Scala использован более традиционный синтаксис, когда функция может принимать несколько параметров, разделённых запятыми - это также отражается на реализации конструкторов типов. В итоге получаем следующую формализацию:
> *Вид типа - это либо вид простых типов ($\star$), либо отображение ($\rightarrow$) из одного вида типа (или нескольких через запятую) в другой вид типа.*

Стрелка, как оператор, обычно подразумевает правую ассоциативность, поэтому вид $\star\rightarrow(\star\rightarrow\star)$ эквивалентен виду $\star\rightarrow\star\rightarrow\star$. Таким образом, в конце каждого вида типа после стрелочки будет вид простого типа $\star$ - любой вид типа описывает конструкторы простых, истинных типов!

Можно привести такую таблицу соответствия видов типа и параметров конструкторов типа:

| Вид типа                                                    | Параметр конструктора типа                                                | Пример                                |
| ----------------------------------------------------------- | ------------------------------------------------------------------------- | ------------------------------------- |
| $\star$                                                     | `A`                                                                       | `Int`                                 |
| $\star\rightarrow\star$                                     | `F[_]`                                                                    | `Option`                              |
| $\star\rightarrow\star\rightarrow\star$                     | `F[_][_]`, но Scala не умеет работать с параметрами каррированного вида(( | `Reader` из примера выше              |
| $(\star\rightarrow\star)\rightarrow\star$                   | `Alg[_[_]]`                                                                 | `Functor`                             |
| $((\star\rightarrow\star)\rightarrow\star)\rightarrow\star$ | `Prog[_[_[_]]]`                                                           | `TaglessFinalProgram` из примера выше | 
| $(\star,\star)\rightarrow\star$                             | `M[_, _]`                                                                 | `Map`                                 |
Ещё раз стоит обратить внимание на вид типа `Functor` из примера выше - в Scala конструкции вроде `[A, B] => ...` обозначают *простой тип* полиморфной функции, поэтому в итоге и получается вид $(\star\rightarrow\star)\rightarrow\star$.


- связь типов `⋆ => ⋆` с логикой второго порядка (и вывод связи с логиками высших порядков)

[[Generic-programming-using-Higher-Kinded-Data.pdf]]

https://gist.github.com/kubukoz/5f6dd415eb3345a8300d91cfc6209a10
https://stackoverflow.com/questions/72407103/problem-with-given-instances-writing-mtl-style-code-with-scala-cats
https://codegolf.stackexchange.com/questions/205809/implement-ski-combinator-calculus

### Вселенные типов

[Решение задачи о 8 ферзях на трёх уровнях Scala — программа, типы, метапрограмма](https://habr.com/ru/articles/725462/)

Парадоксы, характерные для множеств, проявляются и для типов.
Например, парадокс Жерара демонстрирует, что **тип всех типов невозможно построить**.
Один из способов избегания такого рода парадоксов - введение **кумулятивной вселенной типов**.
(В теории множеств есть аналогичная идея - вселенные Гротендика, но это другая история)

* Каждый терм вводится с указанием своего типа.
* Следовательно, каждый тип, будучи термом, имеет свой тип.
* Но тип типа уже не будет принадлежать той же вселенной типов, что исходный тип - он будет принадлежать следующей вселенной типов.
* Таким образом, вселенные типов образуют совокупность, индексированную натуральными числами.
* Каждый тип принадлежит не только своей вселенной, но и всем вселенным с более высоким индексом (**кумулятивность**).
Например, в программировании обобщённые типы (`list`, `option`, `Task`) относятся к вселенным более высоких индексов чем простые типы (`integer`, `boolean`, `string`, пользовательские простые типы и т.п.).

### Кодировки Чёрча

[Scala type level encoding of the SKI calculus](https://michid.wordpress.com/2010/01/29/scala-type-level-encoding-of-the-ski-calculus/)
[Type level lambda calculus in Scala (github)](https://github.com/tarao/lambda-scala)
https://github.com/folone/type-level-birds/blob/master/src/main/scala/Birds.scala

[Typelevel fix point](https://jto.github.io/articles/typelevel-fix/)


### Полиморфизм видов

Прогулки по мультивселенной могут оказаться весьма опасными для неподготовленного программиста, поэтому предлагаю вернуться домой, к классам и типам.

## Классы типов

### Это вам не типы классов!



[Type classes в Scala](https://habr.com/ru/companies/tinkoff/articles/147759/)
[Классы типов в Scala (с небольшим обзором библиотеки cats)](https://habr.com/ru/articles/318960/)

[[TypeClasses.pdf]]

Любой ли обобщённый тип можно интерпретировать, как описание класса типов? Рассмотрим такой фрагмент кода:
```scala
def isValid[A: Set] // Тип A должен принадлежать некому классу Set
  : A => Boolean    // Аннотация типа не обязательна
  = summon[Set[A]].contains

given validInts // Помещаем значение класса Set типа Int в контекст
  : Set[Int]
  = Set(2, 3, 5, 7, 11)
isValid(42)     // Класс Set для типа Int неявно найден в контексте
//isValid("42") // Ошибка! В контексте не найден класс Set для типа String!
```
Безотносительно того, что размещать в контексте неявное значение "слаботипизированного" типа `Set[Int]` достаточно безответственно, но, в целом, очевидно, что ответ на поставленный выше вопрос утвердительный.

#### Отличие от Haskell
[Type classes in Scala](https://scalac.io/blog/typeclasses-in-scala/)
> In comparison, a type class in Haskell can **only have one instance**. In Scala, we can define an instance and pass it as a parameter explicitly (not relying on implicit resolution), which makes the usage less convenient, but may be useful.

#### Ключевое слово `derived`
### Специальный полиморфизм

### Реализуем ООП

### Семейства типов

В третьей версии Scala появилась возможность использовать в выражениях типов [сопоставления с шаблонами](https://docs.scala-lang.org/scala3/reference/new-types/match-types.html). 

## Типы-контейнеры

### Контейнеры

Для обобщённых типов есть ещё одна любопытная трактовка

### Эффекты

[Линейные типы в Scala](https://github.com/earldouglas/linear-scala)

### Tagless Final
[Optimizing Tagless Final – saying farewell to Free](https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html)

### Ко-контейнеры и другие

## Подкатегории типов (анонс)

## Заключение

