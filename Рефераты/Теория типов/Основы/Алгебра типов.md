
### Изоморфизм
В предыдущем разделе на первой диаграмме показан тип $B$, который можно было представить и как $A+A$ и как $A\times2$. Эти представления не эквиваленты - они предоставляют разные способы работы со значениями этих типов. Но между множествами их значений можно построить **взаимно-однозначное соответствие**:
```scala
  type Int2 = (Int, Boolean)      // Int × 2
  type IntOrInt = Int Either Int  // Int + Int

  def туда(i2: Int2): IntOrInt =
    i2 match
      case (i, true)  => Right(i) // конструктор правого слагаемого
      case (i, false) => Left (i) // конструктор левого  слагаемого
      
  def обратно(ii: IntOrInt): Int2 =
    ii match
      case Right(i) => (i, true)  // правое слагаемое
      case Left(i)  => (i, false) // левое  слагаемое
  
  assert((обратно compose туда)(i2) == i2) // для любых i2
  assert((туда compose обратно)(ii) == ii) // для любых ii
```
Если мы можем предоставить две такие функции между типами, композиция которых даёт тождественные отображения, то говорят, что типы **изоморфны**. При использовании изоморфных типов будут отличаться разве что синтаксические конструкции, но это будут по прежнему одни и те же данные.

В программировании изоморфизм двух типов соответствует **взаимной подтипизации** - изоморфные типы являются подтипом друг друга. Понятное дело, что такое не получится организовать через "наследование".

Используя обозначение $\cong$ мы можем записать изоморфизм из примера выше так:
$$A+A\cong A\times2,$$
где $2$ - это тип с двумя значениями. 

Аналогично, для изоморфизма $$A\times A\cong A^2,$$можно предоставить такие методы:
```scala
  type IntInt = (Int, Int)        // Int × Int
  type BoolToInt = Boolean => Int // 2 => Int

  def туда(ii: IntInt): BoolToInt =
    b =>
      if (b)  ii._1
      else    ii._2

  def обратно(i2: BoolToInt): IntInt = (
    i2(true),
    i2(false),
  )
  
  assert((обратно compose туда)(ii) == ii) // для любых ii
  assert((туда compose обратно)(i2) == ii) // а так Scala не сумеет))
```

Старая добрая школьная алгебра, не так ли? Более того, суммы и произведения типов удовлетворят (с точностью до изоморфизма) основным алгебраическим законам:
- *коммутативность*: $A+B\cong B+A,\;A\times B\cong B\times A$;
- *ассоциативность*: $A+(B+C)\cong(A+B)+C,\;A\times(B\times C)\cong(A\times B)\times C;$ 
- *дистрибутивность*: $A\times(B+C)\cong A\times B+A\times C.$

Как правило, эти законы не работают в популярных языках программирования автоматически. Разве что, в Scala эти правила выполняются для объединения и пересечения типов, которые для *различающихся* типов с натяжкой можно считать суммой и произведением. Но в Scala есть техническая возможность связать изоморфизмом типы, ненаследующие друг другу, реализовав неявные преобразования между ними.

Для экспоненциала также можно записать знакомые со школы выражения. Но зачастую для них в языках программирования предоставляются специальные механизмы. Рассмотрим их подробнее.

### Cопоставление с шаблонами

Тип суммы определяется своими конструкторами - способами получения значения этого типа. Но гораздо важнее то, как мы эти значения сможем **использовать** - как из них можно получить значения другого типа. Общие соображения подсказывают нам, что для того чтобы преобразовать значения типа суммы в другой тип, нужно предоставить соответствующие преобразования в этой тип из значений типов-слагаемых. Алгебраические соотношения говорят нам то же самое:
$$A^{B+C+D}\cong A^B\times A^C\times A^D.$$
То есть, функцию из $B+C+D$ в $A$ можно построить, если у нас есть все три функции в $A$ из $B$, $C$ и $D$. Для этих целей и предназначен упомянутый ранее механизм *сопоставления с шаблонами*:
```scala
  val patternMatching         // Int + Boolean + Double => String
    : Int | Boolean | Double => String =
      case i: Int     => "целое " + i        // Int     => String
      case b: Boolean => "булево " + b       // Boolean => String
      case d: Double  => "рациональное " + d // Double  => String
```
Компилятор сам отслеживает, чтобы при сопоставлении с шаблонами были учтены все альтернативы - все слагаемые типа-суммы, и чтобы у каждой ветки был обработчик-функция соответствующего типа.

Для стандартных (и многих сторонних) типов-сумм в Scala предоставляются специальные методы, дающие те же возможности, но без необходимости использовать синтаксический сахар:
```scala
  val eFold: Int Either Double => String = // Int + Double => String
    intOrDouble => intOrDouble.fold(       // λ-выражение
      i => "целое " + i,                   // Int          => String
      d => "рациональное " + d)            // Double       => String
```

### Каррирование

Чтобы вычислить некоторое выражение, зависящее от переменных, нужно построить на его основе функцию и передать эти переменные как аргументы (захват переменных, определённых вручную, сейчас рассматриваем). Но сделать это можно несколькими способами:
```scala
  val f1
    : (Int, Boolean) => String
    = (i, b) => if ((i > 0) && b) "тру!" else "дырка!"

  val f2
    : Int => (Boolean => String)  // скобки лишние ("правая ассоциативность")
    = i => b => if ((i > 0) && b) "тру!" else "дырка!"

  f1(-2, false) // "тру!"
  f2(-2)(false) // "тру!"
```
Функции - это "первоклассные объекты", и мы можем просто вернуть из функции другую функцию, в теле которой "захвачен" аргумент родительской!

Две функции из примера выше основаны на одном выражении `if ((i > 0) && b) "тру!" else "дырка!"` и отличаются друг от друга только способом связывания переменных и своим типом. Не сложно догадаться, что эти типы также связаны изоморфизмом. Соответствующие функции преобразования от одного типа к другому очевидны, и они уже есть в Scala - это метод `curried` (в Scala функции являются экземплярами ООП-класса, и имеют свои методы) и функция `Function.uncurried`:
```scala
  import Function.uncurried
  assert(f1.curried(i)(b)    == f2(i)(b)) // для любых i, b
  assert(uncurried(f2)(i, b) == f1(i, b)) // для любых i, b
```

Ниже приведён немного искусственный пример использования метода `curried`:
```scala
  // Int × (Int => Int) => Int
  def doubleModification(i: Int, modifier: Int => Int): Int =
    modifier(modifier(i))

  val sum
    : (Int, Int) => Int
    = (a, b) => a + b
  sum(2, 2)                    // 4

  val add5 = sum.carried(5)    // Int => Int
  doubleModification(2, add5)  // 12
```
У нас есть функция, `doubleModification`, которая принимает целое число, некоторую функцию-модификатор, и применяет эту функцию к целому числу *дважды*. И так же есть функция от двух целых чисел, просто складывающая их. Для двойного прибавления к некому числу (например, 2) заданного числа (например, 5) можно сперва построить каррированную версию функции сложения, и применить её к прибавляемому числу (5). Так мы получим функцию, принимающую только один аргумент - оставшееся слагаемое. И эту функцию мы можем смело передавать в `doubleModification`.

Ключевой момент здесь - чтобы скомбинировать сложение с `doubleModification` нам не нужно описывать новую функцию вручную - мы просто (явно, с помощью `curried`) получаем значение изоморфного функционального типа!

Из примеров выше видно, что в Scala и вызов, и определение функции и её каррированной версии отличаются лишь синтаксисом. В некоторых языках программирования (например ML-семейство - Haskell, F# и т.п.) для таких функций используется одинаковый синтаксис. Например в F#:
```fsharp
let sum a b = a + b
let four = sum 2 2 // 4
let add2 = sum 2   // Int => Int
let five = add2 3  // 5
```

Не важно, как вашем любимом языке программирования обрабатывается каррирование, само по себе оно является следствием "школьного" алгебраического изоморфизма типов:
$$A^{B\times C}\cong \left(A^B\right)^C.$$

### (Не)важные понятия

Видимо так сложилось исторически, но в программировании накопились такие "важные" понятия:
- *каррированная функция*,
- *частичное применение* (каррированной функции),
- функции, как *объекты первого класса*,
- функции *высокого рода*,
- и т.п.

"Необходимость" знания таких "высокородных первоклассностей" повышает порог вхождения в функциональное программирование, но при этом сами понятия практически не имеют самостоятельного веса... Самое важное, что нужно понимать - это то, что в теории типов и в программировании функции являются **обычными значениями обычных (функциональных) типов** - и, так же как и другие значения, их можно передавать как параметры функций и возвращать их из функций. Да, существуют языки программирования, которые так не умеют, но мало кто о них знает, и "тут о таких не поют".

### Единица

Иногда возникает необходимость в "забывающих" функциях, отображающих значения некого типа в тип, который даже не помнит, каким путём были получены его значения. Значение этого типа отражает лишь сам факт *существования* чего-то, что мы можем передать на вход другой функции. Для любого типа есть только одна возможность, чтобы забыться - это функция которая просто игнорирует свой аргумент и возвращает единственное значение "типа-существования". Такой *тип-одиночка* называется **единицей** $1$, а единственность способа получения его значения из других типов - это его *универсальное свойство*.

Такой "забывчивый" тип часто встречается в программировании. Но в некоторых языках программирования он доступен не как самостоятельный тип, а как некая синтаксическая конструкция. Например, процедура, которая не возвращает (осмысленного) значения часто обозначается ключевым словом `void`. Такая "пустота", получающаяся после вызова процедуры, на самом деле не является совсем уж "ничем" - у нас по прежнему *существует возможность* продолжать вычисления. Таким образом, процедуры аналогичны функциям, **возвращающим** значение типа-единицы. Типы этих функций, ввиду *универсального свойства* единицы, являются типами-одиночками, что соответствует известному алгебраическому тождеству: $$1^A\cong1$$

С другой стороны, когда мы вызываем функцию *без параметров*, мы в любом случае передаём ей саму *возможность* производить вычисления. Функции без параметров - это отображения **из** типа единицы. Во многих языках программирования при вызове таких функций необходимо указать пустые круглые скобки. В Scala такая конструкция считается литералом типа `Unit` - той самой единицы:
```scala
  val unitId
    : Unit => Unit // функция из единицы в единицу
    = u    => ()   // "забываем" единицу))

  assert(unitId(()) == ())
```
Несложно заметить, что типы таких функций изоморфны типам, которые они возвращают - между ними также можно построить знакомый изоморфизм: $$A^1\cong A.$$

Тип-единица определяется однозначно, но с точностью до изоморфизма - два любых типа-одиночки (с единственным значением) изоморфны друг другу. Но не эквивалентны - они отличаются семантикой, связанными с ними функциями. В Scala часто встречаются такие типы-одиночки:
- `None` - подтип `Option[A]`, определяющий факт отсутствия значения типа `A`.
- `Nil` - подтип `List[A]`, означающий пустой список.
Так как они являются подтипами, для них заданы функции неявного преобразования к своим супер-типам. Эти функции определяют их семантическое различие, но очевидно, что они остаются изоморфными `Unit`.

Из этих примеров видно, что типы-одиночки частенько используются в качестве слагаемых для типов сумм. Например тот же тип `Option` можно представить, как
$$Option[A]\cong A+1,$$
где $1$ соответствует типу-одиночке `None`.

С другой стороны, когда тип-единица выступает в качестве "множителя" для некого типа-произведения, он не привносит новой информации, и всегда можно предоставить такой изоморфизм:
```scala
  def туда(a: A): (A, Unit) = (a, ())
  def обратно(pair: (A, Unit)): A = pair._1

  assert((обратно compose туда)(a) == a)              // для любых a
  assert((туда compose обратно)((a, ())) == (a, ()))  // для любых a
```
Этот изоморфизм представляет собой обычные алгебраические законы для произведения:
$$A\times1\cong A.$$

В документации Scala сказано, что супертипом для всех типов языка является `Any`. Однако, универсальный морфизм для `Unit` встроен в язык как _неявное преобразование_, так что, следуя написанному ранее определению типизации, `Unit`, будучи *подтипом* `AnyVal` и `Any`, в то же время является _супертипом_ для всех остальных типов, в том числе и для Any:
```scala
  val any: Any = new {}
  val unit: Unit = any            // из Any в Unit
```
Впрочем, компилятор Scala будет выдавать предупреждения при использовании неявных преобразованиях к `Unit`, считая что, скорее всего, вы делаете что-то не то. Наличие неявных преобразований от `Any` к `Unit` и обратно ("зацикливание" подтипизации) не образует изоморфизм, так как применение их композиции к значению типа `Any` в общем случае не вернёт значение, равное ему же. Дело в том, что значения типа `Any` "помнят", каким путём они были получены, и их можно использовать, например, в сопоставлениях с шаблонами, но `Unit` не является суммой типов - его единственное значение не знает ничего, кроме факта своего существования.

### Ноль

Значительно реже, чем "забывание" типа, бывает полезным описать полное обрывание вычисление, без получения какого-либо значения вообще. Это может быть бесконечный цикл/рекурсия, или возникновение исключения. Чтобы продемонстрировать, что функция вообще не завершается, можно прописать, что она отображает некий тип в другой, у которого не может быть значений по определению!

Для типа-ноля существуют очевидные изоморфизмы:
$$A+0\cong A,$$
$$A\times0\cong 0,$$
$$A^0\cong1.$$
Рассмотрим последний изоморфизм подробнее. Функция, которая ведёт от ноля к любому заданному типу (в том числе к нолю) типу имеет единственную реализацию. Или точнее, если имеется несколько таких функций, не получится различить их, потому невозможно передать в эти функции значение типа $0$, ведь у него вообще нет значений!

С типами функций, ведущими к нолю, ситуация интереснее. Если $A\ncong0$, то, внезапно, $0^A\ncong0$. Неформально это можно трактовать так, что у нас есть разные способы "повесить" или вообще прервать вычисление.

Во многих популярных языках программирования нет соответствующего типа. В Scala такой тип есть - он называется `Nothing`. Также там есть библиотечная функция, которая определяется примерно так:
```scala
val ???                     // вполне допустимый идентификатор Scala
  : Unit => Nothing         // из единицы в ноль
  = u    => throw Exception // никогда не вернёт значение

// использование:
val a: A = ???              // заглушка, скомпилируется без реализации
```

Тип ноль чаще используется как аргумент обобщённых типов, например, с его помощью реализованы упомянутые выше типы-одиночки `None` и `Nil`. Но в этой статье мы не будем рассказывать об обобщёных типах.

Для типа-ноля можно построить изоморфные ему типы, для которых также невозможно получить экземпляр. Такие типы так же используются как параметры обобщённых типов и призваны прежде всего отличать одни типы от других - несмотря на изоморфность друг другу, они несут семантику *неэквивалентности*.