
### Предпосылки

С давних времён люди находили нечто общее в решаемых задачах из самых разных сфер жизни. Например, если одна корова да ещё одна корова - это две коровы, то такое же рассуждение справедливо и для яблок. В этом рассуждении ключевую роль играют не коровы (и, тем более, не яблоки), а [**числа**](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE) - одна из первых математических абстракций.

Более четырёх тысяч лет назад в древнем Междуречье люди [умели вычислять](https://elementy.ru/nauchno-populyarnaya_biblioteka/434752/Matematika_v_Mesopotamii) объёмы крепостных стен, площади земельных участков, динамику численности стад и проч. Тогда на примере конкретных житейских проблем были описаны **способы вычисления**, которые применимы для широкого спектра задач, достаточно лишь заменить числа в условии. Но лишь в средние века в Европе в обиход вошло понятие «[алгоритм](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC "Алгоритм")» (по имени [учёного IX века](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C-%D0%A5%D0%BE%D1%80%D0%B5%D0%B7%D0%BC%D0%B8)), для которого необходимо использование новой абстракции - [**переменной**](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD%D0%B0).

Термин "переменная" вовсе не означает, что связанное с ней значение будет меняться по ходу выполнения алгоритма, но значение будет разным для разных задач, которые призван решать этот алгоритм. Обычно, наоборот, подразумевается, что в течении решения задачи переменная остаётся неизменяемой. (Есть конечно исключения, например, когда переменная связана квантором суммы и действительно пробегает ряд значений; при рекурсии переменная может иметь разные значения в разных итерациях, но в каждой итерации значение будет фиксировано по умолчанию). Если же какое-либо значение окажется фиксированным для всего класса задач, то такое значение принято называть **константой** алгоритма.

Алгоритм описывает, что мы должны сделать с переменными, не зависимо от того, какие значения (из некоторого **набора** возможных значений) будут **подставлены** вместо неё при решении конкретной задачи. Таким образом, "переменная" представляет собой значение из некоторого **множества** возможных значений.

Свойства таких наборов-множеств, их взаимоотношений исследуются веками. В XIX веке активно ищутся способы нахождения корней многочленов (см. [алгебраические замыкания](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8_%D0%B7%D0%B0%D0%BC%D0%BA%D0%BD%D1%83%D1%82%D0%BE%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B5)), для упрощения сложных задач изучается разделение множеств на классы эквивалентности (см. например, [классы вычетов](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_%D0%B2%D1%8B%D1%87%D0%B5%D1%82%D0%BE%D0%B2)) и многое другое. Внезапно оказалось, что четкое понимание множества категорически необходимо в самых разных областях математики, которые развиваются зачастую независимо друг от друга узкими специалистами. Множества представляются потенциальным фундаментом, на котором можно построить **единый способ проверки корректности любых алгоритмов**!

Ближе к XX веку в научном сообществе накопилась необходимость к формализации понятия "множество". Это было исторически неизбежно, и не так важно, кого бы назвали первым.

### Множества

Множество определяется условием **принадлежности** к нему какого-либо элемента (которое, например, может быть другим множеством): $a\in A$.
Существует выделенное пустое множество $\emptyset$, такое что для любого $a$ утверждение $a\in\emptyset$ ложно. Задать множество можно двумя способами:
* **экстенсионально** - просто перечислив его элементы - $\{a, b, c\}$;
* **интенсионально** - указав условие, по которому можно выбрать некоторые элементы существующего множества - $\{$*множество всех людей, кто сейчас читает эту статью*$\}$.

Интенсионально, через условие, определяются основные операции над множествами.
![[операции над множествами.png]]

Также важно понятие отношения между множествами, в частности, равенство множеств.
![[отношения множеств.png]]

### Парадоксы

Оказывается, что некоторые предикаты не позволяют определить множество. Возникают разного рода [парадоксы](https://habr.com/ru/post/197578/):
* не существует множества всех множеств,
* не существует множества элементов, не равных самим себе,
* и т.п.
Попытки построить такие множества неизбежно приводят к противоречиям.

Вводится понятие **класса** - совокупности объектов, удовлетворяющих некому условию. При этом, каждый класс может быть
* либо множеством,
* либо **собственным классом** ("больше" чем множество).

Парадоксы сигнализируют о "дырявости" концепции, не позволяющей использовать её для контроля корректности алгоритмов. Избежать таких проблем можно с помощью [ограничений теории](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2#%D0%90%D0%BA%D1%81%D0%B8%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2 "Теория множеств"), запрещающих появление парадоксальных утверждений, или расширений, например, привлекая концепцию [кумулятивных вселенных](https://ru.wikipedia.org/wiki/%D0%A3%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D1%83%D0%BC_%D0%93%D1%80%D0%BE%D1%82%D0%B5%D0%BD%D0%B4%D0%B8%D0%BA%D0%B0).

### Неразличимость и вычисления

Итак, множества нужны прежде всего для того, чтобы характеризовать алгоритмы-функции, отношения совокупностей входных и выходных данных для них.
![[отображения множеств.png]]
Биекция задаёт класс эквивалентности множеств, что приводит к понятию **мощности** множества. Множества одинаковой мощности, без обогащения иными математическими структурами являются эквивалентными, неразличими!

Например, восьмибайтовая ячейка памяти может хранить в себе значения как из множества `Int64`, так и из `double` - эти множества имеют одинаковую мощность, но чтобы различить их необходимо для них предоставляется **разный набор возможностей**. Или житейский пример: мы не сможем отличить множество коров от множества яблок, если и яблоки и коровы не только выглядят, но даже пишутся одинаково))). А если не одинаково, значит у нас есть **дополнительная структура** над множествами - операция отношения, которая позволяет сравнить корову с яблоком.

### Пример - свертка списка

Рассмотрим класс задач свёртки списков элементов из выбранного множества - получение на основе списка единственного значения из этого же множества. Суммирование чисел, конкатенация строк или даже получение большой инструкции из последовательности небольших инструкций - всё это частные случаи задач, относящиеся к тому же классу.

Для такого класса задач нам требуется дополнительная структура над множествами - набор функций позволяющий "уменьшать количество" элементов списка. Такая структура называется "**моноид**". Абстрактный моноид обычно описывается так:
* некое **множество** (числа, строки...),
* бинарная операция на этом множестве - принимает два элемента множества, и "сворачивает" их в один (сложение, умножение чисел; конкатенация строк или вычисление самой длинной и т.п.),
* нейтральный элемент из этого множества - значение "по умолчанию" для случая пустого списка (единица для умножения, пустая строка для конкатенации...),
* "законы":
	* ассоциативность бинарной операции позволяет производить свёртку "в любом направлении" (порядок элементов списка не имеет значения), и даже параллельно (как будто разбиваем список на список нескольких списков и сворачиваем их независимо друг от друга),
	* свойства нейтрального элемента по отношению к бинарной операции.

На практике для построения алгоритмов с использованием, например, того же моноида "лишним" в его определении оказывается... множество! В самом деле, для суммирования списка (заданы ассоциативная бинарная операция и $0$) инструкции не меняются, если в качестве множества мы выбираем `int`, `double` или `string` - описание алгоритма остаётся тем же! Фактически, множество выступает всего лишь как некий ярлык - связующее звено для композиции различных возможности (моноида и прочих). Так на переднем плане появляется концепция типа.
