
### Определение типа

Тип - это не более чем некая метка, приписываемая _к каждому_ терму (переменной, выражению и т.п.). Типы позволяют формализовать возможные преобразования термов, без изучения их внутренней структуры, составляющих их элементов. Суть типа полностью определяется совокупностью отображений (функций), связывающих его с другими типами. Зачастую такие отображения бывает удобно отобразить на диаграмме в виде ориентированного графа:
![[определение типа.png]]

Типы отличаются друг от друга только своим положением на такого рода диаграммах. Чтобы определить тип нужно
* указать совокупность "входящих" отображений (также говорят "инъекторы" или "конструкторы");
* указать совокупность "исходящих" отображений (также говорят "проекторы").

Смоделировав задачу в виде диаграммы типов и честно предоставив реализации всех функций, связывающих типы на диаграмме, мы можем построить корректный (но это ещё не точно)) алгоритм решения задачи.

На картинке выше видно, что
* если у нас есть объект типа $A_1$, или $A_2$, то мы можем считать, что у нас есть (мы всегда можем получить) и объект типа $C$.
* с другой стороны, если у нас есть объект типа $C$, то у нас есть (мы можем получить) объекты типов $B_1$ и $B_2$.

Можем ли мы определить тип $C$, как "$A_1$ **или** $А_2$"? Или как "$B_1$ **и** $B_2$"? Формально, мы можем всё, мы ж программисты!!

Но к сожалению, такого рода утверждения не будут считаться полными и однозначными определениями. В нашем случае, мы должны ещё гарантировать, что нет никаких $A_3$, $B_3$ и прочих, кто ещё связан отображениями с $C$. Но с другой стороны, например, если для $A_1$ есть отображение в $A_2$, то $A_2$ вполне можно исключить из определения типа $C$. Аналогично, среди типов $B$ также могут найтись те, кто связан с отображениями, значит там тоже кого-то можно исключить из формулировки $C$ через произведения. Так что из всех возможных типов-претендентов называться **суммой** или **произведением** типов, нам нужно выбрать "наилучшего" универсального представителя. Нам нужно некое **универсальное свойство**.

### Универсальное свойство

Универсальное свойство какой-либо конструкции в теории типов (на базовом уровне) определяется **единственностью** функции из любого типа-кандидата в "наилучший" тип, либо же, наоборот, в обратную сторону. "Единственность" функции, идущей от одного типа к другому, означает **эквивалентность** всех функции также связывающих эти типы. Такой "наилучший" тип и семейство уникальных морфизмов также называют "универсальными".

Универсальное свойство в теории типов можно определить как-то так:
> Существует тип и единственная функция принимающая (или возвращающая) значения этого типа, такая что соответствующая диаграмма будет коммутативной.

Звучит, пожалуй, сложновато)). Наверное, на начальном этапе универсальное свойство стоит воспринимать просто как некий универсальные способ однозначного формулирования различных абстракций поверх теории типов.

Сейчас имеет смысл, разве что, сказать пару слов про упомянутую "коммутативность".

### Функции и их композиция

Диаграмма считается коммутативной, если двигаясь по стрелкам *разными* путями от любого значения одного типа к другому мы получим *одинаковый* результат ("перестановочность путей"). Например, посмотрим на такую диаграмму:
![[композиция функций.png]]
Здесь $g \circ f$ - это **композиция функций** $f$ и $g$:
```scala
def f(a: A): B = ??? // какая-то функция
def g(b: B): C = ??? // какая-то функция
def h = g compose f  // получилась функция из A в C
```
С непривычки может смутить странный порядок операндов для композиции функций - "с конца в начало". Получается что-то вроде такого: "функция $h$ возвращает результат применения функции $g$ к результату применённая функции $f$". На самом деле возможное удивление - это следствие привычек. Со временем вы можете обнаружить, что именно такой порядок операндов наиболее логичен)).

Так вот диаграмма для композиции функций коммутативна по самому определению композиции:
```scala
assert((g compose f)(a) == g(f(a))) // для любого a
```

К этому моменту у кого уже не должно остаться сомнений, что функции - это душа теории типов, а теория типов - основа ~~функционального~~ программирования!
