
### Определение типа

Тип - это не более чем некая метка, приписываемая _к каждому_ терму (переменной, выражению и т.п.). Типы позволяют формализовать возможные преобразования термов, без изучения их внутренней структуры, составляющих их элементов. Суть типа полностью определяется совокупностью отображений (функций), связывающих его с другими типами. Зачастую такие отображения бывает удобно отобразить на диаграмме в виде ориентированного графа:
![[определение типа.png]]

Типы отличаются друг от друга только своим положением на такого рода диаграммах. Чтобы определить тип нужно
* указать совокупность "входящих" отображений (также говорят "инъекторы" или "конструкторы");
* указать совокупность "исходящих" отображений (также говорят "проекторы").

Смоделировав задачу в виде диаграммы типов и честно предоставив реализации всех функций, связывающих типы на диаграмме, мы можем построить корректный (но это ещё не точно)) алгоритм решения задачи.

На картинке выше видно, что
* если у нас есть объект типа $A_1$, или $A_2$, то мы можем считать, что у нас есть (мы всегда можем получить) и объект типа $C$.
* с другой стороны, если у нас есть объект типа $C$, то у нас есть (мы можем получить) объекты типов $B_1$ и $B_2$.

Можем ли мы определить тип $C$, как "$A_1$ **или** $А_2$"? Или как "$B_1$ **и** $B_2$"? Формально, мы можем всё, мы ж программисты!!

Но к сожалению, такого рода утверждения не будут считаться полными и однозначными определениями. В нашем случае, мы должны ещё гарантировать, что нет никаких $A_3$, $B_3$ и прочих, кто ещё связан отображениями с $C$. Но с другой стороны, например, если для $A_1$ есть отображение в $A_2$, то $A_2$ вполне можно исключить из определения типа $C$. Аналогично, среди типов $B$ также могут найтись те, кто связан с отображениями, значит там тоже кого-то можно исключить из формулировки $C$ через произведения. Так что из всех возможных типов-претендентов называться **суммой** или **произведением** типов, нам нужно выбрать "наилучшего" универсального представителя. Нам нужно некое **универсальное свойство**.

### Универсальное свойство

Универсальное свойство какой-либо конструкции в теории типов (на базовом уровне) определяется **единственностью** функции из любого типа-кандидата в "наилучший" тип, либо же, наоборот, в обратную сторону. "Единственность" функции, идущей от одного типа к другому, означает *эквивалентность* всех функции также связывающих эти типы. Такой "наилучший" тип и семейство уникальных морфизмов также называют "универсальными".

Универсальное свойство в теории типов можно определить как-то так:
> Существует тип и единственная функция принимающая (или возвращающая) значения этого типа, такая что соответствующая диаграмма будет коммутативной.

Звучит, пожалуй, сложновато)). Наверное, на начальном этапе универсальное свойство стоит воспринимать просто как некий универсальные способ однозначного формулирования различных абстракций поверх теории типов.

Сейчас имеет смысл, разве что, сказать пару слов про упомянутую "коммутативность".

### Функции и их композиция

Диаграмма считается коммутативной, если двигаясь по стрелкам *разными* путями от любого значения одного типа к другому мы получим *одинаковый* результат ("перестановочность путей"). Например, посмотрим на такую диаграмму:
![[композиция функций.png]]
Здесь $g \circ f$ - это **композиция функций** $f$ и $g$:
```scala
def f(a: A): B = ??? // какая-то функция
def g(b: B): C = ??? // какая-то функция
def h = g compose f  // получилась функция из A в C
```
С непривычки может смутить странный порядок операндов для композиции функций - "с конца в начало". Получается что-то вроде такого: "функция $h$ возвращает результат применения функции $g$ к результату применённая функции $f$". На самом деле возможное удивление - это следствие привычек. Со временем вы можете обнаружить, что именно такой порядок операндов наиболее логичен)).

Так вот диаграмма для композиции функций коммутативна по самому определению композиции:
```scala
assert((g compose f)(a) == g(f(a))) // для любых f, g и a
```

К этому моменту у кого уже не должно остаться сомнений, что функции - это душа теории типов, а теория типов - основа ~~функционального~~ программирования!

### Сумма типов

Вооружившись понятием универсального свойства, попробуем определить новый тип как "$A$ или $B$". В математике это обычно называют **суммой типов**. На диаграмме ниже представлено универсальное свойство для типа-суммы:
![[сумма типов.png]]
Для *любых* типа $D$ и функций $f$ и $g$ существует **единственный** (с точностью до изоморфизма) тип $A+B$ и **единственная** функция $u$, делающие диаграмму коммутативной. Здесь $i_A$ и $i_B$ - это два разных **конструктора** (инъектора) типа $A+B$ из значений типов $A$ и $B$. Рассмотрим конкретные примеры сумм типов в языке программирования Scala.

Обязательный тип-сумма, который присутствует в каждом языке программирования - булевский тип, у которого может быть только два разных значения - `true` или `false`:
```scala
  // Булевский тип
  type Bool = Boolean                 // True + False
```

В парадигме ООП сумма типов обычно определяется через наследование - класс-родитель является суммой своих прямых наследников. Чтобы однозначно определять тип-родитель как сумму типов-наследников, зачастую его можно "запечатать" - в Scala для этих целей используется модификатор `sealed`:
```scala
  // прямое наследование
  sealed trait Type2                  // One + Two
  final case class One() extends Type2
  final case class Two() extends Type2
```

Типы перечисления в Scala 3 под капотом реализуются аналогично через подтипы-"наследники":
```scala
  // подтипизация с помощью перечисления Scala3
  enum Type3 { case One, Two, Three } // One + Two + Three
```

Также в библиотеке Scala есть стандартные *обобщённые* типы `Option` и `Either` (и другие), которые реализуют семантику суммы типов через наследование:
```scala
  // обобщённые типы Scala "из коробки"
  type IntOrNone = Option[Int]    // Int + 1
  type IntOrInt = Int Either Int  // Int + Int
```
Но в обобщённые типы мы постараемся не углубляться, дабы не выходить за рамки и без того богатой темы этой публикации.

В Scala 3 также появилось понятие типа-объединения:
```scala
  // тип-объединение Scala3
  type IntOrString = Int | String     // Integer + String
```
На самом деле, объединение типов в общем случае - это не то же самое, что их сумма. Например, `Int | Int` будет *точно тоже самое*, что и просто `Int` - такое объединение не позволяет получить сумму двух одинаковых типов, как это было в случае `IntOrInt` в примере выше.

На диаграмме универсального свойства видно, что у типа суммы есть несколько конструкторов - несколько *параллельных* путей получения значения этого типа. Соответственно, чтобы получить *из этого типа* значения другого типа потребуется учесть все эти ветви. Суммы типов нужны как раз для реализации семантики **ветвления** алгоритмов. Помимо стандартной языковой конструкций `if` более общим паттерном в программировании является *сопоставление с шаблонами* (*pattern mathing*), как, например, в этом методе `choose`:
```scala
  def choose(variant: Boolean | Int | String): String =
    variant match
      case b: Boolean => "булево значение " + b
      case i: Int     => "целое число " + i
      case s: String  => "строка " + s
      // тип оперделяет выбор ровно из трёх альтернатив!
```

Подробнее о связи тип сумм с ветвлением алгоритмов расскажем далее.

### Произведение типов

Если на диаграмме универсального свойства для типа суимы мы обратим все стрелки обратно, то получим универсальное свойство типа- произведения, соответствующего семантике высказывания $A$ **и** $B$:
![[произведение типов.png]]
Для *любых* типа $D$ и функций $f$ и $g$ существует **единственный** (с точностью до изоморфизма) тип $A\times B$ и **единственная** функция $u$, делающие диаграмму коммутативной. Здесь $p_A$ и $p_B$ - это два **проектора** типа $A\times B$ на типы $A$ и $B$. Рассмотрим конкретные примеры произведения типов в языке программирования Scala.

Прежде всего, это привычные ООП-шные классы (а также трейты, интерфейсы, структуры, записи, объекты или что ещё есть в вашем любимом языке программирования?)):
```scala
  case class BoolAndDouble(b: Boolean, d: Double) // Boolean × Double
```
Открытые поля и свойства класса - это и есть те самые проекции типа-произведения. Методы класса также можно считать проекциями значений функционального типа (этот тип мы рассмотрим чуть ниже). В прочем, в классы (трейты, объекты) Scala на самом деле больше чем просто типы произведения - в них можно также определять абстрактные типы, методы-расширения, неявные методы и значения и проч. Но это уже совсем другая история.

Наиболее выразительно тип произведения определяется в Scala c помощью кортежей:
```scala
  type IntStrBool = (Int, String, Boolean) // Int × String × Boolean
  val isb: IntStrBool = (5, "4", false)
  assert(isb._2 == "4") // проекция _2
  val (_, _, b) = isb   // деконструкция через сопоставление с шаблоном
  assert(b == false)
```

В Scala 3 также появилось понятие типа-пересечения:
```scala
  type StringAndLong = String & Long // String × Long
```
Но тут есть аналогичная проблема, как и с объединением типов. Например, `Int & Int` будет *точно тоже самое*, что и просто `Int` - такое пересечение не позволяет получить произведение двух одинаковых типов, чего вполне можно достичь с помощью тех же кортежей.

Симметричность с точностью до инверсии всех стрелок универсальных свойств суммы и произведения типов является фундаментальной особенностью теории ~~категорий~~типов. Если мы формулируем какое-то универсальное свойство, то мы автоматически получаем и **дуальное** ему. Дуальность в теории типов следует из возможности декомпозиции вычислений на шаги, выполняемые *последовательно* во времени - имея такую последовательность, её можно развернуть в обратную сторону. Инвертированные шаги не всегда может получится реализовать, но общие утверждения об исходном алгоритме будут справедливы и для обратного (опять же с точностью до направления рассуждений). Таким образом дуальность обусловлена существованием стрелы времени)).

### Экспоненциал типов

Рассмотрим сумму двух одинаковых типов $B=A+A$. Это значит, что у нас есть два конструктора типа $B$ из типа $A$. Сумма типов устроена так, что её значения "помнят", каким конструктором они были созданы - это необходимо, чтобы из типа суммы получить значения какого-либо другого типа, если мы знаем, как их получить из значений типов-слагаемых (сопоставление с шаблонами). Фактически это значит, что для типа $A+A$ у нас есть не только проекция обратно в $A$, но в некий индексирующий тип, значения которого определяют выбор того или иного слагаемого.

Это можно визуализировать с помощью такой диаграммы:
![[произведение из суммы.png]]
Здесь $i_1$ и $i_2$ - два конструктора типа $B$, а $2$ - это тот самый индексирующий тип, у которого в нашем случае есть только два возможных значения. Получается, что тип $B$, представленный на диаграмме, можно определить двумя разными способами - и как сумму $A+A$ и как произведение $A\times2$!

Тут стоит обратить внимание на следующую идею: значения нашего индексирующего типа *ставятся в соответствие* функциям из $A$ в $B$. Так может быть эти функции также являются значениями какого-то типа?..

Но сперва давайте рассмотрим ту же самую диаграмму, но с другой точки зрения. Теперь будем считать, что $A=B\times B$, и вместо конструкторов типа $B$  $i_1$ и $i_2$ теперь у нас теперь есть проекторы типа $A$  $p_1$ и $p_2$. Поэтому, имея значение типа $A$ мы можем получить значение типа $B$, только если мы **выберем** один доступных проекторов, т.е. на момент вычисления у нас на руках есть, помимо значения типа $A$, есть ещё и предпочтённый индекс проектора. Такая пара значений относится к типу $A\times2$, где $2$ - тип, индексирующий проекторы $A$. Тогда имея значение типа $A\times2$ у нас будет возможность вычислить (evaluate) значение типа $B$:
![[экспоненциал из произведения.png]]
Эти соотношения справедливы для любых индексирующих типов - для любого количества проекторов (или, дуально, конструкторов).

Такой тип, чьи проекторы в некий тип $B$ индексируются типом $C$ обозначают как $B^C$ и называют **экспоненциалом**. Более точно экпоненициал определяется через своё универсальное свойство:
![[экспоненциал.png]]
Для любого типа $A$ и функции $g$ существует единственные тип $B^C$ и функция $u$, делающие эту диаграмму коммутативной.

Экспоненциал $B^C$ имеет очень простую трактовку - это **тип функций** из значений типа $C$ в тип $B$. Пара значений $(f, c)$ типа $B^C\times C$ - это всё, что необходимо для вычисления значения $f(c)$.

Функции, как значения некоторого типа, ("[первоклассные функции](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)") есть в том или ином виде практически во всех популярных языках программирования: "указатели на функцию" в С++, "делегаты" в C# и т.п. В Scala для типа функций обычно используются конструкции такого вида:
```scala
  val toStr                     // бестолковый метод
	: Int => String             // тип функции
	= i   => "#"                // λ-выражение
    
  def toStringDoubled(          // ещё один бестолковый метод
    i: Int,
    intToString: Int => String  // получаем значение-функцию
  ): String =
    val str = intToString(i);   // используем значение-функцию
    s"($str, $str)"
```
$\lambda$-выражения по сути являются литералами значений функционального типа - они так же присутствуют в большинстве языков программирования. Помимо $\lambda$-выражения, для получений значения функционального типа многие языки позволяют (неявно) использовать ссылки на какой-то метод:
```scala
  def doubleDouble(i: Int): Double = i * 2.0
  val intToDouble: Int => Double = doubleDouble // ссылка на метод
```

### Подтипизация и наследование

В программировании широко известно такое понятие как "подтипизация" - основе ключевой для ООП разновидности полиморфизма - *полиморфизма подтипов*. Подтипизация - это такое отношение между типами, что если $B$ является подтипом для $A$ ($A :> B$), тогда любой терм типа $B$ можно _безопасно использовать_ в _любом контексте_, где ожидается терм типа $A$. "Безопасное использование" и "контекст" могут трактоваться по разному в разных языках программирования.

В ООП есть схожее понятие, которое иногда путают с подтипизацией - "наследование". Наследование - это способ описать *реализацию* нового типа на основе *реализации* существующих типов, в то время, как подтипизация - это только отношение между типами. Подтип не всегда является наследником супертипа. Например `Int32` вполне можно считать подтипом для `Int64`, но ни о каком наследовании тут нет речи. Наследование выстраивает типы в иерархическую структуру, но подтипизация в этом плане гораздо гибче.

По сути, мы имеем дело с наличие (неявного) преобразования значения значений от подтипа к супертипу.
**Отношение подтипизации - это просто функция**!

В Scala, помимо ООП-шного наследования ("расширения" или имплементации абстрактных типов), есть и встроенные неявные преобразования типов, а также можно определять свои:
```scala
given Conversion[Int Either Int, (Boolean, Int)] = // Int + Int => 2 × Int
  case Left(i) => (false, i)
  case Right(i) => (true, i)

def toStr(pair: (Boolean, Int)) = pair match // принимает 2 × Int
  case (false, i) => "Левое "  + i
  case (true,  i) => "Правое " + i

val intOrInt: Int Either Int = Right(42)     // Int + Int
val str = toStr(intOrInt)      // Правое 42  // срабатвает подтипизаця
```

