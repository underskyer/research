Отношение подтипизации - это частный случай морфизма - стрелка от подтипа типа к супертипу. В языках программирования компилятор предоставляет неявные преобразования от подтипа к супертипу, и чаще всего такие преобразования даются бесплатно (ссылка на экземпляр подтипа оказывается корректной ссылкой на экземпляр супертипа). 

В программировании также популярно связанное понятие из ООП - "наследование". Эта концепция заметно уже, чем подтипизация (например `Int32` можно считать подтипом для `Int64`, но ни о каком наследовании тут нет речи). Появление наследования не обусловлено каким либо классом задач, в решении которых оно играло бы ключевую роль. Популярность же этого понятия является следствием крупных финансовых вливаний в раскрутку ООП, но его практической пользой.

Наследование выстраивает типы в иерархическую структуру, но подтипизация в этом плане гораздо гибче. "Ветви" подтипизации могут не только расти от одного "корня", но и, наоборот, сходится к одному типу. * "Стрелки" подтипизации могут даже образовывать циклы, и это не всегда будет означать эквивалентность типов, через которые проходит этот цикл.  Подтипизация сама по себе не накладывает никаких ограничений на неявные преобразования между типами.

Типичный пример в Scala - тип `Nothing`. Экземпляр это типа (да, вы не сможете его получить, но его) вы можете привести к любому другому типу. `Nothing` является подтипом всех типов в Scala!

Можно было бы ожидать, что в Scala также тип `Unit` играет роль супертипа всех типов, но к сожалению это не так. `Unit` относится к семейству "типов-значений", а это семейство не пересекается со "ссылочными типами". Роль суппер-пуппер типа в Scala выполняет `Any` - для него работают механизмы отражений (динамическая типизация), Null и прочее тяжелое наследие ООП-шной Java.
