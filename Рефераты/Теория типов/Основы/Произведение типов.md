
В теории типов высказывание вида "$A$ и $B$" называют **произведением типов**. Универсальное свойство для типа-произведения аналогично таковому для типа суммы - диаграммы идентичны с точностью до изменения направления всех стрелок:
![[произведение типов.png]]
Для *любых* типа $D$ и функций $f$ и $g$ существует **единственный** (с точностью до изоморфизма) тип $A\times B$ и **единственная** функция $u$, делающие диаграмму коммутативной. Здесь $p_A$ и $p_B$ - это два **проектора** типа $A\times B$ на типы $A$ и $B$. Рассмотрим конкретные примеры произведения типов в языке программирования Scala.

Прежде всего, это привычные ООП-шные классы (а также трейты, интерфейсы, структуры, записи, объекты или что ещё есть в вашем любимом языке программирования?)):
```scala
  case class BoolAndDouble(b: Boolean, d: Double) // Boolean × Double
```
Открытые поля и свойства класса - это и есть те самые проекции типа-произведения. Методы класса также можно считать проекциями значений функционального типа (этот тип мы рассмотрим чуть ниже). В прочем, в классы (трейты, объекты) Scala на самом деле больше чем просто типы произведения - в них можно также определять абстрактные типы, методы-расширения, неявные методы и значения и проч. Но это уже совсем другая история.

Наиболее выразительно тип произведения определяется в Scala c помощью кортежей:
```scala
  type IntStrBool = (Int, String, Boolean) // Int × String × Boolean
  val isb: IntStrBool = (5, "4", false)
  assert(isb._2 == "4") // проекция _2
  val (_, _, b) = isb   // деконструкция через сопоставление с шаблоном
  assert(b == false)
```

В Scala 3 также появилось понятие типа-пересечения:
```scala
  type StringAndLong = String & Long // String × Long
```
Но тут есть аналогичная проблема, как и с объединением типов. Например, `Int & Int` будет *точно тоже самое*, что и просто `Int` - такое пересечение не позволяет получить произведение двух одинаковых типов, чего вполне можно достичь с помощью тех же кортежей.

Симметричность с точностью до инверсии всех стрелок универсальных свойств суммы и произведения типов является фундаментальной особенностью теории ~~категорий~~типов. Если мы формулируем какое-то универсальное свойство, то мы автоматически получаем и **дуальное** ему. Дуальность в теории типов следует из возможности декомпозиции вычислений на шаги, выполняемые *последовательно* во времени - имея такую последовательность, её можно развернуть в обратную сторону. Инвертированные шаги не всегда может получится реализовать, но общие утверждения об исходном алгоритме будут справедливы и для обратного (опять же с точностью до направления рассуждений). Таким образом дуальность обусловлена существованием стрелы времени)).