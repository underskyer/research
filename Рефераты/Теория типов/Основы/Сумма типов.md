
Вооружившись понятием универсального свойства, попробуем определить новый тип как "$A$ или $B$". В математике это обычно называют **суммой типов**. На диаграмме ниже представлено универсальное свойство для типа-суммы:
![[сумма типов.png]]
Для *любых* типа $D$ и функций $f$ и $g$ существует **единственный** (с точностью до изоморфизма) тип $A+B$ и **единственная** функция $u$, делающие диаграмму коммутативной. Здесь $i_A$ и $i_B$ - это два разных **конструктора** (инъектора) типа $A+B$ из значений типов $A$ и $B$. Рассмотрим конкретные примеры сумм типов в языке программирования Scala.

Обязательный тип-сумма, который присутствует в каждом языке программирования - булевский тип, у которого может быть только два разных значения - `true` или `false`:
```scala
  // Булевский тип
  type Bool = Boolean                 // true + false
```

В парадигме ООП сумма типов обычно определяется через наследование - класс-родитель является суммой своих прямых наследников. Чтобы однозначно определять тип-родитель как сумму типов-наследников, зачастую его можно "запечатать" - в Scala для этих целей используется модификатор `sealed`:
```scala
  // прямое наследование
  sealed trait Type2                  // One + Two
  final case class One() extends Type2
  final case class Two() extends Type2
```

Типы перечисления в Scala 3 под капотом реализуются аналогично через подтипы-"наследники":
```scala
  // подтипизация с помощью перечисления Scala3
  enum Type3 { case One, Two, Three } // One + Two + Three
```

Также в библиотеке Scala есть стандартные *обобщённые* типы `Option` и `Either` (и другие), которые реализуют семантику суммы типов через наследование:
```scala
  // обобщённые типы Scala "из коробки"
  type IntOrNone = Option[Int]    // Int + 1
  type IntOrInt = Int Either Int  // Int + Int
```
Но в обобщённые типы мы постараемся не углубляться, дабы не выходить за рамки и без того богатой темы этой публикации))).

В Scala 3 также появилось понятие типа-объединения:
```scala
  // тип-объединение Scala3
  type IntOrString = Int | String     // Integer + String
```
На самом деле, объединение типов в общем случае - это не то же самое, что их сумма. Например, `Int | Int` будет *точно тоже самое*, что и просто `Int` - такое объединение не позволяет получить сумму двух одинаковых типов, как это было в случае `IntOrInt` в примере выше.

На диаграмме универсального свойства видно, что у типа суммы есть несколько конструкторов - несколько *параллельных* путей получения значения этого типа. Соответственно, чтобы получить *из этого типа* значения другого типа потребуется учесть все эти ветви. Суммы типов нужны как раз для реализации семантики **ветвления** алгоритмов. Помимо стандартной языковой конструкций `if` более общим паттерном в программировании является *сопоставление с шаблонами* (*pattern mathing*), как, например, в этом методе `choose`:
```scala
  def choose(variant: Boolean | Int | String): String =
    variant match
      case b: Boolean => "булево значение " + b
      case i: Int     => "целое число " + i
      case s: String  => "строка " + s
      // тип оперделяет выбор ровно из трёх альтернатив!
```

Подробнее о связи тип сумм с ветвлением алгоритмов расскажем далее.
