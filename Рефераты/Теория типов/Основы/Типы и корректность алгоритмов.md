
### Тип множеств

Что представляет собой множество с точки зрения теории типов? Множество определяется через возможность проверки принадлежности ему любого объекта, т.е. через функцию типа
```scala
val contains: (Set, Any) => Boolean
```
Если эту функцию переписвть в каррированном в виде, то получится что-то вроде ООП-представления - множество *предоставляет* метод проверки принадлежности ему некоторого объекта:
```scala
val setChecker: Set => Any => Boolean
setChecker(set)(value) // true/false
```

Ввиду единственности метода, определяющешо семантику множества, его тип оказыапется изоморфен типу функции из Any в классификатор Boolean:
```scala
type Set = Any => Boolean
```
Операции, порождающие другие множества из существующих, определяются через возможности типа `Boolean`:
```scala
val union
  : (Set, Set) => Set
  = (a, b)     => x => a(x) || b(x)
val intersection
  : (Set, Set) => Set
  = (a, b)     => x => a(x) && b(x)
val дополнение
  : Set => Set
  = a   => x => !a(x)
```
В Scala уже есть встроенный тип `Set` с различными реализациями, но ключевая семантика множества, как функции-классификатора (`true/false`) значений там точно такая же. **Множество - это функция!**

Отношения между множествами (включение) можно определить, если получится пробежать все элементы этих множеств (или объемлющего множеста). Но множество не является коллекцией - для него в общем случае не задан способ перечиления принадлежащих ему элементов (существуют и вовсе несчётные множества). Понятие *мощности* множества также определяется через отношение эквивалентности множеств. Честная реализация отношений между множествами достаочно сложна и выходит за рамки этой статьи.

### Типы и классы

Важно понимать, чем отличаются понятия типа и множества. [Попытки ассоциировать эти понятия](https://habr.com/ru/post/713800/) приводят к разного рода противоречиям.

Признак наличия совокупности связанных с типом отображений можно считать предикатом, выделяющим некий **класс** объектов. А классы, как было сказано выше, не обязательно описывают множество.

Тип не имеет внутренней структуры - его не всегда можно описать поэлементно. Но зачастую такую структуру можно привязать "снаружи", определив совокупность морфизмов в элементы некоторого множества.

### Типы и множества их значений

Если представить тип-сумму покомпонентно, то видно, что каждому объекту типов слагаемых соответствует свой объект результирующего типа.
![[сумма типов как множество.png]]

### Соотношения Кари-Говарда.
Типы - утверждения, значения типов - доказательство утверждений.
Отношение эквивалентности, тип `CanEquals`.

Проблема останова.


### Типизация
- сильная/слабая
- статическая/динамическая

### SKI - корректность без типов