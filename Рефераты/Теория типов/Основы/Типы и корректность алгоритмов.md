
### Время, чистые функции и неизменяемые значения

Как было сказано в начале, основная причина появления теории типов (теории множеств, $\lambda$-исчисления и проч.) - это предоставление возможности *доказать корректность* алгоритмов. Для появления такой возможности необходимо гарантировать *предсказуемость* вычисления. *Результат* вычисления алгоритма должен быть *детерминирован начальными условиями* - при одних и тех же условиях мы должны получать один и тот же результат. 

Математика зачастую абстрагируется от процесса вычисления, акцентируя внимание на логически-корректную декомпозицию большого алгоритма на более мелкие. Например, *пути* на диаграмме типов распадаются на комбинацию отдельных стрелочек-функций. В то же время путь может быть разветвлённым и вычисления должны производиться по всем ветвям. Обычно не декларируется, как вычисление этих ветвей должно быть распределено во времени - параллельно или последовательно и в каком именно порядке - важен лишь результат всех вычислений. Таким образом, один и тот же алгоритм может выполняться по разному.

Но процесс вычислений происходит с участием каких-либо материальных сущностей (например, памяти компьютера), которые склонны менять своё состояние с течением времени. Так что даже если мы включим состояние этих объектов начальные условия алгоритма, нам ещё нужно гарантировать, что оно не изменится *в процессе вычисления* и не поломает детерминированность.

В программировании сам процесс вычисления алгоритма зачастую играет б**о**льшую роль, чем гарантия корректности этих вычислений. Но если требуется предоставить лучшие гарантии корректности, то стоит учесть перечисленные выше замечания и стараться чаще использовать **чистые функции**. Класс чистых функций можно определить таким двумя условиями:
- никакие вычисления не поломают чистую функцию - при фиксированных значениях аргументах мы всегда можем подменить вычисление предоставлением предопределённого результирующего значения (*ссылочная прозрачность*);
- вычисления чистой функции никак не влияет на вычисления любых других функций. 

Другими словами, функция чистая, если она *детерминирована* и не обладает *побочными эффектами*.

Ссылочную прозрачность функции можно обеспечить, если чётко выделить все начальные условия - значения, хранящиеся в ячейках памяти - и гарантировать их *неизменяемость* в процессе вычисления. Теория типов ориентирована в первую очередь на неизменяемость значений, вычисленных одними функциями и переданные на вход другим.

В программировании существует также любопытная концепция *линейных типов*, гарантирующая, что вычисляемые значения будут доступны *единственному* методу, в который они передаются. В процессе вычисления никакой другой метод не сможет прочесть/изменить это значение, а по окончанию вычисления оно вовсе перестанет существовать, но внутри самого метода, где значение существует, мы можем императивно, низкоуровнево, "железо-оптимизированно" его. Это можно обосновать так, будто каждая императивная инструкция принимает на вход одни значения, а возвращает уже новые значения, "забывая" старые, но при этом не возникает проблем с конкурентным доступом к этим же ячейкам памяти из других вычислений. Линейные типы не достаточно широко известны, но это очень интересная тема, достойная отдельной статьи. В общем, наука не стоит на месте, и разрабатываются теории типов, учитывающие изменяемость значений, но пока можно считать, что в общем случае **изменяемость значений = невозможность проверки корректности алгоритма**.

С побочными эффектами ситуация интереснее. Дело в том, что основная задача программирования - это автоматизация различных процессов материального мира. Польза от компьютерных программ как раз заключается в наличии эффектов, во взаимодействии вычислителя с окружением. Полностью "чистый" алгоритм имеет нулевую практическую ценность! Решение парадокса заключается в том, чтобы отделить чистые функции от эффективных вычислений - сама программа должна быть максимально чистой для гарантии корректности, а вычисленные *описания эффектов* отдаются в самом конце общим библиотечным методам или даже среде исполнения. Этот принцип используется в современных Scala-продуктах, написанных на основе библиотек вроде `Cats.Effect` или `ZIO`. К сожалению, это также выходит за рамки данной статьи.

На самом деле, честная проверка наличия "побочных эффектов" оказывается весьма нетривиальной. Оценить "невлияние" вычисления одних функций на другие можно лишь статистически, с определённой долей достоверности. И, вообще говоря, мы получаем целую совокупность классов чистых функций, не влияющих на функции из этого же класса, но потенциально "ломающих" детерминизм функции из других таких классов... Так что, "чистые функции" оказываются не таким уж "чистым", но их роль по прежнему крайне важна как рекомендация, как можно повысить доказуемость корректности алгоритмов.
<div style="page-break-after: always;"></div>
<div style="page-break-after: always;"></div>

### Соответствие Карри-Говарда.

Хаскелл Карри и Уильям Ховард заметили, что построение конструктивного доказательства похоже на описание вычислений, а высказывания конструктивной логики по своей структуре схожи с типами вычисляемых выражений — программ для вычислительной машины.



Типы - утверждения, значения типов - "свидетели", доказательства утверждений.

Отношение эквивалентности, тип `CanEquals`.

Проблема останова.

### Типизация
- сильная/слабая
- статическая/динамическая

### SKI - корректность без типов