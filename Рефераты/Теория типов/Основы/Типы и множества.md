### Тип множеств

Что представляет собой множество с точки зрения теории типов? Множество определяется через возможность проверки принадлежности ему любого объекта, т.е. через функцию
```scala
val contains: (Set, Any) => Boolean
```
Если эту функцию переписать в каррированном в виде, то получится что-то вроде ООП-представления - множество *предоставляет* метод проверки принадлежности ему некоторого объекта:
```scala
val setChecker: Set => Any => Boolean
setChecker(set)(value) // true/false
```

Ввиду единственности метода, определяющего семантику множества, его тип оказывается изоморфен типу функции из `Any` в классификатор `Boolean`:
```scala
type Set = Any => Boolean
```
Из структуры классификатора, следуют два выделенных множества:
```scala
val emptySet    : Set = x => false // никто не принадлежит множеству
val universalSet: Set = x => true  // любой    принадлежит множеству
```
Операции, порождающие другие множества из существующих, определяются через возможности типа `Boolean`:
```scala
val union
  : (Set, Set) => Set
  = (a, b)     => x => a(x) || b(x)
val intersection
  : (Set, Set) => Set
  = (a, b)     => x => a(x) && b(x)
val difference
  : (Set, Set) => Set
  = (a, b)     => x => a(x) && !b(x)
```
В Scala уже есть встроенный тип `Set` с различными реализациями, но ключевая семантика множества, как функции-классификатора (`true/false`) значений там точно такая же. **Множество - это функция!**

Отношения между множествами (включение, равенство) можно определить, если получится пробежать все элементы этих множеств (или объемлющего множества). Но множество не является коллекцией - для него в общем случае не задан способ перечисления принадлежащих ему элементов (существуют и вовсе несчётные множества). Понятие *мощности* множества также определяется через классы эквивалентности множеств. Честная реализация отношений между множествами достаточно сложна и выходит за рамки этой статьи.

### Типы и классы

В программировании часто используется *классы*. Термин заимствован напрямую из теории множеств, где он означает _совокупность объектов, удовлетворяющих перечисленным условиям_. Эти условия являются *ограничениями*, отсеивающими некоторые объекты из универсального множества - чем больше ограничений, тем меньше объектов относятся к этому классу. Классы - это *интенсиональный* способ определения множества через предикаты, в противоположность *экстенсиональному* - через перечисление элементов или через конструирование множества из существующих.

Когда в объявляется ООП-шный класс (трейт, интерфейс, запись, структура...) в нём указываются методы, поля, свойства. Это и есть те самые ограничения, которые накладываются на объекты этого класса, отбирая лишь те, у которых есть перечисленные возможности. Если этот класс наследует от некого суперкласса, он *расширяет* (`extends`) набор *ограничений*, тем самым *сужая множество* объектов, которые относились бы к новому классу.

Как было сказано ранее, интенсионально определённый класс может не определять множества, может быть "больше чем множество". Но в программировании используются такие ограничения класса, которые обеспечивают конструирование именно множества.

Важно понимать, что классы, являясь способом построения множеств, *не являются* типами - метками термов, предназначенными для формализации вычислений. Но в программировании возможный набор ограничений, как правило, соответствует `проекторам` некоторого типа-произведения, так что для таких классов однозначно определяется соответствующий им тип. Наследование ("расширение") классов позволяет утверждать, что объект подкласса **является** также объектом всех суперклассов. В тоже время в теории типов у каждого терма может быть только один тип, а отношение подтипизации, индуцированное наследованием, определяется возможностью неявного преобразования от подтипа к супертипу.

Рассмотрим пример, как можно от ООП-шных классов перейти к суммам, произведениям, экспоненциалам типов (на реализацию не отвлекаемся).
```scala
// есть классы
object classes:
  sealed trait PredictionCalculator:
    def calculate(conditions: Conditions): Estimation
  final case class PessimisticPredictor(fallBack: RopeAndSoap) extends PredictionCalculator:
    def calculate(conditions: Conditions) = ???  

  final case class OptimisticPredictor(continuation: Cocktail) extends PredictionCalculator:
    def calculate(conditions: Conditions) = ???  

// нет классов))
object classless:
  type PredictionCalcFunction = Conditions => Estimation
  type PessimisticPredictor = (RopeAndSoap, PredictionCalcFunction)
  type OptimisticPredictor = (Cocktail, PredictionCalcFunction)
  type PredictionCalculator = PessimisticPredictor | OptimisticPredictor
```
Безусловно, есть различия по получению и использованию значений получившихся типов, но это тема для отдельного (также весьма интересного!) обсуждения. Тут лишь важно заметить, что **классы не привносят ничего нового** в простую теорию типов, только синтаксические ограничения от конкретного языка программирования!

### Типы и множества их значений

Тип не имеет внутренней структуры - его не всегда можно описать поэлементно. Но зачастую такую структуру можно привязать "снаружи", определив совокупность морфизмов в элементы некоторого множества.

Если представить тип-сумму покомпонентно, то видно, что каждому объекту типов слагаемых соответствует свой объект результирующего типа.
![[сумма типов как множество.png]]
