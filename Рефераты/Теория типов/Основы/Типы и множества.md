### Тип множеств

Что представляет собой множество с точки зрения теории типов? Можно считать, что множество определяется через возможность проверки принадлежности ему любого объекта, т.е. через функцию
```scala
val contains: (Set, Any) => Boolean
```
Если эту функцию переписать в каррированном в виде, то получится что-то вроде ООП-представления - множество *предоставляет* метод проверки принадлежности ему некоторого объекта:
```scala
val setChecker: Set => Any => Boolean
setChecker(set)(value) // true/false
```
Ввиду единственности метода, определяющего семантику множества, его тип оказывается изоморфен типу функции из `Any` в классификатор `Boolean`:
```scala
type Set = Any => Boolean
```

Из структуры классификатора, следуют два выделенных множества, а также нам потребуется способ создавать одноэлементное множество:
```scala
val emptySet      : Set =      x => false  // никто не принадлежит множеству
val universalSet  : Set =      x => true   // любой    принадлежит множеству
val makeSet: Any => Set = a => x => a == x // создать одноэлементное множество
```
Операции, порождающие другие множества из существующих, определяются через возможности типа `Boolean`:
```scala
val union
  : (Set, Set) => Set
  = (a, b)     => x => a(x) || b(x)
val intersection
  : (Set, Set) => Set
  = (a, b)     => x => a(x) && b(x)
val difference
  : (Set, Set) => Set
  = (a, b)     => x => a(x) && !b(x)
```
В Scala уже есть встроенный тип `Set` с различными реализациями, но ключевая семантика множества, как функции-классификатора (`true/false`) значений там точно такая же. **Множество - это функция** (ну, почти)!

Отношения между множествами (включение, равенство) можно определить, если получится пробежать все элементы этих множеств (или объемлющего множества). Но множество не является коллекцией - для него в общем случае не задан способ перечисления принадлежащих ему элементов (существуют и вовсе несчётные множества). Понятие *мощности* множества также определяется через классы эквивалентности множеств. Честная реализация отношений между множествами достаточно сложна и выходит за рамки этой статьи.

На самом деле описанный выше тип множества - это не всегда множество)). С точки зрения математики, это *класс*, который лишь иногда может представлять множество, в зависимости от способа классификации. Описанные выше три способа создания и три способа комбинирования позволяют *экстенсионально* строить настоящие множества фиксированной мощности. Тем не менее, с помощью перечисленных способов не получится построить все возможные множества (например, множество действительных чисел). Но давайте рассмотрим такой класс:
```scala
trait MyTrait:            // все возможные "наследники" не образуют множество!
  def myFunc(i: Int): Int

val myClass               // этот класс описывает множество, или нет?
  : Set
  = x => x.isInstanceOf[MyTrait]
```
Если бы этот класс представлял множество, как бы можно было оценить его мощность?
**ВОЗМОЖНО ТУТ ФИГНЮ СМОРОЗИЛ - НАДО РОВЕРИТЬ**

### Типы и классы

В программировании часто используется *классы*. Термин заимствован напрямую из теории множеств, где он означает _совокупность объектов, удовлетворяющих перечисленным условиям_. Эти условия являются *ограничениями*, отсеивающими некоторые объекты из универсального множества - чем больше ограничений, тем меньше объектов относятся к этому классу. Классы - это *интенсиональный* способ определения множества через предикаты, в противоположность *экстенсиональному* - через перечисление элементов или через конструирование множества из существующих.

Когда объявляется ООП-шный класс (трейт, интерфейс, запись, структура...), в нём указываются методы, поля, свойства. Это и есть те самые ограничения, которые накладываются на объекты этого класса, отбирая лишь те, у которых есть перечисленные возможности. Если этот класс наследует от некого суперкласса, он *расширяет* (`extends`) набор *ограничений*, тем самым *сужая множество* объектов, которые относились бы к новому классу.

Важно понимать, что классы, являясь способом классификации объектов, *не являются* типами - метками термов, предназначенными для формализации вычислений. Но в программировании возможный набор ограничений, как правило, соответствует `проекторам` некоторого типа-произведения, так что для таких классов однозначно определяется соответствующий им тип. Наследование ("расширение") классов позволяет утверждать, что объект подкласса **является** также объектом всех суперклассов. В тоже время в теории типов у каждого терма может быть только один тип, а отношение подтипизации, индуцированное наследованием, определяется возможностью неявного преобразования от подтипа к супертипу.

Рассмотрим пример, как можно от ООП-шных классов перейти к суммам, произведениям, экспоненциалам типов (на реализацию не отвлекаемся).
```scala
// есть классы
object classes:
  sealed trait PredictionCalculator:
    def calculate(conditions: Conditions): Estimation
  final case class PessimisticPredictor(fallBack: RopeAndSoap) extends PredictionCalculator:
    def calculate(conditions: Conditions) = ???  

  final case class OptimisticPredictor(continuation: Cocktail) extends PredictionCalculator:
    def calculate(conditions: Conditions) = ???  

// нет классов, только экспоненциал, пара произведений и сумма типов
object classless:
  type PredictionCalcFunction = Conditions => Estimation
  type PessimisticPredictor   = (RopeAndSoap, PredictionCalcFunction)
  type OptimisticPredictor    = (Cocktail,    PredictionCalcFunction)
  type PredictionCalculator   = PessimisticPredictor | OptimisticPredictor
```
Безусловно, есть различия по получению и использованию значений получившихся типов, но это тема для отдельного (также весьма интересного!) обсуждения. Сейчас лишь важно заметить, что ООП-классы реализуют в языках программирования всё те же базовые понятия теории типов!

### Типы и множества их значений

Тип не имеет внутренней структуры - его не всегда можно описать поэлементно. Но если он ассоциирован с множеством, то ему можно поставить в соответствие и мощность этого множества. Интересно проследить, как операции с типами отражаются на мощностях их множеств. Для мощности типа $A$ используем обозначение $\|A\|$.

С типами $0$ и $1$ всё очевидно - мощности их множеств отражены в названии:
$$\|0\|=0,\;\|1\|=1.$$

Рассмотрим покомпонентно сумму типов:
![[мощность суммы.png]]
Стрелки здесь обозначают не функции, а пару связанных значений. Тогда функция от одного типа к другому - это набор таких пар. Из диаграммы видно, что операция вычисления мощности типа сохраняет сложение: $$\|A+B\|=\|A\|+\|B\|.$$
Рассмотрим теперь произведение типов. Для простоты представим произведение как многократную сумму:
![[мощность произведения.png]]
Здесь $a_ib_j$ - это просто обозначение элемента типа $A\times B$. Очевидно что для произведения выполняется соотношение аналогичное сумме типов:
$$\|A\times B\|=\|A\|\times\|B\|.$$

При рассмотрении типа-экспоненциала $B^A$, можно достаточно вспомнить что каждый его объект, функция, в теории множеств представляет собой набор пар значений типа $A$ и $B$, причём в этом наборе присутствуют все элементы типа $A$ в единственном количестве. Чтобы вычислить все возможные значения этого типа достаточно перебрать все различающиеся наборы пар:
![[мощность экспонциала.png]]
Получается, что вычисление мощности типа сохраняет также и экспоненту:
$$\|B^A\|=\|B\|^{\|A\|}\;\;\;(B\ncong0).$$
Удивительный результат, не правда ли?

Множества могут быть бесконечными и вовсе несчётными. Мощности, в свою очередь, - это не натуральные числа, а _кардинальные_, учитывающие разные "сорта бесконечности". Тем не менее, приведённые выше выражения удовлетворяются и для бесконечных кардинальных чисел.

Но не стоит забывать, что типы не всегда соответствуют множествам)).