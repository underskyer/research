### Изоморфизм
В предыдущем разделе на первой диаграмме показан тип $B$, который можно было представить и как $A+A$ и как $A\times2$. Эти представления не эквиваленты - они представляют разную семантику работы со значениями этих типов. Но между множествами их значений можно построить **взаимно-однозначное соответствие**:
```scala
  type Int2 = (Int, Boolean)      // Int × 2
  type IntOrInt = Int Either Int  // Int + Int

  def туда(i2: Int2): IntOrInt =
    i2 match
      case (i, true)  => Right(i) // конструктор правого слагаемого
      case (i, false) => Left (i) // конструктор левого  слагаемого
      
  def обратно(ii: IntOrInt): Int2 =
    ii match
      case Right(i) => (i, true)  // правое слагаемое
      case Left(i)  => (i, false) // левое  слагаемое
  
  assert((обратно compose туда)(i2) == i2) // для любых i2
  assert((туда compose обратно)(ii) == ii) // для любых ii
```
Если мы можем предоставить две такие функции между типами, композиция которых даёт тождественные отображения, то говорят, что типы **изоморфны**. При использовании изоморфных типов будут отличаться разве что синтаксические конструкции, но это будут по прежнему одни и те же данные.

В программировании изоморфизм двух типов, как правило, соответствует **взаимной подтипизации** - изоморфные типы являются подтипом друг друга. Понятное дело, что такое не получится организовать через "наследование".

Используя обозначение $\simeq$ мы можем записать изоморфизм из примера выше так:
$$A+A\simeq A\times2,$$
где $2$ - это тип с двумя значениями. 

Аналогично, для изоморфизма $$A\times A\simeq A^2,$$
можно предоставить такие методы:
```scala
  type IntInt = (Int, Int)        // Int × Int
  type BoolToInt = Boolean => Int // 2 => Int

  def туда(ii: IntInt): BoolToInt =
    b =>
      if (b)  ii._1
      else    ii._2

  def обратно(i2: BoolToInt): IntInt = (
    i2(true),
    i2(false),
  )
  
  assert((обратно compose туда)(ii) == ii) // для любых i2
  assert((туда compose обратно)(i2) == ii) // а так Scala не сумеет))
```

Старая добрая школьная алгебра, не так ли? Более того, суммы и произведения типов удовлетворят (с точностью до изоморфизма) основным алгебраическим законам:
- *коммутативность*: $A+B\simeq B+A,\;A\times B\simeq B\times A$;
- *ассоциативность*: $A+(B+C)\simeq(A+B)+C,\;A\times(B\times C)\simeq(A\times B)\times C;$ 
- *дистрибутивность*: $A\times(B+C)\simeq A\times B+A\times C.$

Как правило, эти законы не работают в популярных языках программирования автоматически. Разве что, в Scala эти правила выполняются для объединения и пересечения типов, которые для *различающихся* типов с натяжкой можно считать суммой и произведением. Но в Scala есть техническая возможность связать изоморфизмом типы, ненаследующие друг другу, реализовав неявные преобразования между ними.

Для экспоненциала также можно записать знакомые со школы выражения. Но зачастую для них в языках программирования предоставляются специальные механизмы. Рассмотрим их подробнее.

### Cопоставление с шаблонами

Тип суммы определяется своими конструкторами - способами получения значения этого типа. Но гораздо важнее то, как мы эти значения сможем **использовать** - как из них можно получить значения другого типа. Общие соображения подсказывают нам, что для того чтобы преобразовать значения типа суммы в другой тип, нужно предоставить соответствующие преобразования в этой тип из значений типов-слагаемых. Алгебраические соотношения говорят нам то же самое:
$$A^{B+C+D}\simeq A^B\times A^C\times A^D.$$
То есть, функцию из $B+C+D$ в $A$ можно построить, если у нас есть все три функции в $A$ из $B$, $C$ и $D$. Для этих целей и предназначен упомянутый ранее механизм *сопоставления с шаблонами*:
```scala
  val patternMatching // Int + Boolean + Double         => String
    : Int | Boolean | Double => String =
      case i: Int     => "целое " + i        // Int     => String
      case b: Boolean => "булево " + b       // Boolean => String
      case d: Double  => "рациональное " + d // Double  => String
```
Компилятор сам отслеживает, чтобы при сопоставлении с шаблонами были учтены все альтернативы - все слагаемые типа-суммы, и чтобы у каждой ветки был обработчик-функция соответствующего типа.

Для стандартных (и многих сторонних) типов-сумм в Scala предоставляются специальные методы, дающие те же возможности, но без необходимости использовать синтаксический сахар:
```scala
  val eFold: Int Either Double => String = // Int + Double => String
    intOrDouble => intOrDouble.fold(       // λ-выражение
      i => "целое " + i,                   // Int          => String
      d => "рациональное " + d)            // Double       => String
```

### Каррирование

Чтобы вычислить некоторое выражение, зависящее от переменных, нужно построить на его основе функцию и передать эти переменные как аргументы (захват переменных, определённых вручную, сейчас рассматриваем). Но сделать это можно несколькими способами:
```scala
  val f1
    : (Int, Boolean) => String
    = (i, b) => if ((i > 0) && b) "тру!" else "дырка!"

  val f2
    : Int => (Boolean => String)  // тут и ниже скобки лишние
    = i => b => if ((i > 0) && b) "тру!" else "дырка!"  

  f1(-2, false) // "тру!"
  f2(-2)(false) // "тру!"
```
И тоже самое с перестановкой аргументов функции местами. Функции - это "первоклассные объекты", и мы можем просто вернуть из функции другую функцию, в теле которой "захвачен" аргумент родительской!

$A^{B\times C}\simeq \left(A^B\right)^C\simeq \left(A^C\right)^B$

```scala
  val sum: (Int, Int) => Int =          // Int × Int => Int
    (a, b) => a + b
  sum(2, 2)                             // 4
  
  val sumCarried: Int => Int => Int =   // Int => (Int => Int)
    sum.curried
  val add5 = sumCarried(5)              // Int => Int
  add5(5)                               // 10
  sumCarried(2)(2)                      // 4
  
  // Int × (Int => Int) => Int
  def doubleModification(i: Int, modifier: Int => Int): Int =
    modifier(modifier(i))
  doubleModification(2, sumCarried(2))  // 6
```