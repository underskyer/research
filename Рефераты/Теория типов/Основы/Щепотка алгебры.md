
### Изоморфизм
В предыдущем разделе на первой диаграмме показан тип $B$, который можно было представить и как $A+A$ и как $A\times2$. Эти представления не эквиваленты - они представляют разные способы работы со значениями этих типов. Но между множествами их значений можно построить **взаимно-однозначное соответствие**:
```scala
  type Int2 = (Int, Boolean)      // Int × 2
  type IntOrInt = Int Either Int  // Int + Int

  def туда(i2: Int2): IntOrInt =
    i2 match
      case (i, true)  => Right(i) // конструктор правого слагаемого
      case (i, false) => Left (i) // конструктор левого  слагаемого
      
  def обратно(ii: IntOrInt): Int2 =
    ii match
      case Right(i) => (i, true)  // правое слагаемое
      case Left(i)  => (i, false) // левое  слагаемое
  
  assert((обратно compose туда)(i2) == i2) // для любых i2
  assert((туда compose обратно)(ii) == ii) // для любых ii
```
Если мы можем предоставить две такие функции между типами, композиция которых даёт тождественные отображения, то говорят, что типы **изоморфны**. При использовании изоморфных типов будут отличаться разве что синтаксические конструкции, но это будут по прежнему одни и те же данные.

В программировании изоморфизм двух типов соответствует **взаимной подтипизации** - изоморфные типы являются подтипом друг друга. Понятное дело, что такое не получится организовать через "наследование".

Используя обозначение $\simeq$ мы можем записать изоморфизм из примера выше так:
$$A+A\simeq A\times2,$$
где $2$ - это тип с двумя значениями. 

Аналогично, для изоморфизма $$A\times A\simeq A^2,$$можно предоставить такие методы:
```scala
  type IntInt = (Int, Int)        // Int × Int
  type BoolToInt = Boolean => Int // 2 => Int

  def туда(ii: IntInt): BoolToInt =
    b =>
      if (b)  ii._1
      else    ii._2

  def обратно(i2: BoolToInt): IntInt = (
    i2(true),
    i2(false),
  )
  
  assert((обратно compose туда)(ii) == ii) // для любых ii
  assert((туда compose обратно)(i2) == ii) // а так Scala не сумеет))
```

Старая добрая школьная алгебра, не так ли? Более того, суммы и произведения типов удовлетворят (с точностью до изоморфизма) основным алгебраическим законам:
- *коммутативность*: $A+B\simeq B+A,\;A\times B\simeq B\times A$;
- *ассоциативность*: $A+(B+C)\simeq(A+B)+C,\;A\times(B\times C)\simeq(A\times B)\times C;$ 
- *дистрибутивность*: $A\times(B+C)\simeq A\times B+A\times C.$

Как правило, эти законы не работают в популярных языках программирования автоматически. Разве что, в Scala эти правила выполняются для объединения и пересечения типов, которые для *различающихся* типов с натяжкой можно считать суммой и произведением. Но в Scala есть техническая возможность связать изоморфизмом типы, ненаследующие друг другу, реализовав неявные преобразования между ними.

Для экспоненциала также можно записать знакомые со школы выражения. Но зачастую для них в языках программирования предоставляются специальные механизмы. Рассмотрим их подробнее.

### Cопоставление с шаблонами

Тип суммы определяется своими конструкторами - способами получения значения этого типа. Но гораздо важнее то, как мы эти значения сможем **использовать** - как из них можно получить значения другого типа. Общие соображения подсказывают нам, что для того чтобы преобразовать значения типа суммы в другой тип, нужно предоставить соответствующие преобразования в этой тип из значений типов-слагаемых. Алгебраические соотношения говорят нам то же самое:
$$A^{B+C+D}\simeq A^B\times A^C\times A^D.$$
То есть, функцию из $B+C+D$ в $A$ можно построить, если у нас есть все три функции в $A$ из $B$, $C$ и $D$. Для этих целей и предназначен упомянутый ранее механизм *сопоставления с шаблонами*:
```scala
  val patternMatching         // Int + Boolean + Double => String
    : Int | Boolean | Double => String =
      case i: Int     => "целое " + i        // Int     => String
      case b: Boolean => "булево " + b       // Boolean => String
      case d: Double  => "рациональное " + d // Double  => String
```
Компилятор сам отслеживает, чтобы при сопоставлении с шаблонами были учтены все альтернативы - все слагаемые типа-суммы, и чтобы у каждой ветки был обработчик-функция соответствующего типа.

Для стандартных (и многих сторонних) типов-сумм в Scala предоставляются специальные методы, дающие те же возможности, но без необходимости использовать синтаксический сахар:
```scala
  val eFold: Int Either Double => String = // Int + Double => String
    intOrDouble => intOrDouble.fold(       // λ-выражение
      i => "целое " + i,                   // Int          => String
      d => "рациональное " + d)            // Double       => String
```

### Каррирование

Чтобы вычислить некоторое выражение, зависящее от переменных, нужно построить на его основе функцию и передать эти переменные как аргументы (захват переменных, определённых вручную, сейчас рассматриваем). Но сделать это можно несколькими способами:
```scala
  val f1
    : (Int, Boolean) => String
    = (i, b) => if ((i > 0) && b) "тру!" else "дырка!"

  val f2
    : Int => (Boolean => String)  // скобки лишние ("правая ассоциативность")
    = i => b => if ((i > 0) && b) "тру!" else "дырка!"

  f1(-2, false) // "тру!"
  f2(-2)(false) // "тру!"
```
Функции - это "первоклассные объекты", и мы можем просто вернуть из функции другую функцию, в теле которой "захвачен" аргумент родительской!

Две функции из примера выше основаны на одном выражении `if ((i > 0) && b) "тру!" else "дырка!"` и отличаются друг от друга только способом связывания переменных и своим типом. Не сложно догадаться, что эти типы также связаны изоморфизмом. Соответствующие функции преобразования от одного типа к другому очевидны, и они уже есть в Scala - это метод `curried` (в Scala функции являются экземплярами ООП-класса, и имеют свои методы) и функция `Function.uncurried`:
```scala
  import Function.uncurried
  assert(f1.curried(i)(b)    == f2(i)(b)) // для любых i, b
  assert(uncurried(f2)(i, b) == f1(i, b)) // для любых i, b
```

Ниже приведён немного искусственный пример использования метода `curried`:
```scala
  // Int × (Int => Int) => Int
  def doubleModification(i: Int, modifier: Int => Int): Int =
    modifier(modifier(i))

  val sum
    : (Int, Int) => Int
    = (a, b) => a + b
  sum(2, 2)                    // 4

  val add5 = sum.carried(5)    // Int => Int
  doubleModification(2, add5)  // 12
```
У нас есть функция, `doubleModification`, которая принимает целое число, некоторую функцию-модификатор, и применяет эту функцию к целому числу *дважды*. И так же есть функция от двух целых чисел, просто складывающая их. Для двойного прибавления к некому числу (например, 2) заданного числа (например, 5) можно сперва построить каррированную версию функции сложения, и применить её к прибавляемому числу (5). Так мы получим функцию, принимающую только один аргумент - оставшееся слагаемое. И эту функцию мы можем смело передавать в `doubleModification`.

Ключевой момент здесь - чтобы скомбинировать сложение с `doubleModification` нам не нужно описывать новую функцию вручную - мы просто (явно, с помощью `curried`) получаем значение изоморфного функционального типа!

Из примеров выше видно, что в Scala и вызов, и определение функции и её каррированной версии отличаются лишь синтаксисом. В некоторых языках программирования (например ML-семейство - Haskell, F# и т.п.) для таких функций используется одинаковый синтаксис. Например в F#:
```fsharp
let sum a b = a + b
let four = sum 2 2 // 4
let add2 = sum 2   // Int => Int
let five = add2 3  // 5
```

Не важно, как вашем любимом языке программирования обрабатывается каррирование, само по себе оно является следствием "школьного" алгебраического изоморфизма типов:
$$A^{B\times C}\simeq \left(A^B\right)^C.$$

### (Не)важные понятия

Видимо так сложилось исторически, но в программировании накопились такие "важные" понятия:
- *каррированная функция*,
- *частичное применение* (каррированной функции),
- функции, как *объекты первого класса*,
- функции *высокого рода*,
- и т.п.

"Необходимость" знания таких "высокородных первоклассностей" повышает порог вхождения в функциональное программирование, но при этом сами понятия практически не имеют самостоятельного веса... Самое важное, что нужно понимать - это то, что в теории типов и в программировании функции являются **обычными значениями обычных (функциональных) типов** - и, так же как и другие значения, их можно передавать как параметры функций и возвращать их из функций. Да, существуют языки программирования, которые так не умеют, но мало кто о них знает, и "тут о таких не поют".

### Ноль

### Единица

Можно было бы ожидать, что в Scala также тип `Unit` играет роль супертипа всех типов, но к сожалению это не так. `Unit` относится к семейству "типов-значений", а это семейство не пересекается со "ссылочными типами". Роль суппер-пуппер типа в Scala выполняет `Any` - для него работают механизмы отражений (динамическая типизация), Null и прочее тяжелое наследие ООП-шной Java.
