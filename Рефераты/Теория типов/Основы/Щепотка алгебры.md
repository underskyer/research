В предыдущем разделе на первой диаграмме показан тип $B$, который можно было представить и как $A+A$ и как $A\times2$. Эти представления не эквиваленты - они представляют разную семантику работы со значениями этих типов. Но они **изоморфны** - между множествами их значений можно построить **взаимно-однозначное соответствие** (две функции в противоположные направления, композиция которых даёт тождественное отображение):
```scala
  type Int2 = (Int, Boolean)      // Int × 2
  type IntOrInt = Int Either Int  // Int + Int

  def туда(i2: Int2): IntOrInt =
    i2 match
      case (i, true)  => Right(i) // конструктор правого слагаемого
      case (i, false) => Left (i) // конструктор левого  слагаемого
      
  def обратно(ii: IntOrInt): Int2 =
    ii match
      case Right(i) => (i, true)  // правое слагаемое
      case Left(i)  => (i, false) // левое  слагаемое
  
  assert((обратно compose туда)(i2) == i2) // для любых i2
  assert((туда compose обратно)(ii) == ii) // для любых ii
```
Это означает, что изоморфные типы мы можем использовать в своих программах равноэффективно (речь не про производительность) - просто будут отличаться синтаксические конструкции.

В программировании изоморфизм двух типов соответствует взаимной подтипизации -  каждый тип является подтипом другого. Понятное дело, что через такое не получится организовать через "наследование".

Используя изоморфизм (тут используем обозначение $\simeq$) как отношение эквивалентности мы можем записать такие "равенства":
$$A+A\simeq A\times2,$$
$$A\times A\simeq A^2,$$
где $2$ - это тип с двумя значениями.

Старая добрая школьная алгебра, не так ли? Более того, суммы и произведения типов удовлетворят (с точностью до изоморфизма) основным алгебраическим законам:
- ассоциативность: $A+(B+C)=(A+B)+C,\;A\times(B\times C)=(A\times B)\times C;$ 
- коммутативность: $A+B\simeq B+A,\;A\times B\simeq B\times A$;
- дистрибутивность: $A\times(B+C)=A\times B+A\times C.$

Как правило, эти законы не работают в популярных языках программирования автоматически. Разве что, в Scala эти правила выполняются для объединения и пересечения типов, которые *различающихся* типов с натяжкой можно считать суммой и произведением.

Для экспоненициала также можно записать знакомые со школы выражения. Но для них зачастую в языках программирования предоставляются специал
$A^{B+C}\simeq A^B\times A^C$ - сопоставление с шаблонами.
$A^{B\times C}\simeq \left(A^B\right)^C$ - каррирование

*Правая*  (**или левая???**):
$A+(B+C)=(A+B)+C,\;A\times(B\times C)=(A\times B)\times C$

Коммутативность

 - дистрибутивность