
Рассмотрим сумму двух одинаковых типов $B=A+A$. Это значит, что у нас есть два конструктора типа $B$ из типа $A$. Сумма типов устроена так, что её значения "помнят", каким конструктором они были созданы - это необходимо, чтобы из типа суммы получить значения какого-либо другого типа, если мы знаем, как их получить из значений типов-слагаемых (сопоставление с шаблонами). Фактически это значит, что для типа $A+A$ у нас есть не только проекция обратно в $A$, но в некий индексирующий тип, значения которого определяют выбор того или иного слагаемого.

Это можно визуализировать с помощью такой диаграммы:
![[произведение из суммы.png]]
Здесь $i_1$ и $i_2$ - два конструктора типа $B$, а $2$ - это тот самый индексирующий тип, у которого в нашем случае есть только два возможных значения. Получается, что тип $B$, представленный на диаграмме, можно определить двумя разными способами - и как сумму $A+A$ и как произведение $A\times2$!

Тут стоит обратить внимание на такую идею: значения нашего индексирующего типа *ставятся в соответствие* функциям из $A$ в $B$. Так может быть эти функции также являются значениями какого-то типа?..

Но сперва давайте рассмотрим ту же самую диаграмму, но с другой точки зрения. Теперь будем считать, что $A=B\times B$, и вместо конструкторов типа $B$  $i_1$ и $i_2$ теперь у нас теперь есть проекторы типа $A$  $p_1$ и $p_2$. Поэтому, имея значение типа $A$ мы можем получить значение типа $B$, только если мы **выберем** один доступных проекторов, т.е. на момент вычисления у нас на руках есть, помимо значения типа $A$, есть ещё и предпочтённый индекс проектора. Такая пара значений относится к типу $A\times2$, где $2$ - тип, индексирующий проекторы $A$. Тогда имея значение типа $A\times2$ у нас будет возможность вычислить (evaluate) значение типа $B$:
![[экспоненциал из произведения.png]]
Эти соотношения справедливы для любых индексирующих типов - для любого количества проекторов (или, дуально, конструкторов).

Такой тип, чьи проекторы в некий тип $B$ индексируются типом $C$ обозначают как $B^C$ и называют **экспоненциалом**. Более точно экпоненициал определяется через своё универсальное свойство:
![[экспоненциал.png]]
Для любого типа $A$ и функции $g$ существует единственные тип $B^C$ и функция $u$, делающие эту диаграмму коммутативной.

Экспоненциал $B^C$ имеет очень простую трактовку - это **тип функций** из значений типа $C$ в тип $B$. Пара значений $(f, c)$ типа $B^C\times C$ - это всё, что необходимо для вычисления значения $f(c)$.

Функции, как значения некоторого типа, ("[первоклассные функции](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)") есть в том или ином виде практически во всех популярных языках программирования: "указатели на функцию" в С++, "делегаты" в C# и т.п. В Scala для типа функций обычно используются конструкции такого вида:
```scala
  val toStr: Int => String =    // тип функции
    i => "#"                    // λ-выражение
    
  def toStringDoubled(          // бестолковый метод
    i: Int,
    intToString: Int => String  // получаем значение-функцию
  ): String =
    val str = intToString(i);   // используем значение-функцию
    s"($str, $str)"
```
$\lambda$-выражения по сути являются литералами значений функционального типа - они так же присутствуют в большинстве языков программирования. Помимо $\lambda$-выражения, для получений значения функционального типа многие языки позволяют (неявно) использовать ссылки на какой-то метод:
```scala
  def doubleDouble(i: Int): Double = i * 2.0
  val intToDouble: Int => Double = doubleDouble // ссылка на метод
```

