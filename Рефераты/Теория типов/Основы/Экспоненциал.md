
Рассмотрим сумму двух одинаковых типов $B=A+A$. Это значит, что у нас есть два конструктора типа $B$ из типа $A$. Сумма типов устроена так, что её значения "помнят", каким конструктором они были созданы - это необходимо, чтобы из типа суммы получить значения какого-либо другого типа, если мы знаем, как их получить из значений типов-слагаемых (сопоставление с шаблонами). Фактически это значит, что для типа $A+A$ у нас есть не только проекция обратно в $A$, но в некий индексирующий тип, значения которого определяют выбор того или иного слагаемого.

Это можно визуализировать с помощью такой диаграммы:
![[Рефераты/Теория типов/изображения/Произведение из суммы.png]]
Здесь $i_1$ и $i_2$ - два конструктора типа $B$, а $2$ - это тот самый индексирующий тип, у которого в нашем случае есть только два возможных значения. Вот так, лёгким движением руки сумма превращается в произведение!

Тут несколько вольно используется символ $=$ по отношению к типам. На самом деле тут выражение $A+A=A\times2$ означает, не то, что типы буквально **равны**, но то, что они **изоморфны** - между значениями типа всегда можно построить взаимно-однозначное отображение:
```scala
  type Int2 = (Int, Boolean)      // Int × 2
  type IntOrInt = Int Either Int  // Int + Int

  def туда(i2: Int2): IntOrInt =
    i2 match
      case (i, true)  => Right(i) // конструктор правого слагаемого
      case (i, false) => Left (i) // конструктор левого  слагаемого
      
  def обратно(ii: IntOrInt): Int2 =
    ii match
      case Right(i) => (i, true)  // правое слагаемое
      case Left(i)  => (i, false) // левое  слагаемое
```

Тут стоит обратить внимание на такую идею: значения нашего индексирующего типа *ставятся в соответствие* функциям из $A$ в $B$. Так может быть эти функции также являются значениями какого-то типа?..

Но сперва давайте рассмотрим ту же диаграмму, но с другой точки зрения. Теперь будем считать, что $A=B\times B$ и вместо конструкторов типа $B$  $i_1$ и $i_2$ теперь у нас теперь есть проекторы типа $A$  $p_1$ и $p_2$. Поэтому, имея значение типа $A$ мы можем получить значение типа $B$, только если мы **выберем** один доступных проекторов, т.е. на момент вычисления у нас на руках есть помимо значения типа $A$ ещё и индекс проектора. Эта пара значений относится к типу $A\times2$, где $2$ - тип, индексирующий проекторы $A$. Тогда имея значение типа $A\times2$ у нас будет возможность вычислить (evaluate) значение типа $B$:
![[экспоненциал из произведения.png]]
Эти соотношения справедливы для любых индексирующих типов - для любого количества проекторов (или, дуально, конструкторов).

Такой тип, чьи проекторы в некий тип $B$ индексируются типом $C$ обозначают как $B^C$ и называют **экспоненциалом**. Более точно экпоненициал определяется через своё универсальное свойство:
![[экспоненциал.png]]
Для любого типа $A$ и функции $g$ существует единственные тип $B^C$ и функция $u$, делающие эту диаграмму коммутативной.

Экспоненциал $B^C$ имеет очень простую трактовку - это **тип функций** из значений типа $C$ в тип $B$. Пара значений $(f, c)$ типа $B^C\times C$ - это всё, что необходимо для вычисления значения $f(c)$.

Функции, как значения некоторого типа, ("[первоклассные функции](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)") есть в том или ином виде практически во всех популярных языках программирования: в С++ это "указатели на функцию", в C# это "делегаты" и т.п. В Scala для типа функций обычно используются конструкции такого вида:
```scala
  val toStr: Int => String =    // тип функции
    i => "#"                    // λ-абстракция
    
  def duplicate(
    i: Int,
    intToString: Int => String  // принимаем значения-функции
  ): String =
    val s = intToString(i);     // используем значение-функцию
    s"($s, $s)"
```
$\lambda$-выражения по сути являются литералами значений функционального типа - они так же присутствуют в большинстве языков программирования. Помимо $\lambda$-выражения значения функционального типа, как правило, можно получить с помощью $\eta$-конверсии - преобразования (во многих языках, неявного) из ссылки на какой-то метод:
```scala
  def doubleDouble(i: Int): Double = i * 2.0
  val intToDouble: Int => Double = doubleDouble
```
Но всё же $\lambda$-исчисление - это несколько иной раздел математики, поэтому мы сейчас не будем туда углубляться.

