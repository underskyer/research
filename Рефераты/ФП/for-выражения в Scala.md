
### Свиридов Сергей Анатольевич

![[for-выражения.png]]

Краткая иллюстрация, почему я **рекомендую избегать** for-выражений. 1) оборачивание всего что попало в `F[_]` только ради for! 2) характерный для for паттерн `_ <-` прощающий любые ошибки


### Яковлев Сергей Владимирович

То есть рекомендуешь не использовать for-comprehension? Который считается практически одной из "киллер-фич" Скалы, позволяющий получить императивный вид куска программы..
По 2) без for это `oneMethod().map(_ => anotherMethod())` и чем он лучше


### Свиридов Сергей Анатольевич

Ты так говоришь, будто в "императивном виде" есть хоть что-то хорошее... "Киллер-фичей" это считается только потому, что относительно легко пересадить на "контейнерные" вычисления молодых императивщиков, которых учили так говнокодить чуть ли ни с детского сада. Так что опять же, не надо верить наслово маркетинговым клише))

На самом деле тут речь идёт не столько об императивности, сколько об алгоритмах, основанных на стеке. Это очень низкоуровный подход, опирающийся на архитектуру современных процессоров. Но он допускает такие косяки, как неправильная последовательность действий, лишние действия, забывание промежуточных результатов, ошибочное использование не тех промежуточных результатов из мусорной кучи (стека).

Более безопасной альтернативой стековым вычислениям являются цепочки вычислений, когда на каждом шаге доступна не вся куча промежуточных результатов (стек), а только те данные, которые требуются для продолжения вычислений. При такой технике гораздо сложнее перепутать порядок действий, или случайно забыть результат предыдущего шага. Кроме того, в отличие от `for` такой подход не побуждает всё подряд заворачивать в контейнер (оба косяка из моего примера сводились в итоге к этому).

В твоём же фрагменте кода, судя по всему, `anotherMethod` - чистая функция, вызов которой без аргументов эквивалентен константе. Чаще встречается аналогичный код с `flatMap`, позволяющий комбинировать побочные эффекты. И несмотря на популярность `.flatMap(_ => ...)`, забывание предыдущих вычислений - небезопасный путь. В подобных случаях более правильным было бы использование бизнесОвых состояний ("одиночки", изоморфные Unit) и переходов между ними по стрелкам вида `State3 => F[State4]`. В нашей кодовой базе я такого не встречал...


### Яковлев Сергей Владимирович

На счет "верить маркетинговым клише": я считаю что императивный стиль дает простой, понятный, логичный вид вместо кучи комбинаций map и flatMap - "callback hell".
А по поводу моего пример, да там надо было `flatMap` написать.


### Свиридов Сергей Анатольевич

Меня в своё время тоже вполне устраивал императивно-ООПшнй стиль. Пока не познакомился с функциональной парадигмой.

Дело в том, что "императивный сталь" **объективно** хуже, безотносительно личных предпочтений. Он более костыльный, более многословный и **систематически** провоцирует на ошибки, что ни в каком смысле не хорошо.

Те же `for`-выражения - синтаксический мусор сахар над тремя комбинаторами: `map`, `flatMap` и `filter` В то время как на практите их очень редко бывает достаточно. Поэтому любителям `for` постоянно приходится перегружать свой код разнородным синтаксиосм, сочетая "сахар" с обычными цепочками преобразований. Необходимостью такого комбинирования иногда оправдываются прямо-таки монструозные конструкции, из-за чего зачастую страдает и логика, что не всегда заметно по коду.

Вот несколько примеров кода из NGFW Предлагаю оценить, стало бы лучше, или хуже, если бы этот код переписать посредством `for`.

```scala
lazy val updateKnownIntrefaces = getActualInterfaces map getNames flatMap knownSaver.putInterfacesNames
```

```scala
        lazy val handleRoutes = (routes: Option[List[RoutingConfigV1.Route]]) =>
          (
            routes traverse filterRoutes,
            obtainInitializedFrrStaticRoutes,
            actualRoutesCount
          ).tupled flatMap replaceRoutes.tupled
```

```scala
        lazy val handleInterfaces =
          (_*: Option[List[InterfaceConfig]])
            .toList.flatten
            .filterA(ifConfig => AppCtx.access.map(_*.nodeId == ifConfig.nodeId))
            .flatMap(interfacesConfigurator.configure)
```

```scala
    lazy val handleNewNames = (getActualInterfaces map getNames zip knownGetter.getInterfacesNames)
      .map(_.sequence)
      .flatMap {_
        .map(shutdownNewInterfaces.tupled &&& handleDeletedInterfaces.tupled)
        .traverse(_.tupled)
      }
```

```scala
      vlanId = vlanNamePattern
        .findFirstMatchIn(interface.ifname)
        .flatMap(_.subgroups.headOption)
        .flatMap(_.toIntOption)
        .flatMap(VLanId.fromInt),
```

А "callback hell" - это не то, чтобы про комбинирование вычислений. Это устаревшее понятие с тех времён, когда ещё не было проработано удобных инструментов и техник для "стиля передачи продолжений".


### Яковлев Сергей Владимирович

> Предлагаю оценить, стало бы лучше, или хуже, если бы этот код переписать посредством for.

На прошлом месте работы было правило, что если больше одного map/flatMap, то использовать for-comprehension, и причем внутри for не использовать map/flatMap (если прям тяжело внутри без доп map/flatMap то в отдельный метод кусок вытащить) - и все были довольны и код выглядел легко читаемым.


### Свиридов Сергей Анатольевич

Из хорошего в этих правилах - только декомпозиция, если код сложный. в остальном - сочувствую. такие ограничения не способствуют ни качественному коду, ни развитию навыков. кроме того, я говорил не столько о вложенных map/flatMap, а о прочих комбинаторах (zip, tupoled, traverse, filterA и т.п.), выносить которые в отдельные методы, _лишь бы угодить стиль `for_` было бы слишком расточительно.

И правила в той компании ни как не отвечают на мой вопрос по приведённым фрагментам кода))


### Яковлев Сергей Владимирович

Основной профит от for-compehension в такого вида вычислениях:

```scala
for {
  a <- methodA()
  b <- methodB()
  c <- methodC(a)
  d <- methodD(b, c)
  _ <- methodE(b,d)
} yield d
```

Где, например, `def methodA(): IO[A] = ???`

Попробуй переделай в map/flatMap и увидишь аналог "callback-hell" (назовем это аналог)

А прочие комбинаторы никуда не убираются а используются в `for`.


### Свиридов Сергей Анатольевич

Проста этого кода - кажущаяся. Сложность проявится при попытке зарефакторить этот код. проблема опять же в "стековости" - последовательность действий не фиксирована чётко.
- Можно переставить местами 1 и 2 шаги, 2 и 3.
- Промежуточные значения не используются в результате.
- Если типы значений совпадают, например, `a` и `d`, то скомпилируется и такой вариант: `methodE(b, a)` т.е. область видимости опасно замусорена лишними идентификаторами.

Переписать можно так:
```scala
    methodB()                      both
    (methodA() flatMap methodC)    mproduct
    methodD.tupled                 map
    { case ((b, c), d) => (b, d) } flatTap
    methodE.tupled                 map
    {_._2}
```
В этом варианте слева находятся ключевые операции, шаги цепочки вычислений, а справа - комбинаторы.

Или можно переписать в более императивном стиле:
```scala
methodB()
    .both(methodA() flatMap methodC)
    .mproduct(methodD.tupled)
    .map{ case ((b, c), d) => (b, d) }
    .flatTap(methodE.tupled)
    .map{_._2}
```
Появились лишние точки и скобочки, но накаждом шаге сразу видно, как он комбинируется с предыдущим.

В том-то и дело! Помимо обычных операций с контейнерами приходится использовать ещё и дополнительный (необязательный!) синтаксис. Т.е. усложняется инструментарий разработки. Причём привносит лишь дополнительные опасности. Вред есть, а польза мнимая (потакание привычкам большинства).


### Яковлев Сергей Владимирович

Ну я даже не знаю как сказать, это же намного сложнее читается и понимается:
```scala
methodB()
    .both(methodA() flatMap methodC)
    .mproduct(methodD.tupled)
    .map{ case ((b, c), d) => (b, d) }
    .flatTap(methodE.tupled)
    .map{_._2}
```
против этого:
```scala
for {
  a <- methodA()
  b <- methodB()
  c <- methodC(a)
  d <- methodD(b, c)
  _ <- methodE(b,d)
} yield d
```
В твоем примере куча операторов дополнительных, которые нужно осмысливать и следить правильно ли все передано, а в for нет операторов, просто вызовы методов и результаты в качестве аргументов потом используются. В итоге читать чужой код насыщенный кучей операторов намного медленнее получится…


### Сивак Даниил Олегович

> проста этого кода - кажущаяся. > сложность проявится при попытке зарефакторить этот код.

По-моему это либо какая-то надуманная проблема ради аргумента, либо не проблема вообще. Я не помню когда у меня из-за "стековости" фора были какие-то затруднения с рефакторингом.

Вот код типа
```scala
    methodB()                      both
    (methodA() flatMap methodC)    mproduct
    methodD.tupled                 map
    { case ((b, c), d) => (b, d) } flatTap
    methodE.tupled                 map
    {_._2}
```
Pарефакторить то конечно намного проще (тут даже сходу непонятно что происходит вообще)))


### Свиридов Сергей Анатольевич

Сперва модный в наше время *disclaimer*.
@Яковлев, код на подобие твоего я без комментариев пропускаю на ревью, однако сам бы так не *скорее всего* не написал бы. В данном алгоритме бросается в глаза странная последовательность передачи параметров. Поэтому, какой бы вариант я ни предпочёл, сперва попробовал бы реорганизовать методы – как вызываемые, так и вызывающий.


> Читать чужой код насыщенный кучей операторов намного медленнее получится

Дело не только в “скорости чтения”, сколько в “скорости понимания”. `for` даёт понимание необходимости именно таких действий **не многим больше**, чем в анекдоте про Шерлока Холмса на воздушном шаре. `for` даёт “простоту недопонимания”. А вот с бесстековой композицией такой ситуации не возникнет – если понимаешь код, то полностью.


> Не помню затруднений с рефакторингом из-за "стековости" `for`

При рефакторинге не достаточно поверхностного “лёгкого чтения“. Придётся вникать глубже, разбираться, почему шаги указаны именно в этом порядке и почему передаются именно эти параметры, а не другие… “Стековость” не ограничивает программиста лишь необходимыми действиями, провоцирует труднодиагностируемые ошибки, и в целом “*размывает точность*” алгоритма, которую требуется понять при рефакторинге, чтобы ничего не упустить.

Часто рефакторинг `for` не вызывает сложностей у опытных программистов. Просто обычно `for` устроены проще, чем в примере Сергея. Но в более сложных ситуациях, помимо характерных для `for` косяков, на рефакторинге могут появится ещё и связанные с недостаточным пониманием первоначальной задумки автора, которую `for` просто не способен донести в точности – *`for` не обязывает быть точным*.


> следить, правильно ли все передано

Как раз наоборот, это `for` обязывает программиста постоянно за этим следить. А программист, как известно, машина не очень надёжная. Косячит регулярно. В то время как в бесстековой композиции за этим следит компилятор – он просто не позволит передать “что-то не то”.


> Тут даже сходу непонятно что происходит вообще))

А я расскажу))
- Метод `both` склеивает два значения в контейнере `(IO[A], IO[B]) => IO[(A, B)]`. Чаще такой метод называется `zip`, или `tupled` и иногда реализуется через класс типов `Applicative`, отвечающий за независимое (параллельное) вычисление. Метод `both` гораздо точнее описывает суть алгоритма, чем последовательные вычисления посредством `flatMap` в `for`-выражении.
- Выражение `(methodA() flatMap methodC)` показывает, что нам безразличен результат `methodA`, для него не нужно заводить отдельную переменную, которая потом будет только мешаться. Важен лишь результат комбинации этих методов.
- Комбинатор `mproduct` интереснее, так как он склеивает входной параметр с результатом вычислений (произведение входа и выхода). Сразу становится ясно, что входной параметр нам понадобится ещё и на следующем шаге.
- Выражение `map { case ((b, c), d) => (b, d) }` призвано “забыть” лишнее значение. Явно даём понять, что дальше нам не понадобится `c`.
- Наконец, `flatTap` позволяет игнорировать результат последующего вычисления, пробрасывая дальше лишь входные параметры.
В итоге код получился более алгоритмически точным, причём, в отличие от `for`, все важные моменты прописаны явно. В таком стиле вероятность допустить ошибку существенно ниже, чем с `for`-выражениями. Технически, можно даже в рамках Scala переписать этот алгоритм ещё более выразительно (например, избавится от шага явного “забывания“), но даже так всё выглядит неплохо.


> В твоем примере куча операторов дополнительных, которые нужно осмысливать

 В Scala (да и вообще много где) повсеместно используются “вычисления в контейнерах”. Для них характерны возможности **всего трёх видов (!)**:
 - ковариантность (`map`);
 - дистрибутивность (`sequence`, `tupled` и т.п.);
 - “естественные преобразования” (в т.ч. монады и комонады).
Другие операции строятся как частные случаи (`mproduct`, `tap`, ...) и комбинации вышеперечисленных (`flatMap`, `filter`, …).

В разных фреймворках (и языках) конкретные операции могут называться по-разному. Но когда знаешь, что искать, всегда можно найти наиболее подходящие, и понять код, написанный другими разработчиками. Если же эти три вида возможностей не знакомы Scala-разработчику, то, как говориться, “у меня для вас плохие новости”.

Такие операторы – это профессиональный набор инструментов взамен “любительских” `for`, `<-` или `yield`. Когда некоторое время поработаешь с такими инструментами своего фреймворка (ZIO, IO, …) то они перестают быть “сложными для осмысления”. В то время как вводящиеся в `for` **“стековые” переменные действительно усложняют** код, заставляя держать много мусора в головах разработчика и компьютера.


#### Пару слов про универсальность `for`.

Вспомнился ещё анекдот про универсальность пургена… Но лучше приведу другую аналогию))
`for`-выражения, это как разводной ключ. Простой, универсальный, популярный и привычный. Поэтому даже когда попадаются винты, уже даже мысли не возникает об отвёртке, а лишь о том, как завинтить их разводным ключом. А если кто скажет, что проще винты крутить отверткой, то он не прав, так как привыкать к другим инструментам – это сложно… Но разводной ключ вовсе необязательные инструмент, ведь всегда в запасе есть наборы *значительно более удобных* ключей любой формы и размера, отвёрток и даже того, о чём ты и не думал раньше.

#### Оборачивание for в скобки

```scala
flatMap { _ =>
      (for {
        ...
        ...
        20 строк
        ...
        ...
      } yield savedClusterInfo)
        .whenException(deleteClusterFromCurrentNode(true))
}
```


### Яковлев Сергей Владимирович

> И вот ещё один из "паттернов" любителей for

Ну в этом случае надо делать переменную val something = for{..} yield .. А потом с этой переменной делать цепочечные. Чтоб не было такого нагромождения


### Свиридов Сергей Анатольевич

Понятно, как это можно улучшить. Просто причина такого кода - вера в `for` как в "киллер-фичу", стремление решать любую задачи с помощью "разводного ключа", ведь "если вдруг так случится, что его не хватает, всегда можно рядом воткнуть отвёртку"...


### Яковлев Сергей Владимирович

Это всё замечательно что в Scala такое богатство операторов, и ты топишь за то чтобы их использовать, типа если вы постоянно их будете использовать то привыкните к ним. Ну ок, привыкнем, а смысл? Надо как можно проще и понятнее писать код - это привлечёт к экосистеме больше разработчиков а не единиц-гиков. Вот например сервисный слой приложения: надо выразить сложную бизнес-логику как можно более простыми конструкциями языка чтобы не пришлось например меняя эту логику (когда пришёл запрос от бизнеса) ещё и разбираться с нагромождением tupled

For-comprehesion даёт в этом случае возможность не думать о конструкциях а сосредоточиться на бизнес-логике

### Свиридов Сергей Анатольевич

> чтобы не пришлось меняя эту логику ещё и разбираться с нагромождением tupled

> For-comprehesion даёт в этом случае возможность не думать о конструкциях а сосредоточиться на бизнес-логике

Считаешь, такое “нагромождение конструкций” никак не обусловлено требуемой логикой?)) На самом деле всё как раз наоборот – использование узкоспециализированых комбинаторов гораздо точнее характеризует бизнес-логику, нежели бездумное стековое комбинирование посредством `for`. “Сосредоточиться на бизнес-логике” – это буквально “думать о конструкциях”.


>Ну ок, привыкнем, а смысл? 

Смысл в том, чтобы, отложив в сторону “разводной ключ“ и открыв для себя полный набор инструментов, научиться писать *более качественный код*, а не “так, как раньше”. В итоге – снизить стоимость разработки и сопровождения за счёт уменьшение количества итераций на исправление ошибок, и в целом предоставлять клиентам более качественный продукт.


> Надо как можно проще и понятнее писать код - это привлечёт к экосистеме больше разработчиков

Привлекает внимание к экосистеме популяризация Scala, даже таких её “килер-фич”, как `far`. А от продуктового кода ожидается нечто иное, чем “привлечение разработчиков”. Скалисты бегут со всяких ГГЭ и прочих плеевских и недоплеевских проектов в сторону ZIO, или Cats Effect с их “замороченными возможностями”, которые, внезапно, оказываются притягательнее, чем банальный `flatMap` выражений `for`.

Scala отличается от большинства языков очень мощной системой полиморфных типов высокого рода, что, в частности, позволяет писать код в стилях, автоматически защищающих от самой *возможности появления* ошибок, типичных для стекового программирования. Именно возможность обеспечить более высокое качество программ обеспечивает преимущество Scala над другими языками. И это преимущество нивелируется, если повсеместно использовать `for`-выражения.


#### Linq

Кстати, вот ещё один пример. В C# тоже есть синтаксис, аналогичный `for` в Scala. Он называется Linq (Language Integrated Query) и ориентирован на работу с коллекциями (и с запросами к БД):
```csharp
var query =
    from word in "the quick brown fox jumps over the lazy dog".Split(' ')
    group word.ToUpper() by word.Length into gr
    orderby gr.Key
    select new { Length = gr.Key, Words = gr };
```
У Linq больше приятных плюшек: помимо типовых map, flatMap, filter (в C# другие названия) там есть комбинаторы для группировки, сортировки и т.п. И также как и в `for` можно определять свои “стековые” переменные. И также как с `for`, универсальность linq является мнимой – для слишком многих операций не нашлось подходящего синтаксического сахара. Поэтому, *чтобы не усложнять* стандартный синтаксис вызовов методов с “модным” Linq, хорошим тоном считается избегать по возможности последний:
```scala
var list = "the quick brown fox jumps over the lazy dog"
    .Split(' ')
    .GroupBy(w => w.Length, w => w.ToUpper())
    .Select(g => new { Length = g.Key, Words = g }) // map
    .OrderBy(o => o.Length)
    .ToList();
```

#### Что ты предлагаешь

Итак, `for`-выражения
- формируют “шаблонное мышление” – бизнес-логика варварски подгоняется под “разводной ключ” `for`;
- замусоривают код бесполезными идентификаторами, размазывая представление о последовательности действий, и приводя к появлению труднодиагностируемых ошибок;
- мнимая “универсальность” приводит к необходимости всё равно встраивать специализированные комбинаторы, что иногда приводит к просто ужасному коду (прежде всего как раз у начинающих скалистов);
- не способствует развитию навыков программирования (скорее наоборот).
Зато “стековые” вычисления всем привычны и поэтому “легко читаются”…

Ты предлагаешь всем программистам, независимо от уровня, использовать “легкочитаемые” `for`-выражения с тем, чтобы упростить жизнь неофитам.

Я же предлагаю объяснять, что `for`-выражения – это костыли, которые необходим новичкам до тех пор, пока они не проникнутся ФП и не смогут бегать без костылей.
Предлагаю повышать уровень новичков, а не опускаться до их уровня.
