
### Свиридов Сергей Анатольевич

![[for-выражения.png]]

Краткая иллюстрация, почему я **рекомендую избегать** for-выражений. 1) оборачивание всего что попало в `F[_]` только ради for! 2) характерный для for паттерн `_ <-` прощающий любые ошибки


### Яковлев Сергей Владимирович

То есть рекомендуешь не использовать for-comprehension? Который считается практически одной из "киллер-фич" Скалы, позволяющий получить императивный вид куска программы..
По 2) без for это `oneMethod().map(_ => anotherMethod())` и чем он лучше


### Свиридов Сергей Анатольевич

Ты так говоришь, будто в "императивном виде" есть хоть что-то хорошее... "Киллер-фичей" это считается только потому, что относительно легко пересадить на "контейнерные" вычисления молодых императивщиков, которых учили так говнокодить чуть ли ни с детского сада. Так что опять же, не надо верить наслово маркетинговым клише))

На самом деле тут речь идёт не столько об императивности, сколько об алгоритмах, основанных на стеке. Это очень низкоуровный подход, опирающийся на архитектуру современных процессоров. Но он допускает такие косяки, как неправильная последовательность действий, лишние действия, забывание промежуточных результатов, ошибочное использование не тех промежуточных результатов из мусорной кучи (стека).

Более безопасной альтернативой стековым вычислениям являются цепочки вычислений, когда на каждом шаге доступна не вся куча промежуточных результатов (стек), а только те данные, которые требуются для продолжения вычислений. При такой технике гораздо сложнее перепутать порядок действий, или случайно забыть результат предыдущего шага. Кроме того, в отличие от `for` такой подход не побуждает всё подряд заворачивать в контейнер (оба косяка из моего примера сводились в итоге к этому).

В твоём же фрагменте кода, судя по всему, `anotherMethod` - чистая функция, вызов которой без аргументов эквивалентен константе. Чаще встречается аналогичный код с `flatMap`, позволяющий комбинировать побочные эффекты. И несмотря на популярность `.flatMap(_ => ...)`, забывание предыдущих вычислений - небезопасный путь. В подобных случаях более правильным было бы использование бизнесОвых состояний ("одиночки", изоморфные Unit) и переходов между ними по стрелкам вида `State3 => F[State4]`. В нашей кодовой базе я такого не встречал...


### Яковлев Сергей Владимирович

На счет "верить маркетинговым клише": я считаю что императивный стиль дает простой, понятный, логичный вид вместо кучи комбинаций map и flatMap - "callback hell".
А по поводу моего пример, да там надо было `flatMap` написать.


### Свиридов Сергей Анатольевич

Меня в своё время тоже вполне устраивал императивно-ООПшнй стиль. Пока не познакомился с функциональной парадигмой.

Дело в том, что "императивный сталь" **объективно** хуже, безотносительно личных предпочтений. Он более костыльный, более многословный и **систематически** провоцирует на ошибки, что ни в каком смысле не хорошо.

Те же `for`-выражения - синтаксический мусор сахар над тремя комбинаторами: `map`, `flatMap` и `filter` В то время как на практите их очень редко бывает достаточно. Поэтому любителям `for` постоянно приходится перегружать свой код разнородным синтаксиосм, сочетая "сахар" с обычными цепочками преобразований. Необходимостью такого комбинирования иногда оправдываются прямо-таки монструозные конструкции, из-за чего зачастую страдает и логика, что не всегда заметно по коду.

Вот несколько примеров кода из NGFW Предлагаю оценить, стало бы лучше, или хуже, если бы этот код переписать посредством `for`.

```scala
lazy val updateKnownIntrefaces = getActualInterfaces map getNames flatMap knownSaver.putInterfacesNames
```

```scala
        lazy val handleRoutes = (routes: Option[List[RoutingConfigV1.Route]]) =>
          (
            routes traverse filterRoutes,
            obtainInitializedFrrStaticRoutes,
            actualRoutesCount
          ).tupled flatMap replaceRoutes.tupled
```

```scala
        lazy val handleInterfaces =
          (_*: Option[List[InterfaceConfig]])
            .toList.flatten
            .filterA(ifConfig => AppCtx.access.map(_*.nodeId == ifConfig.nodeId))
            .flatMap(interfacesConfigurator.configure)
```

```scala
    lazy val handleNewNames = (getActualInterfaces map getNames zip knownGetter.getInterfacesNames)
      .map(_.sequence)
      .flatMap {_
        .map(shutdownNewInterfaces.tupled &&& handleDeletedInterfaces.tupled)
        .traverse(_.tupled)
      }
```

```scala
      vlanId = vlanNamePattern
        .findFirstMatchIn(interface.ifname)
        .flatMap(_.subgroups.headOption)
        .flatMap(_.toIntOption)
        .flatMap(VLanId.fromInt),
```

А "callback hell" - это не то, чтобы про комбинирование вычислений. Это устаревшее понятие с тех времён, когда ещё не было проработано удобных инструментов и техник для "стиля передачи продолжений".


### Яковлев Сергей Владимирович

> Предлагаю оценить, стало бы лучше, или хуже, если бы этот код переписать посредством for.

На прошлом месте работы было правило, что если больше одного map/flatMap, то использовать for-comprehension, и причем внутри for не использовать map/flatMap (если прям тяжело внутри без доп map/flatMap то в отдельный метод кусок вытащить) - и все были довольны и код выглядел легко читаемым.


### Свиридов Сергей Анатольевич

Из хорошего в этих правилах - только декомпозиция, если код сложный. в остальном - сочувствую. такие ограничения не способствуют ни качественному коду, ни развитию навыков. кроме того, я говорил не столько о вложенных map/flatMap, а о прочих комбинаторах (zip, tupoled, traverse, filterA и т.п.), выносить которые в отдельные методы, _лишь бы угодить стиль `for_` было бы слишком расточительно.

И правила в той компании ни как не отвечают на мой вопрос по приведённым фрагментам кода))


### Яковлев Сергей Владимирович

Основной профит от for-compehension в такого вида вычислениях:

```scala
for {
  a <- methodA()
  b <- methodB()
  c <- methodC(a)
  d <- methodD(b, c)
  _ <- methodE(b,d)
} yield d
```

Где, например, `def methodA(): IO[A] = ???`

Попробуй переделай в map/flatMap и увидишь аналог "callback-hell" (назовем это аналог)

А прочие комбинаторы никуда не убираются а используются в `for`.


### Свиридов Сергей Анатольевич

Проста этого кода - кажущаяся. Сложность проявится при попытке зарефакторить этот код. проблема опять же в "стековости" - последовательность действий не фиксирована чётко.
- Можно переставить местами 1 и 2 шаги, 2 и 3.
- Промежуточные значения не используются в результате.
- Если типы значений совпадают, например, `a` и `d`, то скомпилируется и такой вариант: `methodE(b, a)` т.е. область видимости опасно замусорена лишними идентификаторами.

Переписать можно так:
```scala
    methodB()                      both
    (methodA() flatMap methodC)    mproduct
    methodD.tupled                 map
    { case ((b, c), d) => (b, d) } flatTap
    methodE.tupled                 map
    {_._2}
```
В этом варианте слева находятся ключевые операции, шаги цепочки вычислений, а справа - комбинаторы.

Или можно переписать в более императивном стиле:
```scala
methodB()
    .both(methodA() flatMap methodC)
    .mproduct(methodD.tupled)
    .map{ case ((b, c), d) => (b, d) }
    .flatTap(methodE.tupled)
    .map{_._2}
```
Появились лишние точки и скобочки, но накаждом шаге сразу видно, как он комбинируется с предыдущим.

В том-то и дело! Помимо обычных операций с контейнерами приходится использовать ещё и дополнительный (необязательный!) синтаксис. Т.е. усложняется инструментарий разработки. Причём привносит лишь дополнительные опасности. Вред есть, а польза мнимая (потакание привычкам большинства).


### Яковлев Сергей Владимирович

Ну я даже не знаю как сказать, это же намного сложнее читается и понимается:
```scala
methodB()
    .both(methodA() flatMap methodC)
    .mproduct(methodD.tupled)
    .map{ case ((b, c), d) => (b, d) }
    .flatTap(methodE.tupled)
    .map{_._2}
```
против этого:
```scala
for {
  a <- methodA()
  b <- methodB()
  c <- methodC(a)
  d <- methodD(b, c)
  _ <- methodE(b,d)
} yield d
```
В твоем примере куча операторов дополнительных, которые нужно осмысливать и следить правильно ли все передано, а в for нет операторов, просто вызовы методов и результаты в качестве аргументов потом используются. В итоге читать чужой код насыщенный кучей операторов намного медленнее получится…


### Сивак Даниил Олегович

> проста этого кода - кажущаяся. > сложность проявится при попытке зарефакторить этот код.

По-моему это либо какая-то надуманная проблема ради аргумента, либо не проблема вообще. Я не помню когда у меня из-за "стековости" фора были какие-то затруднения с рефакторингом.

Вот код типа
```scala
    methodB()                      both
    (methodA() flatMap methodC)    mproduct
    methodD.tupled                 map
    { case ((b, c), d) => (b, d) } flatTap
    methodE.tupled                 map
    {_._2}
```
Pарефакторить то конечно намного проще (тут даже сходу непонятно что происходит вообще)))


### Свиридов Сергей Анатольевич

Сперва модный в наше время *disclaimer*.
@Яковлев, твой вариант кода я без комментариев пропускаю на ревью, однако сам бы так не *скорее всего* не написал бы. В данном алгоритме бросается в глаза странная последовательность передачи параметров. Поэтому, какой бы вариант я ни предпочёл, сперва попробовал бы реорганизовать методы – как вызываемые, так и вызывающий.


> Читать чужой код насыщенный кучей операторов намного медленнее получится

Дело не только в “скорости чтения”, сколько в “скорости понимания”. `for` даёт понимание необходимости именно таких действий **не многим больше**, чем в анекдоте про Шерлока Холмса на воздушном шаре. Недопонимания не возникает с бесстековой композицией. Повторюсь, простота `for` – кажущаяся, неполезная.


> Не помню затруднений с рефакторингом из-за "стековости" `for`

При рефакторинге не достаточно поверхностного “лёгкого чтения“. Придётся вникать глубже, разбираться, почему шаги указаны именно в этом порядке и почему передаются именно эти параметры, а не другие… “Стековость” не ограничивает программиста лишь необходимыми действиями, провоцирует труднодиагностируемые ошибки, и в целом “*размывает точность*” алгоритма, которую требуется понять при рефакторинге, чтобы ничего не упустить.

Часто рефакторинг `for` не вызывает сложностей у опытных программистов. Просто обычно `for` устроены проще, чем в примере Сергея. Но в более сложных ситуациях, помимо характерных для `for` косяков, на рефакторинге могут появится ещё и связанные с недостаточным пониманием первоначальной задумки автора, которую `for` просто не способен донести в точности – *`for` не обязывает быть точным*.


> следить, правильно ли все передано

Как раз наоборот, это `for` обязывает программиста постоянно за этим следить. А программист, как известно, машина не очень надёжная. Косячит регулярно. В то время как в бесстековой композиции за этим следит компилятор – он просто не позволит передать “что-то не то”.


> В твоем примере куча операторов дополнительных, которые нужно осмысливать

 В Scala (да и вообще много где) повсеместно используются “вычисления в контейнерах”. Для них характерны возможности **всего трёх видов (!)**:
 - ковариантность (`map`);
 - дистрибутивность (`sequence`, `tupled` и т.п.);
 - “естественные преобразования” (в т.ч. монады и комонады).
Другие операции строятся как частные случаи (`productM`, `tap`, ...) и комбинации вышеперечисленных (`flatMap`, `filter`, …).

В разных фреймворках (и языках) конкретные операции могут называться по-разному. Но когда знаешь, что искать, всегда можно найти наиболее подходящие, и понять код, написанный другими разработчиками. Если же эти три вида возможностей не знакомы Scala-разработчику, то, как говориться, “у меня для вас плохие новости”.


> Тут даже сходу непонятно что происходит вообще))

А я расскажу))


И снова про “простоту и сложность”.

- разводной ключ для винтов.
- анекдот про пурген.
- лишние идентификаторы.

“простота недопонимания”

Оборачивание for в скобки