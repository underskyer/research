
# Предисловие

Я много лет программировал на C# — популярном объектно-ориентированном языке программирования. Изучил ООП-шные паттерны, детально разобрал SOLID и другие принципы разработки. Успешно применял всё это на практике и был вполне доволен собой. Во только не давали покоя вопросы вроде «как развивать навыки программирования дальше?», «это что, предел?», «пора искать более интересную профессию?». Но возращение в науку (теоретическая физика) выглядело для меня совсем уж бесперспективным…

Однажды в телефонном разговоре мой однокашник, который по началу выбрал как раз науку, упомянул, что он теперь программист-фрилансер. Ещё в университете он интересовался функциональным программированием и использовал в научных исследованиях F#, а тут сказал, что для лучшего понимания программирование изучает *теорию категорий*!

Будучи закоренелым ООП-шником, я тогда с большим скепсисом относился к функциональной парадигме, хотя и слышал, что такое крутое нововведение в C#, как Linq, позаимствовано именно оттуда. А про теорию категорий я не знал вообще ничего. Заглянул в Википедию — совсем не впечатлило — подумаешь, какие-то бесполезные стрелочки… В итоге забыл об этом на некоторое время.

Однако, меня зацепила сама идея познакомиться с ФП поближе. Начал, конечно же, с ресурса Скотта Влашина [F# for Fun and Profit](https://fsharpforfunandprofit.com/). Знаю, прозвучит банально, но для меня действительно открылся новый мир! Я буквально прозрел и раздвинул горизонты собственного невежества. «Так вот что это такое — программирование!»

С тех пор для меня всё изменилось. В продуктовом C#-коде я стал регулярно пользоваться техниками функционального программирования. Они действительно оказались проще и выразительные, и к тому же автоматически защищали от некоторых типичных трудноуловимых ошибок, свойственных императивному стилю. И мне действительно стало [стыдно за код, которым я гордился ранее](https://habr.com/ru/articles/505928/#:~:text=%D0%9D%D0%BE%20%D0%B5%D1%81%D1%82%D1%8C%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BE%D0%BA).

Также мне повсеместно стали бросаться в глаза функторы с монадами (`IEnumrable`, `Nullable`, `Task`…), хотя на тот момент я весьма поверхностно представлял себе, что же на самом деле стоит за этими терминами и насколько широки возможности их применения в программировании. Моей целью стало исследовать этот вопрос, найти за слоями «*сложной*» математики тот самый *простой* минимальный базис, на котором основываются все «лучшие практики» программирования.

Сперва я познакомился с основами $\lambda$-исчисления, теории типов и математической логики, а вскоре руки дошли и до пресловутой теории категорий — именно тут и появляются все эти функторы-монады. Основным источником сведений стали публикации Бартоша Милевски, из части которых составлена книга [Category Theory for Programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) (переводы нескольких глав этой книги [опубликованы на Хабре](https://habr.com/ru/articles/305018/)).

Но столько новой информации было очень сложно «разложить по полочкам». Тогда-то и возникла идея оформить все интересные мне сведения в виде серии публикаций для программистов, разделяющих моё стремление к основам. Ведь если у меня получится объяснить материал кому-то ещё, то, возможно, и сам его когда-нибудь пойму!

Среди тем, связанных с применением теории категорий в программировании, выделю две, раскрыть которые было сложнее прочих.
- **Монады не композируются**. Под монадами обычно понимаются обобщённые «контейнерные» типы, предназначенные для удобной и безопасной работы с «эффектами»: недетерминированностю (списки и т.п.), обработкой ошибок, асинхронностью, и многими другими. Так вот утверждается, что не существует *универсального* способа из двух *любых* контейнеров эффектов собрать новый контейнер, обслуживающий *совокупность этих эффектов*. 
- **Альтернативы монадам**. Монады — это вообще «сложно», да и тем более они не композируются)). В интернете можно найти разные заметки о «программировании без монад». Значит, без них и правда можно обойтись? И что же будет взамен?

Такие темы сложно освещать в лоб, без подготовки. Поэтому набросал примерный план изложения материала, рассчитанный на несколько публикаций:

![[темы.drawio.png|Зелёным подсвечены темы, рассмотренные в предыдущих обзорах, а золотым - целевые темы|800]]

Некоторые темы уже были освещены в предыдущих обзорах:
- [Теория типов](https://habr.com/ru/articles/758542/).
- [Обобщённые типы](https://habr.com/ru/articles/807467/).
- [Рекурсивные типы](https://habr.com/ru/articles/863304/).

В данном же обзоре, посвящённом применению теории категорий в программировании, мы сосредоточимся на том, что стремление к повышению качества программ *неизбежно* приводит к абстракциям, которые уже появились в математике при решении другого рода задач («функтор», «монада» и прочие).

Для примеров кода я использую язык программирования Scala. Это весьма компромиссный язык, одной из целей которого является упрощение переучивания программистов с популярных императивных языков на функциональное программирование. Ведь на Scala можно программировать как по старинке, чисто в стиле «better Java», так и в самых продвинутых функциональных стилях. К сожалению, эта вариативность Scala является её же минусом. Синтаксис языка, помимо относительно лёгких «функциональных» возможностей, несёт и громоздкое ООП-шное наследие. Программы, написанные на Scala, работают в объектно-ориентированной среде JRE, да и вообще вся «функциональщина» тут реализована через ООПу. В этом смысле язык Scala оказывается заметно сложнее своих конкурентов.

Тем не менее, считаю, что для демонстрации фундаментальных концепций передовых техник программирования лучше всего подходит именно синтаксис Scala. Даже устаревающий Haskell, с его ML-синтаксисом, близким к $\lambda$-исчислению, зачастую уступает в выразительных возможностях. Да и по популярности среди ФП-языков Scala занимает лидирующие позиции. Поэтому в своих обзорах и использую имеyно его.

В данной публикации будет рассказано о некоторых категориях, наиболее важных для дальнейшего изложения, а также операции, позволяющие из существующих категорий строить новые. Будет продемонстрировано разнообразие категорий, но их полезность проявится лишь в последующих частях обзора, посвящённых переходам (функторам) между различными категориями.

# Категория

## Мотивация

Все задачи программирования сводятся к описанию алгоритма, который последовательно, *шаг за шагом*, *от состояния к состоянию* преобразует начальное условие в конечный результат, удовлетворяющий заданным требованиям. В статически-типизированной программе требования накладываются не только на конечный результат, но и на начальное, и на все промежуточные состояния. Эти требования определяются *типами*, предоставляющими ограниченные *возможностями*, из которых *выбирается конкретный шаг* к следующему состоянию исполнителя.

Визуально это можно представить как направленный граф, узлами которого являются типы, а рёбрами — функции, связывающие эти узлы-типы. Тогда статически типизированная программа представляет собой путь на таком графе от типа, определяющего начальное состояние, к типу, характеризующему конечное.

Диаграмме типов можно построить бесконечное количество путей между двумя выбранными типами — одну и ту же задачу программирования можно решить бесконечным количеством способов. Задача программиста — *выбрать среди эквивалентных путей наилучший*, например, кратчайший.

![[выбор.png|Программисту всего лишь нужно сделать выбор. Каждый раз. Изо дня в день.|800]]

Полный путь определяется количеством отдельных шагов, каждый из которых также является «маленьким путём». Это значит, что нужно уметь строить путь как *композицию* других путей. Построение большого пути из маленьких само по себе *является вычислением*, каждым шагом которого является *комбинирование двух путей в один*. Для каждого типа у нас есть тривиальный путь — функция `identity[A]: A => A`. Кроме того, так как пути являются независимыми и равноправными, комбинировать смежные можно в любом порядке — в итоге получится один и тот же полный путь. Следовательно, операция комбинирования путей обязана быть *ассоциативной*.

Все эти диаграммы типов и функций прекрасным образом укладываются в систему $\lambda^\rightarrow$ — [просто типизированного лямбда-исчисления](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Эта система полная, она позволяет успешно решать все задачи программирования. Однако часто приводит к дублирующемуся коду, что намекает на существование *более базовых абстракций*, которые невозможно описать в рамках $\lambda^\rightarrow$.

Абстракции, сильно упрощающие написание качественных алгоритмов, предоставляются более продвинутыми вариантами лямбда-исчисления. В этих системах появляются такие понятия, как [полиморфные функции и типы](https://habr.com/ru/articles/807467/#polymorphic_types), [зависимые типы](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF). Теперь пути вычислений могут проходить не только через простые, но и через полиморфные типы, а также через отдельные значения! Очевидно, что далеко не все ребра получающегося графа будут обычными функциями.

И тем не менее, задача программиста остаётся прежней — *найти оптимальный путь* от начального условия и конечному состоянию. Но чтобы корректно сформулировать эту задачу, требуется обобщить понятия «шаг» и «состояние». Это и проводит нас к абстракции, известной в математике под названием «категория».

## Определение

Поиск, сравнение и другие операции с путями между точками изучает «топология». Именно там в середине прошлого века зародилась [теория категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9) — *подраздел математики, изучающий свойства отношений между объектами, не зависящие от внутренней структуры объектов*.

> **Категория** — это
> - **объекты**,
> - **морфизмы**-стрелки между объектами, причём,
> 	- для каждого объекта существует единственный **тождественный морфизм** и
> 	- определена операция **композиции** между присоединёнными морфизмами, которая
> 		- **ассоциативна** и
> 		- не меняющая исходный морфизм при композиции с тождественным (с любой стороны) .

Теория категорий разрабатывалась на основе теории множеств. В связи с этим существует классификация категорий на большие и малые (и промежуточные), в зависимости от того, образуют ли объекты и морфизмы множества или нет. В математике такая классификация позволяет избежать [парадокс Кантора](https://ru.wikipedia.org/wiki/Парадокс_Кантора) — аналог [парадокса Рассела](https://ru.wikipedia.org/wiki/Парадокс_Рассела) из теории множеств.

В программировании же мы имеем дело с типами, а *типы изначально не являются множествами значений*. Эти понятия обладают совершенно разной семантикой. Для множеств *постулируется* существование операции проверки принадлежности объекта множеству. В любом же статически типизированном языке программирования каждый терм (литерал, переменная, выражение) *изначально* имеет собственный тип и вопрос о принадлежности значения типу даже не ставится. Привычные программистам проверки возможности *приведения* значения к другому типу также не имеют прямого отношения к теории множеств. Любые операции из теории множеств в реальности суть функции, которые в общем случае является неуникальными и *частично определённым* — не для всех входящих параметров ответ будет получен за конечное время. Говорить о «мощности типа» вообще говоря не корректно, так отношение эквивалентности для значений также не фиксируется однозначно и может быть частично определённой функцией. Даже разные *необитаемые типы не являются эквивалентными*, в отличие от пустых множеств.

В данном обзоре везде, где в теории категорий упоминаются множества, будут употребляться *совокупности значений какого-либо **типа***. Например, здесь будет использоваться следующее определение

> Морфизмы между любыми двумя объектами категории соответствуют совокупности значений **hom-типа**, зависящим от этих самых объектов.

Это не является ~~серьёзным~~ преступлением, ведь так фактически и поступают во всех адаптациях теории категорий к программированию.

Очень важно понимать, что для одной и той же совокупности объектов категории могут отличаться значениями Hom-типа. По сути, именно строгое определение hom-типов и фиксирует категорию — среди их возможных значений-морфизмов должны будут предусмотрены и тождественные, идентифицирующие и все объекты категории. Остаётся только предоставить корректную операцию комбинирования морфизмов, удовлетворяющую законам категориальной композиции.

Можно догадаться, что пути вычисления многих программ пролегают сразу сквозь несколько категорий. Такое путешествие невозможно без так называемой *категории категорий*, о которой мы поговорим в следующий раз. В этой же части будут рассмотрены примеры базовых категорий, востребованных в программировании.

# Примеры категорий

## Категории типов

Самая важная для программирования категория — это такая категория:
- объекты — это типы (внимание! не значения типов, а сами типы!),
- морфизмы — функции между типами (`A => B`),
	- тождественный морфизм — встроенная функция `identity[A]: A => A`,
	- композиция морфизмов — встроенные функции `Function1.compose`, или `Function1.andThen`,
		- которые, естественно, ассоциативные
		- и «уважают» `identity`.

Так или иначе все пути программы начинаются и оканчиваются в этой категории.

```scala
type Hom[A, B] = A => B
  val morphism1: Hom[Double, String] = _.toString  
  val morphism2: Hom[String, Int   ] = _.length  
  
  val morphism3: Hom[Double, Int   ] = morphism1 andThen identity[String] andThen morphism2  
  val morphism4: Hom[Double, Int   ] = morphism2 compose morphism1 compose identity[Double]
  
  // функции morphism3 и morphism4 эквивалентны!
  morphism3(42.0)) // 4  
  morphism4(42.0)) // 4
```

Важно понимать, что используя типы в качестве базы (совокупности объектов), можно построить совершенно разные категории, выбирая другие hom-типы и/или как-то иначе определяя композицию морфизмов. Тут нас выручит универсальный полиморфизм с его «[бесплатными теоремами](https://users.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/wadler89.pdf)» — при построении категорий мы будем целиком полагаться на него.

Реализация *полезной* и «законопослушной» композиции морфизмов произвольных hom-типов может стать весьма сложной задачей. Благо, обычно задача так не ставится. Но для лучшего понимания теории категорий можете, например, попробовать реализовать композицию для морфизмов вида `Hom[A, B] = (A, B)`.



## Дискретная категория

```scala
opaque type Equiv[A] = A | Unit
object Equiv:
  def reflection[A]: Equiv[A] = ()
```

```scala  
type Hom[A, B] = A match
  case B => Equiv[A]
  case _ => Nothing

extension [A] (id: Hom[A, A])
  infix def compose(sameId: Hom[A, A]): Hom[A, A] = id
```

```scala
summon[Hom[Int, String] =:= Nothing            ]
summon[Hom[Int, Int]    =:= Equiv[Int]         ]
summon[Hom[Int, Int]    =:= Hom[String, String]] // ошибка компиляции!

given identity: [A] => Hom[A, A] = Equiv.reflection[A]  
summon[Hom[Int, Int]]  

val sameIdentity = identity[Int] compose identity[Int]  
val ridiculous   = identity[Int] compose identity[String]  // ошибка компиляции!
```

## Тривиальная категория

## Моноид

### Категории значений

Прежде всего, давайте познакомимся с категорией значений какого-то типа, например, `Any`. Каждому 

```scala
type Morph = Any => Any
extension (f: Morph)
  infix def ∘(g: Morph): Morph = x => f(g(x)) // f compose g
```

```scala
type Hom = (Any, Any) => Morph
val hom: Hom = (a, b) =>
  case x if a.equals(x) => b
```

```scala
// тождественные морфизмы
val id = (a: Any) => hom(a, a)

// дополнительные морфизмы
val custom = Array(
  2 -> 4,
  2 -> 42,  // ещё один морфизм из 2!
  4 -> 42,
  4 -> 42, // равен предыдущему, и это нормально!
).map(hom.tupled)
```

```scala
val f = custom(2) ∘ custom(0) ∘ id(2) // 2 -> 42

f(2) // 42
f(3) // MatchError
```

### Категория-синглетон



## Подкатегории типов



```scala
object CatProj:
  type Projections = Obj | Hom
  sealed trait Obj
  sealed trait Hom

type TypeCategory[C[_], hom[_, _]] = [proj <: CatProj.Projections] =>> proj match
  case CatProj.Obj => C
  case CatProj.Hom     => [a, b] =>> TypeMorphism[hom] ?=> hom[C[a], C[b]]

type TypeMorphism[->[a, b]] = (
  id: [a] => () => a -> a,
  compose: [a, b, c] => (b -> c, a -> b) => (a -> c)
)

extension [a, b, ->[_, _]: TypeMorphism as morph](arr: a -> b)
  def ∘[c](prev: c -> a): c -> b = morph.compose(arr, prev)
```


  
```scala
type OptionFunctionCategory = TypeCategory[Option, Function]

given functionMorphism: TypeMorphism[Function] = (
	id = [A] => () => identity[A],
	compose = [a, b, c] => (f: b => c, g: a => b) => f compose g
)
```

```scala
val some42:          OptionFunctionCategory[CatProj.Obj] = Some(42)
val toStringDoubled: OptionFunctionCategory[CatProj.Hom] = _.map(i => i.toString + i.toString)

toStringDoubled(some42)) // Some(4242)
```


```scala
type LogMorphism[A, B] = A => (String, B)
given logMorphism: TypeMorphism[LogMorphism] = (
	id = [A] => () => (a: A) => ("identity", a),
	compose = [a, b, c] => (f: LogMorphism[b, c], g: LogMorphism[a, b]) => (x: a) =>
		val r1 = g(x)
		val r2 = f(r1._2)
		(s"${r1._1} and then ${r2._1}", r2._2)
)

val fo1:      TypeCategory[Option, LogMorphism][CatProj.Hom][Int, String] = "toString" -> _.map("ответ: " + _)
val intLogId: TypeCategory[Option, LogMorphism][CatProj.Hom][Int, Int   ] = summon[TypeMorphism[LogMorphism]].id[Option[Int]]()

println("Option category morphism 2: " + (fo1 ∘ intLogId)(obj)) // Some(4242)

```


# Операции над категориями

## Дуальная (двойственная) категория

## Категориальное произведение

# Промежуточный итог




