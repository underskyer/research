
# Предисловие

Я много лет программировал на C# — популярном объектно-ориентированном языке программирования. Изучил ООП-шные паттерны, детально разобрал SOLID и другие принципы разработки. Успешно применял всё это на практике и был вполне доволен собой. Во только не давали покоя вопросы вроде «как развивать навыки программирования дальше?», «это что, предел?», «пора искать более интересную профессию?». Но возращение в науку (теоретическая физика) выглядело для меня совсем уж бесперспективным…

Однажды в телефонном разговоре мой однокашник, который по началу выбрал как раз науку, упомянул, что он теперь программист-фрилансер. Ещё в университете он интересовался функциональным программированием и использовал в научных исследованиях F#, а тут сказал, что для лучшего понимания программирования изучает *теорию категорий*!

Будучи закоренелым ООП-шником, я тогда с большим скепсисом относился к функциональной парадигме, хотя и слышал, что такое крутое нововведение в C#, как Linq, позаимствовано именно оттуда. А про теорию категорий я не знал вообще ничего. Заглянул в Википедию — совсем не впечатлило — подумаешь, какие-то бесполезные стрелочки! В итоге забыл об этом на некоторое время.

Однако, меня зацепила сама идея познакомиться с ФП поближе. Начал, конечно же, с ресурса Скотта Влашина [F# for Fun and Profit](https://fsharpforfunandprofit.com/)… Знаю, прозвучит банально, но для меня *открылся новый мир*! Я буквально прозрел и раздвинул горизонты собственного невежества. «Так вот что это такое — программирование!»

С того самого момента всё изменилось. В продуктовом C#-коде я стал регулярно пользоваться техниками функционального программирования. Они действительно оказались проще и выразительные, и к тому же автоматически защищали от некоторых типичных трудноуловимых ошибок, свойственных императивному стилю. И мне действительно стало [стыдно за код, которым я гордился ранее](https://habr.com/ru/articles/505928/#:~:text=%D0%9D%D0%BE%20%D0%B5%D1%81%D1%82%D1%8C%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BE%D0%BA).

Также мне повсеместно стали бросаться в глаза функторы с монадами (`IEnumrable`, `Nullable`, `Task`…), хотя на тот момент я весьма поверхностно представлял себе, что же на самом деле стоит за этими терминами и насколько широки возможности их применения. Моей целью стало исследовать этот вопрос, найти за слоями «*сложной*» математики тот самый *простой* минимальный базис, на котором основываются все «лучшие практики» программирования.

Сперва я познакомился с основами $\lambda$-исчисления, теории типов и математической логики, а вскоре руки дошли и до пресловутой теории категорий — именно тут и появляются все эти функторы-монады. Основным источником сведений стали публикации Бартоша Милевски, из части которых составлена книга [Category Theory for Programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) (переводы нескольких глав этой книги [опубликованы на Хабре](https://habr.com/ru/articles/305018/)).

Но столько новой информации было очень сложно «разложить по полочкам». Тогда-то и возникла идея оформить все интересные мне сведения в виде серии публикаций для программистов, разделяющих моё стремление к основам. Ведь если у меня получится объяснить материал кому-то ещё, то, возможно, и сам его когда-нибудь пойму!

Среди тем, связанных с применением теории категорий в программировании, выделю две, раскрыть которые было сложнее прочих.
- **Монады не композируются**. Под монадами обычно понимаются обобщённые «контейнерные» типы, предназначенные для удобной и безопасной работы с «эффектами»: недетерминированностью (списки и т.п.), обработкой ошибок, асинхронностью, и многими другими. Так вот утверждается, что не существует *универсального* способа из двух *любых* контейнеров эффектов собрать новый контейнер, обслуживающий *совокупность этих эффектов*. 
- **Альтернативы монадам**. Монады — это вообще «сложно», да и тем более они не композируются)). В интернете можно найти разные заметки о «программировании без монад». Значит, без них и правда можно обойтись? И что же будет взамен?

Такие темы сложно освещать в лоб, без подготовки. Поэтому был разработан примерный план изложения материала, рассчитанный на несколько публикаций:

![[темы.drawio.png|Зелёным подсвечены темы, рассмотренные в предыдущих обзорах, а золотым - целевые темы|600]]

Некоторые темы уже были освещены в предыдущих обзорах:
- [Теория типов](https://habr.com/ru/articles/758542/).
- [Обобщённые типы](https://habr.com/ru/articles/807467/).
- [Рекурсивные типы](https://habr.com/ru/articles/863304/).

В данном же обзоре, посвящённом применению теории категорий в программировании, мы сосредоточимся на том, что стремление к повышению качества программ *неизбежно* приводит к абстракциям, которые уже появились в математике при решении другого рода задач («функтор», «монада» и прочие).

Для примеров кода я использую язык программирования Scala. Это весьма компромиссный язык, одной из целей которого является упрощение переучивания программистов с популярных императивных языков на функциональное программирование. Ведь на Scala можно программировать как по старинке, чисто в стиле «better Java», так и в самых продвинутых функциональных стилях. К сожалению, эта вариативность Scala является её же минусом. Синтаксис языка, помимо относительно лёгких «функциональных» возможностей, несёт и громоздкое ООП-шное наследие. Программы, написанные на Scala, работают в объектно-ориентированной среде JRE, да и вообще вся «функциональщина» тут реализована через ООПу. В этом смысле язык Scala оказывается заметно сложнее своих конкурентов.

Тем не менее, считаю, что для демонстрации фундаментальных концепций передовых техник программирования лучше всего подходит именно синтаксис Scala. Даже устаревающий Haskell, с его ML-синтаксисом, близким к $\lambda$-исчислению, зачастую уступает в выразительных возможностях. Да и по популярности среди ФП-языков Scala занимает лидирующие позиции. Поэтому в своих обзорах и использую имеyно его.

В данной публикации будет рассказано об основных свойствах категорий, приведены примеры наиболее важных для дальнейшего изложения, а также представлена пара преобразований, позволяющих строить новые категории из существующих. Но сразу предупрежу, что это лишь «скучное введение» — *полезность* представленных здесь сведений раскроится лишь в последующих частях обзора.

# Категория

## Мотивация

Все задачи программирования сводятся к описанию алгоритма, который последовательно, *шаг за шагом*, *от состояния к состоянию* преобразует начальное условие в конечный результат, удовлетворяющий заданным требованиям. В статически-типизированной программе требования накладываются не только на конечный результат, но и на начальное, и на все промежуточные состояния. Эти требования определяются *типами*, предоставляющими ограниченные *возможностями*, из которых *выбирается конкретный шаг* к следующему состоянию исполнителя.

Визуально это можно представить как направленный граф, узлами которого являются типы, а рёбрами — функции, связывающие эти узлы-типы. Тогда статически типизированная программа представляет собой путь на таком графе от типа, определяющего начальное состояние, к типу, характеризующему конечное.

На диаграмме типов можно построить бесконечное количество путей между двумя выбранными точками — одну и ту же задачу программирования можно решить бесконечным количеством способов. Задача программиста — *выбрать среди эквивалентных путей наилучший*, например, кратчайший.

![[выбор.png|Программисту всего лишь нужно сделать выбор. Каждый раз. Изо дня в день.|600]]

Полный путь определяется количеством отдельных шагов, каждый из которых по сути является «маленьким путём». Это значит, что нужно уметь строить новые пути как *композицию* известных путей. Построение большого пути из маленьких само по себе *является вычислением*, каждым шагом которого является *комбинирование двух путей в один*. Для каждого типа у нас есть тривиальный путь — функция `identity[A]: A => A`. Кроме того, так как пути являются независимыми и равноправными, комбинировать смежные можно в любом порядке — в итоге получится один и тот же полный путь. Следовательно, операция комбинирования путей обязана быть *ассоциативной*.

Все эти диаграммы типов и функций прекрасным образом укладываются в систему $\lambda^\rightarrow$ — [просто типизированного лямбда-исчисления](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Эта система полная, она позволяет успешно решать все задачи программирования. Однако часто приводит к дублирующемуся коду, что намекает на существование *более фундаментальных абстракций*, которые невозможно описать в рамках $\lambda^\rightarrow$.

Абстракции, сильно упрощающие написание качественных алгоритмов, предоставляются более продвинутыми вариантами лямбда-исчисления. В этих системах появляются такие понятия, как [полиморфные функции и типы](https://habr.com/ru/articles/807467/#polymorphic_types), [зависимые типы](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF). Теперь пути вычислений могут проходить не только через простые, но и через полиморфные типы, а также через отдельные значения! Очевидно, что далеко не все ребра получающегося графа будут обычными функциями.

И тем не менее, задача программиста остаётся прежней — *найти оптимальный путь* от начального условия и конечному состоянию. Но чтобы корректно сформулировать эту задачу, требуется обобщить понятия «шаг» и «состояние». Это и проводит нас к абстракции, известной в математике под названием «категория».

## Определение

Поиск, сравнение и другие операции с путями между точками изучает «топология». Именно там в середине прошлого века зародилась [теория категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9) — подраздел математики, изучающий *свойства отношений* между объектами, не зависящие от внутренней структуры объектов. Сами же объекты и отношения как раз формируют понятие «категория»:

> **Категория** — это
> - **объекты**,
> - **морфизмы** (отношения, «стрелки») между объектами, причём,
> 	- для каждого объекта существует единственный **тождественный морфизм** и
> 	- определена операция **композиции** между присоединёнными морфизмами, которая
> 		- **ассоциативна** и
> 		- не меняющая исходный морфизм при композиции с тождественным (с любой стороны) .

Теория категорий разрабатывалась на основе теории множеств. В связи с этим существует классификация категорий на большие и малые (и промежуточные), в зависимости от того, образуют ли объекты и морфизмы множества или нет. В математике такая классификация позволяет избежать [парадокс Кантора](https://ru.wikipedia.org/wiki/Парадокс_Кантора) — аналог [парадокса Рассела](https://ru.wikipedia.org/wiki/Парадокс_Рассела) из теории множеств.

В программировании же мы имеем дело с типами, а *типы изначально не являются множествами значений*. Эти понятия обладают совершенно разной семантикой. Для множеств *постулируется* существование операции проверки принадлежности объекта множеству. В любом же статически типизированном языке программирования каждый терм (литерал, переменная, выражение) *изначально* имеет собственный тип и вопрос о принадлежности значения типу даже не ставится. Привычные программистам проверки возможности *приведения* значения к другому типу также не имеют прямого отношения к теории множеств. Любые операции из теории множеств в реальности суть функции, которые в общем случае является неуникальными и *частично определённым* — не для всех входящих параметров ответ будет получен за конечное время. Говорить о «мощности типа» вообще говоря не корректно, так отношение эквивалентности для значений также не фиксируется однозначно и может быть частично определённой функцией. Даже разные *необитаемые типы не являются эквивалентными*, в отличие от пустых множеств.

Поэтому в данном обзоре везде, где в теории категорий упоминаются множества, будут употребляться *совокупности значений какого-либо **типа***. Например, здесь будет использоваться следующее определение

> Морфизмы между любыми двумя объектами категории соответствуют совокупности значений **hom-типа** (в математике — hom-множества), зависящего от этих самых объектов.

Это не является ~~серьёзным~~ преступлением, ведь так фактически и поступают во всех адаптациях теории категорий к программированию.

Очень важно понимать, что для одной и той же совокупности объектов категории могут отличаться значениями hom-типа. По сути, именно строгое определение hom-типов и фиксирует категорию — среди их возможных значений-морфизмов должны будут предусмотрены и тождественные, идентифицирующие и все объекты категории. В итоге, чтобы окончательно определить категорию остаётся предоставить *одну из возможных* корректных операций комбинирования морфизмов, удовлетворяющую законам категориальной композиции.

Можно догадаться, что пути вычисления многих программ пролегают сразу сквозь несколько категорий. Такое путешествие невозможно без так называемой *категории категорий*, но о ней мы поговорим в следующий раз.

# Примеры категорий

## Категории типов

Самая важная для программирования категория состоит из следующих компонентов:
- объекты — это типы (внимание! не значения типов, а сами типы!),
- морфизмы — функции между типами,
	- тождественный морфизм — встроенная функция `identity[A]`,
	- композиция морфизмов — встроенные функции `Function1.compose`, или `Function1.andThen`,
		- которые, естественно, ассоциативные
		- и «уважают» `identity`.

Так или иначе, все пути программы начинаются и оканчиваются в этой категории. Её основные свойства определяются hom-типом `Function1[A, B]` и его встроенными возможностями:
```scala
type Hom[A, B] = A => B

val morphism1: Hom[Double, String] = _.toString  
val morphism2: Hom[String, Int   ] = _.length  
  
val morphism3: Hom[Double, Int   ] = morphism1 andThen identity[String] andThen morphism2  
val morphism4: Hom[Double, Int   ] = morphism2 compose morphism1 compose identity[Double]
  
// функции morphism3 и morphism4 эквивалентны!
morphism3(42.0)) // 4  
morphism4(42.0)) // 4
```

![[пример в категории типов.png|Иллюстрация к коду, где функция `morphism3` строится как композиция трёх функций.|700]]

> **Разница между compose и andThen.** Когда мы описываем последовательность вычислений, то привычнее это делать от начала к концу: «сделаем со значением х первое действие, затем (andThen) второе, затем третье». В математике же сложился альтернативный, «инвертированный» способ описания композиции действий. Композиция функции строится обычно так: `третье(второе(первое(х)))`. При такой записи последнее действие записывается слева, а первое, наоборот, справа. В этом тоже есть свой смысл: «важен в первую очередь *результат* вычисления третьей функции, от результата вычисления второй, от результата первой». Таким образом, акцент переносится с исходных значений на ожидаемый результат! С такой точки зрения и следует трактовать выражения вида `(третье compose второе compose первое)(х)`. В теории категорий, являющейся разделом математики, чаще всего будет встречаться именно такая композиция морфизмов.

В данном примере  функции `morphism3` и `morphism4` хоть и отличаются с точки зрения JRE, но на самом деле являются *эквивалентными*. В случае, когда hom-тип является типом функции, продемонстрировать эквивалентность его значений-морфизмов задача не простая. Честное доказательство потребовало бы перебрать *все различные* значения исходного типа-объекта и убедиться, что в каждом случае значения результатов совпадают. Очевидно, это возможно далеко не всегда, поэтому эквивалентность данных путей предлагаю принять на веру)).
	
## Дискретная категория

Важным и одним из самых распространённых вариантов категорий являются дискретные категории, в которых определены лишь тождественные морфизмы. По сути такие морфизмы являются свидетельством *рефлексивности отношения эквивалентности* объектов. В качестве типичных примеров дискретных категорий часто приводят множества.

Определим следующий тип, который ввиду единственного конструктора будет синглетоном для каждого `A`:
```scala
opaque type Equiv[A] = A | Unit
object Equiv:
  def reflection[A]: Equiv[A] = ()
```

![[дискретная категория.png|Дискретная категория: каждому объекту — по морфизму!|600]]

Тогда на базе типов можно построить дискретную категорию, определив следующим образом hom-тип, тождественный морфизм и их композицию:
```scala  
type Hom[A, B] = A match
  case B => Equiv[A]
  case _ => Nothing

extension [A] (id: Hom[A, A])
  infix def compose(sameId: Hom[A, A]): Hom[A, A] = id

def identity[A]: Hom[A, A] = Equiv.reflection[A]
```

Такой hom-тип будет обитаем лишь для одинаковых типов-объектов, и композировать можно лишь одинаковые тождественные морфизмы, получая по сути эквивалентные:
```scala
summon[Hom[Int, String] =:= Nothing            ]
summon[Hom[Int, Int]    =:= Equiv[Int]         ]
summon[Hom[Int, Int]    =:= Hom[String, String]] // ошибка компиляции!

val sameIdentity = identity[Int] compose identity[Int]  
val ridiculous   = identity[Int] compose identity[String] // ошибка компиляции!
```

Аналогичным образом можно было бы определить дискретную категорию значений, определив hom-тип как-нибудь так:
```scala
sealed trait Hom(a: Any, b: Any):
  infix def compose(other: Hom): Hom = if this == other then this else ???
final case class identity(o: Any) extends Hom(o, o)
```
Отличие от категорий типов будет заключаться в том, что законы категориальной композиции будут проверяться уже во время исполнения:
```scala
val f = identity(42)
val g = f compose f

assert(f == g)           // проверка времени исполнения
f compose identity("42") // выбросит исключение!
```

Впрочем, в этом обзоре больше внимания уделено категориям типов, потому что именно статическая типизация помогает обеспечивать качество программ.


## Моноид

Есть особая разновидность категорий, основанных на единственном объекте. Такие категории называются *моноидами* (лат. «mono» — «один»). Вся информация о моноиде содержится в её морфизмах и законах их композиции. Рассмотрим два примера.

Так как объект к моноида всего один, то hom-тип вообще не нужно параметризировать. Да и в принципе объект не имеет смысла конкретизировать! Выберем такой hom-тип:
```scala
type Hom = Int
```
Да, это не тип функции, но если вас не смутили предыдущие примеры с `Equiv[A]` и `case class identity`, то и целочисленный hom-тип уже не должен удивлять)). В прочем, сам по себе hom-тип мало полезен. Чтобы определить категорию, нужно предоставить тривиальные морфизмы и «законопослушную» функцию композиции. А сделать это можно разными способами даже с одним и тем же hom-типом.

![[категория - моноид.png|Моноид, морфизмы которого индексированы целыми числами.|600]]

Композицию `Int`-морфизмов можно реализовать как посредством сложения
```scala
extension (f: Hom)
  infix def compose(g: Hom): Hom = f + g
val identity: Hom = 0
  
val f: Hom = 20
val g: Hom = 22
val h: Hom = f compose identity compose g // 42
```
так и через умножение
```scala
extension (f: Hom)
  infix def compose(g: Hom): Hom = f * g
val identity: Hom = 1
  
val f: Hom = 7
val g: Hom = 6
val h: Hom = f compose identity compose g // 42
```

Эти примеры демонстрируют, что даже на одних и тех же объектах и морфизмах могут существовать *разные* категории, если у них отличаются хотя бы *способы композиции* морфизмов.

Самой простой, но очень полезной разновидностью моноида, являются *тривиальная категория*, содержащая лишь единственный морфизм: 
```scala
object identity
type Hom = identity.type
extension (f: Hom)
  infix def compose(g: Hom): Hom = f
  
assert(identity compose identity eq identity)
```

Тривиальная категория на первый взгляд выглядит самой бесполезной, но она ещё пригодится в дальнейшем для формулировании типов через их универсальные свойства.

## Подкатегории типов

В программировании часто встречаются категории, объектами которых считаются типы `F[A]`, для некого конструктора типов `F[_]`, морфизмы — обычные функции между ними:
```scala
type Hom[F[+_]] = [A <: F[Any], B <: F[Any]] =>> A => B
```

Все объекты и морфизмы таких категорий являются также объектами и морфизмами обычной категории типов, рассмотренной ранее. Таким образом, каждый конструктор типов образует свою *подкатегорию типов*:

![[Подкатегория типов.png|800]]

Однако, такой hom-тип крайне неудобно использовать. Проще считать, что объектами такой подкатегории являются *все типы*, как и у исходной, а вот морфизмы ограничены лишь функциями такого вида:
```scala
type HomF[F[_]] = [A, B] =>> F[A] => F[B]
```

Новая категория на самом деле *изоморфна* предыдущей — их морфизмы взаимно-однозначно соответствуют друг другу. Впрочем, изоморфизм категорий мы рассмотрим в другой раз.

Чтобы лучше понять идею **под**категории, полезно посмотреть на примеры hom-типов, которые не относятся к этому определение:
```scala
type IntMonoid = [A, B] =>> Int 
type Trivial   = [A, B] =>> Unit
```

Эти hom-типы никак не пересекаются с функции `A => B`, который описывает морфизмы исходной категории типов.

С помощью `HomF` несложно получить исходную категорию:
```scala
type Id = [A] =>> A
type Hom = HomF[Id] // [A, B] =>> A => B
```


### Бесплатные теоремы

Используя типы в качестве базы (совокупности объектов), можно построить совершенно разные категории, выбирая другие hom-типы и/или как-то иначе определяя композицию морфизмов. Тут нас выручит [универсальный полиморфизм](https://habr.com/ru/articles/807467/#polymorphic_types) с его «[бесплатными теоремами](https://users.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/wadler89.pdf)» — при построении категорий мы будем целиком полагаться на него. Далее мы рассмотрим некоторые категории с другими hom-типами.


Основной целю обзора является изучение свойств контейнерных обобщённых типов `F[A]`,  в частности, функциональных отношений их значений. Очевидно, что каждый конструктор типов `F[_]` образует собственную категорию, объектами которой будут все типы, также как и в рассмотренной ранее категории типов. Морфизмы новой категории — это функции со стандартным способом их композиции, а значит, все они также являются морфизмами исходной категории. Но с другой стороны, морфизмы `A => B` не будут относиться к новой категории, если типы `A` и `B` не имеют вид `F[Something]`. Всё это позволяет утверждать, что категория, порождённая конструктором типов `F[_]` является *подкатегорией* категории типов, рассмотренной ранее.

Чтобы собрать воедино все свойства категорий, представленные ранее, выразим категории для `F[_]` в виде типа. Вот как это может выглядеть:
```scala
sealed trait Obj
sealed trait Morph

type TypeCategory[C[_], Hom[_, _]] = [proj <: Obj | Morph] =>> proj match
  case Obj   => C
  case Morph => [A, b] =>> Hom[C[A], C[B]]

type TypeMorphism[->[a, b]] = (
  identity: [A]       => () => A -> A,
  compose : [A, B, C] => (B -> C, A -> B) => (A -> C)
)

extension [A, B, ->[_, _]: TypeMorphism as morph](arrow: A -> B)
  inline infix def ∘[C](prevArrow: C -> A): C -> B = morph.compose(arrow, prevArrow)
  
inline def identity[->[_, _]: TypeMorphism as morph, A] = morph.identity[A]()
```

> **Scala так умеет!** Если еще не заметили, обратите внимание на *виды* типов, возвращаемых при сопоставлении с разными шаблонами в определении типа `TypeCategory`. Если мы передадим в качестве параметра `Obj`, то получим тип вида `* -> *`, а если `Morph`, то `(*, *) -> *`. Такое поведение является одной из разновидностей *полиморфизма видов* (kind polymorphism), который уже упоминался в [одном из предыдущих обзоров](https://habr.com/ru/articles/807467/#kind_polymorphism). Удивительно, что и компилятор, и среды разработки уже позволяют это использовать!

Тип `TypeCategory` несёт в себе информацию и об объектах `C[A]`, и о морфизмах `Hom[C[a], C[b]]`. Для морфизмов должны быть определены композиция и тривиальный морфизм — это организуется с помощью класса типов `TypeMorphism[_[_, _]]`. Тождественный морфизм `identity` описан как функция из `()` из-за ограничений Scala, не разрешающих использовать полиморфные значения. Также добавлена щепотка синтаксического сахара — инфиксный оператор композиции морфизмов `∘` и удобная функция `identity`. Не хватает только законов композиции, но в этом обзоре мы не будем рассказывать о законах.

Теперь чтобы определить новую категорию, достаточно указать конструктор типов, hom-тип и предоставить реализацию класса типов `TypeMorphism`:
```scala
type OptFuncCat = TypeCategory[Option, Function]

given functionMorphism: TypeMorphism[Function] = (
  id      = [A]       => () => identity[A],
  compose = [A, B, C] => (f: B => C, g: A => B) => f compose g
)
```
Типы-объекты и типы-морфизмы можно использовать так:
```scala
val some42:          OptFuncCat[Obj  ][Int]         = Some(42)
val toStringDoubled: OptFuncCat[Morph][Int, String] = _.map(i => i.toString + i.toString)

(toStringDoubled ∘ identity)(some42) // Some(4242)
```
Пока не обращайте внимание на использование `Option.map`)). Об этом поговорим в следующей части обзора.

Для сравнения, вот определение чуть более сложной категории, основанной на том же `Option[_]`:
```scala
type LogMorphism = [A, B] =>> A => (String, B)
type OptLogCat = TypeCategory[Option, LogMorphism]
type OptLogHom = OptLogCat[Morph]

given logOptMorphism: TypeMorphism[OptLogHom] = (
  identity = [A] => () => (a: Option[A]) => ("сохраняем", a),
  compose  = [A, B, C] => (f: OptLogHom[B, C], g: OptLogHom[A, B]) => (x: Option[A]) =>
    val r1 = g(x)
    val r2 = f(r1._2)
    (s"${r1._1} затем ${r2._1}", r2._2)
)
```

Такой hom-тип с механизмом композиции позволяет автоматически журналировать все преобразования в контейнере:
```scala
val negotiate: OptLogHom[Int, Int   ] = "обращаем" -> _.map(-_)
val getAnswer: OptLogHom[Int, String] = "в строку" -> _.map("строка: " + _)
  
(getAnswer ∘ negotiate)(some42) // (обращаем затем в строку,Some(строка: -42))
```
Кстати, в этом примере используется переменная `some42` типа-объекта из предыдущей категории. Просто ещё одна демонстрация того, что объекты двух *разных* категорий могут совпадать.

Впрочем, в дальнейшем нам скорее всего не понадобятся категории типов с hom-типами, отличными от `A => F[B]`.
```scala
type Hom[F[_]] = [A, B] =>> F[A] => F[B]

given functionMorphism: [F[_]] => TypeMorphism[Hom[F]] = (
  id      = [A]       => () => identity[F[A]],
  compose = [A, B, C] => (f: F[B] => F[C], g: F[A] => F[B]) => f compose g
)
```

```scala
```




# Операции над категориями

## Дуальная (двойственная) категория

Одним из параметров типа `TypeCategory`, введённого выше, является hom-тип `->`,параметризированный, в свою очередь, парой простых типов. Порядок в этой паре параметров влияет лишь на направление композиции морфизмов. Очевидно, что на основе любой категории, можно на тех же объектах автоматически сформулировать другую, в которой все морфизмы изменят направление на противоположное. Такая категория называется *двойственно*й или *дуальной*. В математике категория, дуальная $\mathcal{C}$ обозначается как $\mathcal{C}^{op}$ (от «opposite» — «противоположный»).

К сожалению, компилятор Scala пока не позволяет сразу преобразовать любой конкретный `TypeCategory` в двойственный ему. Но можно развернуть любой hom-тип и предоставить для него экземпляр класса типов `TypeMorphism`:
```scala
type Revert[->[_, _]] = [A, B] =>> B -> A

def opMorphism[->[_, _] : TypeMorphism as morph]: TypeMorphism[Revert[->]] = (
  identity = [A]       => () => morph.identity[A](),
  compose  = [A, B, C] => (f: Revert[->][B, C], g: Revert[->][A, B]) => morph.compose(g, f)
)
```
Тривиальный морфизм остался неизменным, но в композиции поменялся порядок морфизмов `(f, g)` на `(g, f)`.

Таким образом можно получить двойственную категорию:
```scala
type OptionOpCategory = TypeCategory[Option, Revert[Function]]
type OptOpHom = OptionOpCategory[Morph]

val getAnswer: OptOpHom[String, Int] = _.map("ответ: " + _): Option[String]  
val twice:     OptOpHom[Int,    Int] = _.map(_ * 2): Option[Int]  
val composed:  OptOpHom[String, Int] = optOpMorph.compose(twice, getAnswer)

composed(Some(21)) // Some(ответ: 42)
```
К сожалению, механизм вывода типов Scala не позволил записать композицию более элегантно. Но обратите внимание — при вызове `compose` функции указаны в противоположном порядке, чем это было бы в исходной категории.

Опять же, при рассмотрении сферической категории в вакууме такие нюансы не имеют значения. Однако, это будет важно в следующей части обзора, когда мы будем рассматривать взаимодействие дуальной категории с исходной.


## Категориальное произведение

Есть ещё один просто способ получать новые категории из существующих — это *произведение категорий*. Рассмотрим, например, такие обобщённые типы:
```scala
infix type + = [A, B] =>>  A Either B  
infix type × = [A, B] =>> (A   ,    B)  
```
Они являются отображением *пары* типов в тип. Так вот пары типов также можно рассматривать как объекты новой категории! Морфизмами тогда будут, пары морфизмов исходных категорий. Соответственно, hom-тип произведения категорий будет произведением (кортежем) исходных hom-типов. Давайте сразу посмотрим на более общий случай, полученный по аналогии с категориями типов выше:
```scala  
type Bimorph[HomC[_, _], HomD[_, _]] = [C1, C2, D1, D2] =>> (HomC[C1, C2], HomD[D1, D2])

type Prod[C[_], D[_], HomC[_, _], HomD[_, _]] =
  [proj <: Obj | Morph] =>> proj match
    case Obj   => [F[_, _]] =>> [c, d] =>> F[C[c], D[d]]
    case Morph => [C1, C2, D1, D2]     =>> Bimorph[HomC, HomD][C[C1], C[C2], D[D1], D[D2]]

type TypeBimorphism[biMorph[_, _, _, _]] = (
  identity: [A, B] => () => biMorph[A, A, B, B],
  compose : [A1, A2, B1, B2, C1, C2] => (biMorph[B1, C1, B2, C2], biMorph[A1, B1, A2, B2]) => biMorph[A1, C1, A2, C2]
)

def biMorphism[HomC[_, _] : TypeMorphism as morphC, HomD[_, _] : TypeMorphism as morphD]: TypeBimorphism[Bimorph[HomC, HomD]] = (
  identity = [C, D] => () => (morphC.identity[C](), morphD.identity[D]()),
  compose = [A1, A2, B1, B2, C1, C2] => (f: Bimorph[HomC, HomD][B1, C1, B2, C2], g: Bimorph[HomC, HomD][A1, B1, A2, B2]) =>
    (morphC.compose(f._1, g._1), morphD.compose(f._2, g._2))
)
```

Тип `Bimorph` определяет hom-тип для произведения категорий, как произведение hom-типов. В свою очередь, `Prod` — собственно произведение категорий. Обратите внимание, что раз объектами являются пары типов, то использовать их можно, лишь предоставив свой конструктор типов `F: (*, *) => *`. Также требуется новый класс типов `TypeBimorphism` для единичного морфизма и композиции — обе эти возможности параметризированы вдвое большим количеством типов-параметров, чем в предыдущих примерах.

Вот пример построения произведения композиции простых подкатегорий типов (морфизмы — обычные функции), основанных на конструкторах `List` и `Option`:
```scala
type ProdIdOptCategory = Prod[List, Option, Function, Function]

summon[ProdIdOptCategory[Obj][Either][Int, Boolean] =:= Either[List[Int], Option[Boolean]]]

val f: ProdIdOptCategory[Morph][Int, Int, Double, String] = (_.map(_ + 100       ), _.map(_.toString))
val g: ProdIdOptCategory[Morph][Int, String, String, Int] = (_.map("строка: " + _), _.map(_.length  ))
val h: ProdIdOptCategory[Morph][Int, String, Double, Int] = biMorphism.compose(g, f)

h._1(List(4, 2)) // List(строка: 104, строка: 102)
h._2(Some(4.2))  // Some(3)
```

«Призыв» доказательства эквивалентности типов демонстрирует способ работы с объектами категориального произведения — здесь для использования пары типов предоставлен двухпараметрический конструктор типов `Either`. Пары же морфизмов композируются стандартным способом.

# Промежуточный итог

Большинство примеров наверняка показались банальными. Но, тут уж ничего не поделаешь — прежде чем двигаться дальше, сперва нужно познакомить читателя с самой концепцией категории.

«Переусложнённые» типы использовались в первую очередь для выражения математических концепций на языке программирования. Надеюсь, что такой альтернативный окажется немного ближе читателю-программисту.

Вот некоторые идеи, которые я надеялся донести в этой части обзора:
- пути вычислений могут пролегать не только через типы, но и в совершенно других категориях;
- тем не менее, если ограничиться только типами, вычисления между ними могут строиться из морфизмов, которые являются не только функциями;
- но даже фиксировав морфизмы, варьируя способы их комбинирования мы получим совершенно разные категории, а значит и отличающиеся пути вычислений в них!

В продолжении обзора мы будем иметь дело по большей части с «простыми» подкатегориями типов (основанных на конкретных конструкторах типов и функциях-морфизмах), но встретятся и другие введённые здесь категории. Также, несомненно, понадобятся дуальная категория и категориальное произведение.

Следующая часть посвящена путям *между категориями*, строить которые нам помогут новые морфизмы — функторы.