
# Предисловие

Я много лет программировал на C# — популярном объектно-ориентированном языке программирования. Изучил ООП-шные паттерны, детально разобрал SOLID и другие принципы разработки. Успешно применял всё это на практике и был вполне доволен собой. Во только не давали покоя вопросы вроде «как развивать навыки программирования дальше?», «это что, предел?», «пора искать более интересную профессию?». Но возращение в науку (теоретическая физика) выглядело для меня совсем уж бесперспективным…

Однажды в телефонном разговоре мой однокашник, который по началу выбрал как раз науку, упомянул, что он теперь программист-фрилансер. Ещё в университете он интересовался функциональным программированием и использовал в научных исследованиях F#, а тут сказал, что для лучшего понимания программирование изучает *теорию категорий*!

Будучи закоренелым ООП-шником, я тогда с большим скепсисом относился к функциональной парадигме, хотя и слышал, что такое крутое нововведение в C#, как Linq, позаимствовано именно оттуда. А про теорию категорий я не знал вообще ничего. Заглянул в Википедию — совсем не впечатлило — подумаешь, какие-то бесполезные стрелочки… В итоге забыл об этом на некоторое время.

Однако, меня зацепила сама идея познакомиться с ФП поближе. Начал, конечно же, с ресурса Скотта Влашина [F# for Fun and Profit](https://fsharpforfunandprofit.com/). Знаю, прозвучит банально, но для меня действительно открылся новый мир! Я буквально прозрел и раздвинул горизонты собственного невежества. «Так вот что это такое — программирование!»

С тех пор для меня всё изменилось. В продуктовом C#-коде я стал регулярно пользоваться техниками функционального программирования. Они действительно оказались проще и выразительные, и к тому же автоматически защищали от некоторых типичных трудноуловимых ошибок, свойственных императивному стилю. И мне действительно стало [стыдно за код, которым я гордился ранее](https://habr.com/ru/articles/505928/#:~:text=%D0%9D%D0%BE%20%D0%B5%D1%81%D1%82%D1%8C%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BE%D0%BA).

Также мне повсеместно стали бросаться в глаза функторы с монадами (`IEnumrable`, `Nullable`, `Task`…), хотя на тот момент я весьма поверхностно представлял себе, что же на самом деле стоит за этими терминами и насколько широки возможности их применения в программировании. Моей целью стало исследовать этот вопрос, найти за слоями «*сложной*» математики тот самый *простой* минимальный базис, на котором основываются все «лучшие практики» программирования.

Сперва я познакомился с основами $\lambda$-исчисления, теории типов и математической логики, а вскоре руки дошли и до пресловутой теории категорий — именно тут и появляются все эти функторы-монады. Основным источником сведений стали публикации Бартоша Милевски, из части которых составлена книга [Category Theory for Programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) (переводы нескольких глав этой книги [опубликованы на Хабре](https://habr.com/ru/articles/305018/)).

Но столько новой информации было очень сложно «разложить по полочкам». Тогда-то и возникла идея оформить все интересные мне сведения в виде серии публикаций для программистов, разделяющих моё стремление к основам. Ведь если у меня получится объяснить материал кому-то ещё, то, возможно, и сам его когда-нибудь пойму!

Среди тем, связанных с применением теории категорий в программировании, выделю две, раскрыть которые было сложнее прочих.
- **Монады не композируются**. Под монадами обычно понимаются обобщённые «контейнерные» типы, предназначенные для удобной и безопасной работы с «эффектами»: недетерминированностю (списки и т.п.), обработкой ошибок, асинхронностью, и многими другими. Так вот утверждается, что не существует *универсального* способа из двух *любых* контейнеров эффектов собрать новый контейнер, обслуживающий *совокупность этих эффектов*. 
- **Альтернативы монадам**. Монады — это вообще «сложно», да и тем более они не композируются)). В интернете можно найти разные заметки о «программировании без монад». Значит, без них и правда можно обойтись? И что же будет взамен?

Такие темы сложно освещать в лоб, без подготовки. Поэтому был разработан примерный план изложения материала, рассчитанный на несколько публикаций:

![[темы.drawio.png|Зелёным подсвечены темы, рассмотренные в предыдущих обзорах, а золотым - целевые темы|600]]

Некоторые темы уже были освещены в предыдущих обзорах:
- [Теория типов](https://habr.com/ru/articles/758542/).
- [Обобщённые типы](https://habr.com/ru/articles/807467/).
- [Рекурсивные типы](https://habr.com/ru/articles/863304/).

В данном же обзоре, посвящённом применению теории категорий в программировании, мы сосредоточимся на том, что стремление к повышению качества программ *неизбежно* приводит к абстракциям, которые уже появились в математике при решении другого рода задач («функтор», «монада» и прочие).

Для примеров кода я использую язык программирования Scala. Это весьма компромиссный язык, одной из целей которого является упрощение переучивания программистов с популярных императивных языков на функциональное программирование. Ведь на Scala можно программировать как по старинке, чисто в стиле «better Java», так и в самых продвинутых функциональных стилях. К сожалению, эта вариативность Scala является её же минусом. Синтаксис языка, помимо относительно лёгких «функциональных» возможностей, несёт и громоздкое ООП-шное наследие. Программы, написанные на Scala, работают в объектно-ориентированной среде JRE, да и вообще вся «функциональщина» тут реализована через ООПу. В этом смысле язык Scala оказывается заметно сложнее своих конкурентов.

Тем не менее, считаю, что для демонстрации фундаментальных концепций передовых техник программирования лучше всего подходит именно синтаксис Scala. Даже устаревающий Haskell, с его ML-синтаксисом, близким к $\lambda$-исчислению, зачастую уступает в выразительных возможностях. Да и по популярности среди ФП-языков Scala занимает лидирующие позиции. Поэтому в своих обзорах и использую имеyно его.

В данной публикации будет рассказано о некоторых категориях, наиболее важных для дальнейшего изложения, а также операции, позволяющие из существующих категорий строить новые. Будет продемонстрировано разнообразие категорий, но их полезность проявится лишь в последующих частях обзора, посвящённых переходам (функторам) между различными категориями.

# Категория

## Мотивация

Все задачи программирования сводятся к описанию алгоритма, который последовательно, *шаг за шагом*, *от состояния к состоянию* преобразует начальное условие в конечный результат, удовлетворяющий заданным требованиям. В статически-типизированной программе требования накладываются не только на конечный результат, но и на начальное, и на все промежуточные состояния. Эти требования определяются *типами*, предоставляющими ограниченные *возможностями*, из которых *выбирается конкретный шаг* к следующему состоянию исполнителя.

Визуально это можно представить как направленный граф, узлами которого являются типы, а рёбрами — функции, связывающие эти узлы-типы. Тогда статически типизированная программа представляет собой путь на таком графе от типа, определяющего начальное состояние, к типу, характеризующему конечное.

Диаграмме типов можно построить бесконечное количество путей между двумя выбранными типами — одну и ту же задачу программирования можно решить бесконечным количеством способов. Задача программиста — *выбрать среди эквивалентных путей наилучший*, например, кратчайший.

![[выбор.png|Программисту всего лишь нужно сделать выбор. Каждый раз. Изо дня в день.|600]]

Полный путь определяется количеством отдельных шагов, каждый из которых также является «маленьким путём». Это значит, что нужно уметь строить путь как *композицию* других путей. Построение большого пути из маленьких само по себе *является вычислением*, каждым шагом которого является *комбинирование двух путей в один*. Для каждого типа у нас есть тривиальный путь — функция `identity[A]: A => A`. Кроме того, так как пути являются независимыми и равноправными, комбинировать смежные можно в любом порядке — в итоге получится один и тот же полный путь. Следовательно, операция комбинирования путей обязана быть *ассоциативной*.

Все эти диаграммы типов и функций прекрасным образом укладываются в систему $\lambda^\rightarrow$ — [просто типизированного лямбда-исчисления](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Эта система полная, она позволяет успешно решать все задачи программирования. Однако часто приводит к дублирующемуся коду, что намекает на существование *более базовых абстракций*, которые невозможно описать в рамках $\lambda^\rightarrow$.

Абстракции, сильно упрощающие написание качественных алгоритмов, предоставляются более продвинутыми вариантами лямбда-исчисления. В этих системах появляются такие понятия, как [полиморфные функции и типы](https://habr.com/ru/articles/807467/#polymorphic_types), [зависимые типы](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF). Теперь пути вычислений могут проходить не только через простые, но и через полиморфные типы, а также через отдельные значения! Очевидно, что далеко не все ребра получающегося графа будут обычными функциями.

И тем не менее, задача программиста остаётся прежней — *найти оптимальный путь* от начального условия и конечному состоянию. Но чтобы корректно сформулировать эту задачу, требуется обобщить понятия «шаг» и «состояние». Это и проводит нас к абстракции, известной в математике под названием «категория».

## Определение

Поиск, сравнение и другие операции с путями между точками изучает «топология». Именно там в середине прошлого века зародилась [теория категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9) — *подраздел математики, изучающий свойства отношений между объектами, не зависящие от внутренней структуры объектов*.

> **Категория** — это
> - **объекты**,
> - **морфизмы**-стрелки между объектами, причём,
> 	- для каждого объекта существует единственный **тождественный морфизм** и
> 	- определена операция **композиции** между присоединёнными морфизмами, которая
> 		- **ассоциативна** и
> 		- не меняющая исходный морфизм при композиции с тождественным (с любой стороны) .

Теория категорий разрабатывалась на основе теории множеств. В связи с этим существует классификация категорий на большие и малые (и промежуточные), в зависимости от того, образуют ли объекты и морфизмы множества или нет. В математике такая классификация позволяет избежать [парадокс Кантора](https://ru.wikipedia.org/wiki/Парадокс_Кантора) — аналог [парадокса Рассела](https://ru.wikipedia.org/wiki/Парадокс_Рассела) из теории множеств.

В программировании же мы имеем дело с типами, а *типы изначально не являются множествами значений*. Эти понятия обладают совершенно разной семантикой. Для множеств *постулируется* существование операции проверки принадлежности объекта множеству. В любом же статически типизированном языке программирования каждый терм (литерал, переменная, выражение) *изначально* имеет собственный тип и вопрос о принадлежности значения типу даже не ставится. Привычные программистам проверки возможности *приведения* значения к другому типу также не имеют прямого отношения к теории множеств. Любые операции из теории множеств в реальности суть функции, которые в общем случае является неуникальными и *частично определённым* — не для всех входящих параметров ответ будет получен за конечное время. Говорить о «мощности типа» вообще говоря не корректно, так отношение эквивалентности для значений также не фиксируется однозначно и может быть частично определённой функцией. Даже разные *необитаемые типы не являются эквивалентными*, в отличие от пустых множеств.

В данном обзоре везде, где в теории категорий упоминаются множества, будут употребляться *совокупности значений какого-либо **типа***. Например, здесь будет использоваться следующее определение

> Морфизмы между любыми двумя объектами категории соответствуют совокупности значений **hom-типа**, зависящим от этих самых объектов.

Это не является ~~серьёзным~~ преступлением, ведь так фактически и поступают во всех адаптациях теории категорий к программированию.

Очень важно понимать, что для одной и той же совокупности объектов категории могут отличаться значениями Hom-типа. По сути, именно строгое определение hom-типов и фиксирует категорию — среди их возможных значений-морфизмов должны будут предусмотрены и тождественные, идентифицирующие и все объекты категории. Остаётся только предоставить корректную операцию комбинирования морфизмов, удовлетворяющую законам категориальной композиции.

Можно догадаться, что пути вычисления многих программ пролегают сразу сквозь несколько категорий. Такое путешествие невозможно без так называемой *категории категорий*, о которой мы поговорим в следующий раз. В этой же части будут рассмотрены примеры базовых категорий, востребованных в программировании.

# Примеры категорий

## Категории типов

Самая важная для программирования категория состоит из следующих компонент:
- объекты — это типы (внимание! не значения типов, а сами типы!),
- морфизмы — функции между типами,
	- тождественный морфизм — встроенная функция `identity[A]`,
	- композиция морфизмов — встроенные функции `Function1.compose`, или `Function1.andThen`,
		- которые, естественно, ассоциативные
		- и «уважают» `identity`.

Так или иначе все пути программы начинаются и оканчиваются в этой категории. Её основные свойства определяются hom-типом `Function1[A, B]` и его встроенными возможностями:
```scala
type Hom[A, B] = A => B

val morphism1: Hom[Double, String] = _.toString  
val morphism2: Hom[String, Int   ] = _.length  
  
val morphism3: Hom[Double, Int   ] = morphism1 andThen identity[String] andThen morphism2  
val morphism4: Hom[Double, Int   ] = morphism2 compose morphism1 compose identity[Double]
  
// функции morphism3 и morphism4 эквивалентны!
morphism3(42.0)) // 4  
morphism4(42.0)) // 4
```

![[пример в категории типов.png|700]]

В данном примере морфизмы `morphism3` и `morphism4` хоть и отличаются с точки зрения JRE, но на самом деле являются *эквивалентными* функциями. В случае, когда hom-тип является типом функции, продемонстрировать эквивалентность его значений-морфизмов задача не простая. Честное доказательство потребовало бы перебрать *все различные* значения исходного типа-объекта и убедиться, что в каждом случае значения результатов совпадают. Очевидно, это возможно далеко не всегда, поэтому эквивалентность данных путей предлагаю принять на веру)).

Нужно понимать, что используя типы в качестве базы (совокупности объектов), можно построить совершенно разные категории, выбирая другие hom-типы и/или как-то иначе определяя композицию морфизмов. Тут нас выручит [универсальный полиморфизм](https://habr.com/ru/articles/807467/#polymorphic_types) с его «[бесплатными теоремами](https://users.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/wadler89.pdf)» — при построении категорий мы будем целиком полагаться на него. Далее мы рассмотрим некоторые категории с другими hom-типами.

## Дискретная категория

Важным и одним из самых распространённых вариантов категорий являются дискретные категории, в которых определены лишь тождественные морфизмы. По сути такие морфизмы являются свидетельством *рефлексивности отношения эквивалентности* объектов. В качестве типичных примеров дискретных категорий часто приводят множества.

Определим следующий тип, который ввиду единственного конструктора будет синглетоном для каждого `A`:
```scala
opaque type Equiv[A] = A | Unit
object Equiv:
  def reflection[A]: Equiv[A] = ()
```

![[дискретная категория.png|Дискретная категория: каждому объекту — по морфизму!|600]]

Тогда на базе типов можно построить дискретную категорию, определив следующим образом hom-тип, тождественный морфизм и их композицию:
```scala  
type Hom[A, B] = A match
  case B => Equiv[A]
  case _ => Nothing

extension [A] (id: Hom[A, A])
  infix def compose(sameId: Hom[A, A]): Hom[A, A] = id

def identity[A]: Hom[A, A] = Equiv.reflection[A]
```

Такой hom-тип будет обитаем лишь для одинаковых типов-объектов, и композировать можно лишь одинаковые тождественные морфизмы, получая по сути эквивалентные:
```scala
summon[Hom[Int, String] =:= Nothing            ]
summon[Hom[Int, Int]    =:= Equiv[Int]         ]
summon[Hom[Int, Int]    =:= Hom[String, String]] // ошибка компиляции!

val sameIdentity = identity[Int] compose identity[Int]  
val ridiculous   = identity[Int] compose identity[String] // ошибка компиляции!
```

Аналогичным образом можно было бы определить дискретную категорию значений, определив hom-тип как-нибудь так:
```scala
sealed trait Hom(a: Any, b: Any):
  infix def compose(other: Hom): Hom = if this == other then this else ???
final case class identity(o: Any) extends Hom(o, o)
```
Отличие от категорий типов будет заключаться в том, что законы категориальной композиции будут проверяться уже во время исполнения:
```scala
val f = identity(42)
val g = f compose f

assert(f == g)           // проверка времени исполнения
f compose identity("42") // выбросит исключение!
```

Впрочем, в этом обзоре бы сделаем акцент именно на категориях типов, потому что статическая типизация помогает обеспечивать качество программ.


## Моноид

Есть особая разновидность категорий, у основанных на единственном объекте. Такие категории называются *моноидами* (лат. «mono» — «один»). Вся информация о моноиде содержится в её морфизмах и законах их композиции. Рассмотрим два примера.

Так как объект к моноида всего один, то hom-тип вообще не нужно параметризировать. Да и в принципе объект не имеет смысла конкретизировать! Выберем такой hom-тип:
```scala
type Hom = Int
```
Да, это не тип функции, но если вас не смутили предыдущие примеры с `Equiv[A]` и `case class identity`, то и целочисленный hom-тип уже не должен удивлять)). В прочем, сам по себе hom-тип мало полезен. Чтобы определить категорию, нужно предоставить тривиальные морфизмы и «законопослушную» функцию композиции. А сделать это можно разными способами даже с одним и тем же hom-типом.

![[категория - моноид.png|Моноид, морфизмы которого индексированы целыми числами.|600]]

Композицию `Int`-морфизмов можно реализовать как посредством сложения
```scala
extension (f: Hom)
  infix def compose(g: Hom): Hom = f + g
val identity: Hom = 0
  
val f: Hom = 20
val g: Hom = 22
val h: Hom = f compose identity compose g // 42
```
так и через умножение
```scala
extension (f: Hom)
  infix def compose(g: Hom): Hom = f * g
val identity: Hom = 1
  
val f: Hom = 7
val g: Hom = 6
val h: Hom = f compose identity compose g // 42
```

Эти примеры демонстрируют, что даже на одних и тех же объектах и морфизмах могут существовать *разные* категории, если у них отличаются хотя бы *способы композиции* морфизмов.

Самой простой, но очень полезной разновидностью моноида, являются *тривиальная категория*, содержащая лишь единственный морфизм: 
```scala
object identity
type Hom = identity.type
extension (f: Hom)
  infix def compose(g: Hom): Hom = f
  
assert(identity compose identity eq identity)
```

Тривиальная категория на первый взгляд выглядит самой бесполезной, но она ещё пригодится в последующих частях обзора при формулировании типов через их универсальные свойства.

## Подкатегории типов

Основной целю обзора является изучение свойств контейнерных обобщённых типов `F[A]`,  в частности, функциональных отношений их значений. Очевидно, что каждый конструктор типов `F[_]` образует собственную категорию, объектами которой будут все типы, также как и в рассмотренной ранее категории типов. Все морфизмы новой категории суть функции со стандартным способом их композиции, а значит, что все они также являются морфизмами исходной категории. Но с другой стороны, морфизмы `A => B` не будут относиться к новой категории, если типы `A` и `B` не имеют вид `F[Something]`.

Всё это позволяет утверждать, что категория, порождённая конструктором типов `F[_]` является *подкатегорией* категории типов, рассмотренной ранее. Возможно, это опять покажется банальностью)), но, поверьте, в следующих частях обзора такое отношение между категориями очень пригодится.

![[Подкатегория типов.png|Все объекты и морфизмы подкатегории принадлежат также и родительской категории.|600]]

Чтобы собрать воедино все свойства категорий, представленные ранее, выразим категории для `F[_]` в виде типа. Вот как это может выглядеть:
```scala
sealed trait Obj
sealed trait Morph

type TypeCategory[C[_], Hom[_, _]] = [proj <: Obj | Morph] =>> proj match
  case Obj   => C
  case Morph => [a, b] =>> Hom[C[a], C[b]]

type TypeMorphism[->[a, b]] = (
  identity: [a]       => () => a -> a,
  compose : [a, b, c] => (b -> c, a -> b) => (a -> c)
)

extension [a, b, ->[_, _]: TypeMorphism as morph](arrow: a -> b)
  inline infix def ∘[c](prevArrow: c -> a): c -> b = morph.compose(arrow, prevArrow)
inline def identity[->[_, _], A](using morph: TypeMorphism[->]) = morph.identity[A]()
```

> **Scala так умеет!** Если еще не заметили, обратите внимание на *виды* типов, возвращаемых при сопоставлении с разными шаблонами в определении типа `TypeCategory`. Если мы передадим в качестве параметра `Obj`, то получим тип вида `* -> *`, а если `Morph`, то `(*, *) -> *`. Такое поведение является одной из разновидностей *полиморфизма видов* (kind polymorphism), который уже упоминался в [одном из предыдущих обзоров](https://habr.com/ru/articles/807467/#kind_polymorphism). Удивительно, что и компилятор, и среды разработки уже умеют позволяют это использовать!

Тип `TypeCategory` несёт в себе информацию и об объектах `C[A]` и о морфизмах `Hom[C[a], C[b]]`. Для морфизмов должны быть определены композиция и тривиальный морфизм — это организуется с помощью класса типов `TypeMorphism[_[_, _]]`. Тождественный морфизм `identity` описан как функция из `()` из-за ограничений Scala, не разрешающих использовать полиморфные значения. Также добавлена щепотка синтаксического сахара — инфиксный оператор композиции морфизмов `∘` и удобная функция `identity`. Не хватает только законов композиции, но в этом обзоре мы не будем рассказывать о законах.

Теперь чтобы определить новую категорию, достаточно указать конструктор типов, hom-тип и предоставить реализацию класса типов `TypeMorphism`:
```scala
type OptFuncCat = TypeCategory[Option, Function]

given functionMorphism: TypeMorphism[Function] = (
  id      = [A]       => () => identity[A],
  compose = [a, b, c] => (f: b => c, g: a => b) => f compose g
)
```
Типы-объекты и типы-морфизмы можно использовать так:
```scala
val some42:          OptFuncCat[Obj  ][Int]         = Some(42)
val toStringDoubled: OptFuncCat[Morph][Int, String] = _.map(i => i.toString + i.toString)

(toStringDoubled ∘ identity)(some42) // Some(4242)
```
Пока не обращайте внимание на использование `Option.map`)). Об этом поговорим в следующей части обзора.

Для сравнения, вот определение чуть более сложной категории, основанной на том же `Option[_]`:
```scala
type LogMorphism = [A, B] =>> A => (String, B)
type OptLogCat = TypeCategory[Option, LogMorphism]
type OptLogHom = OptLogCat[Morph]

given logOptMorphism: TypeMorphism[OptLogHom] = (
  identity = [A] => () => (a: Option[A]) => ("сохраняем", a),
  compose  = [a, b, c] => (f: OptLogHom[b, c], g: OptLogHom[a, b]) => (x: Option[a]) =>
    val r1 = g(x)
    val r2 = f(r1._2)
    (s"${r1._1} затем ${r2._1}", r2._2)
)
```

Такой hom-тип с механизмом композиции позволяет автоматически журналировать все преобразования в контейнере:
```scala
val negotiate: OptLogHom[Int, Int   ] = "обращаем" -> _.map(-_)
val getAnswer: OptLogHom[Int, String] = "в строку" -> _.map("строка: " + _)
  
(getAnswer ∘ negotiate)(some42) // (обращаем затем в строку,Some(строка: -42))
```
Кстати, в этом примере используется переменная `some42` типа-объекта из предыдущей категории. Просто ещё одна демонстрация того, что объекты двух *разных* категорий могут совпадать.

# Операции над категориями

## Дуальная (двойственная) категория

```scala
type Revert[->[_, _]] = [A, B] =>> B -> A

def opMorphism[->[_, _] : TypeMorphism as morph]: TypeMorphism[Revert[->]] = (
  identity = [A] => () => morph.identity[A](),
  compose = [A, B, C] => (f: Revert[->][B, C], g: Revert[->][A, B]) => morph.compose(g, f)
)
  
type OptionOpCategory = TypeCategory[Option, Revert[Function]]
type OptOpHom = OptionOpCategory[Morph]
```


## Категориальное произведение

# Промежуточный итог




