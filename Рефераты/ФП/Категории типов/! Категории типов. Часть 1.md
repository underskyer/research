
# Введение

Есть не мало популярных публикаций, знакомящих программистов с теорией категорий. Пожалуй, самой объемлющей работой является книга Бартоша Милевски [Category Theory for Programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/). Переводы нескольких глав этой книги даже [опубликованы на Хабре](https://habr.com/ru/articles/305018/).

Большинство таких работ достаточно «математичны» — в них сперва объявляется какая-то абстракция, а затем (и то не всегда) демонстрируется её польза в приложении к программированию. А чего в них практически невозможно найти, так это *вывод **необходимости** этих самых абстракций как самых оптимальных инструментов для решения реальных задач* (программирования).

Данный же обзор не претендует на освещение математических тонкостей теории категорий. Он задуман для демонстрации того, что стремление к повышению качества программ *неизбежно* приводит к абстракциям, *уже известным в теории категорий* («категория», «функтор», «монада» и прочие).

Вот небольшой анонс некоторых проблем, которые мы попробуем разрешить.
- Из теории типов мы имеем [минимальный ряд конструкторов типов](https://habr.com/ru/articles/758542/#types): сумма, произведение и экспоненциал типов, а также единичный и нулевой типы. Все типы (в том числе, и примитивные, вроде `Int`), что могут предложить различные языки программирования, по сути являются комбинацией этих конструкторов. Почему доступны только такие варианты, ответ даёт теория категорий. Тут конструкторы типов формулируются через их [универсальные свойства](https://ru.wikipedia.org/wiki/%D0%A3%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE) — «для любого типа существует единственная функция, делающая диаграмму коммутативной», что-то в этом духе. С непривычки звучит мудрёно, но разобравшись на примерах, многие вполне удовлетворяются таким ответом. Проблема тут в том, что такие определения через универсальные свойства **неконструктивны** — они не дают понимания, **как вывести тип с требуемыми свойствами**. И что вообще значит «вывести тип»?
- В функциональном программировании принято обрабатывать побочные эффекты с помощью «[контейнерных типов](https://habr.com/ru/articles/807495/)», повсеместно называемых «функторами» и «монадами». Эти слова заимствованы из теории категорий, которая «сложная», поэтому периодически встречаются упоминания каких-то «**альтернатив монадам**». Полезно разобраться, что это за альтернативы, и можно ли на самом деле как-то «избавиться от сложных монад».
- Кто уже знаком с монадами в программировании, наверняка слышал, что «**монады не композируются**». В качестве доказательств обычно приводятся какие-то весьма мутные и совершенно не убедительные примеры. Хотелось бы разобраться, на сколько справедливо такое утверждение.

Конечно же, речь пойдёт о статически-типизированном функциональном программировании. Именно оно предлагает наилучшие инструменты для написания надёжных программ, простых и безопасных для дальнейших модификаций. В настоящее время это уже не является какой-то экзотикой. Элементы функционального программирования повсеместно вводятся в популярные объектно-ориентированные языки и различные паттерны и «лучше практики» потихоньку переписываются под их использование.

Для примеров кода здесь будет использоваться язык Scala. Это, пожалуй, самый компромиссный язык, одной из целью которого является упрощение переучивания программистов с популярных Java-подобных языков на функциональное программирование. На Scala можно программировать как по старинке, чисто в стиле «better Java», так и в самых продвинутых функциональных стилях.

К сожалению, эта особенyость Scala является её же минусом. Синтаксис языка, помимо относительно лёгких «функциональных» возможностей, несёт и более громоздкое ООП-шное наследие. Программы, написанные на Scala, работают в объектно-ориентированной среде JVM, да и вообще вся «функциональщина» тут реализована через ООПу. В последних версиях языка есть очень крутые возможности, отсутствующие даже в Haskell, но всё же многие из них имеют мелкие досадные недоработки. Но, несмотря на моё рефлексирование по поводу любимого языка, на мой взгляд, именно синтаксис Scala лучше всего подходит для демонстрации применения элементов теории категорий в программировании!))

Этот обзор является продолжением цикла публикаций по теории типов. Другие обзоры цикла можно найти здесь:
- [Теория типов](https://habr.com/ru/articles/758542/).
- [Обобщённые типы](https://habr.com/ru/articles/807467/).
- [Рекурсивные типы](https://habr.com/ru/articles/863304/).

Предыдущие обзоры, даже будучи разбитыми на части, публиковались сразу, когда были закончены полностью. В этот раз решено публиковать части по-отдельности, по мере их готовности. В данной части будет рассмотрено само понятие «*категория*»:
- покажем, почему можно захотеть такую абстракцию и из чего она состоит;
- рассмотрим некоторые примеры категорий:
	- категории значений с морфизмами-*парами*,
	- категория типов и её подкатегории с морфизмами-*функциями*,
	- категория категорий с морфизмами-*функторами*,
	- категория функторов, морфизмы которой называются «*естественные преобразования*»;
- операции над категориями — *произведения* и *дуальные* категории;
- категория *профункторов*, морфизмы которой называются «*диестественные преобразования*».


# Категория

## Мотивация

Все задачи программирования сводятся к описанию алгоритма, которые последовательно, *шаг за шагом*, *от состояния к состоянию* преобразует начальное условие в конечный результат, удовлетворяющий заданным требованиям. В статически-типизированной программе требования накладываются не только на конечный результат, но и на начальное, и на все промежуточные состояния. Эти требования определяются *типами*, предоставляющими ограниченные *возможностями*, из которых *выбирается конкретный шаг* к следующему состоянию исполнителя.

Визуально это можно представить как направленный граф, узлами которого являются типы, а рёбрами — функции, связывающие эти узлы-типы. Тогда статически типизированная программа представляет собой путь на таком графе от типа, определяющего начальное состояние, к типу, характеризующему конечное.

> Если некоторые типы состояний программы оказываются совпадающими, то такая программа является *слабо-типизированной*. Это может приводить к ошибкам, которые и компилятор не обнаружит, и даже воспроизвести их будет сложно. Лучший способ защититься от подобных ошибок — типы состояний делать уникальными и, в частности, не использовать [примитивные типы](https://habr.com/ru/articles/882862/#primitives).
> Совпадающие типы состояний мешают представить алгоритм в виде графа, но это никак не ограничивают применение теории категорий в программировании. Дело в том, что, вообще визуализировать категориальные диаграммы с помощью «честных графов» получается далеко не всегда.

Таким образом, оптимизация алгоритма сводится к поиску *кратчайших путей* на таком графе, а наилучшее описание алгоритма — к выбору среди *эквивалентных путей*.

Длина пути определяется количеством отдельных шагов, каждый из которых также является «маленьким путём». Это значит, что нужно уметь строить путь как *композицию* других путей. Построение большого пути из маленьких само по себе *является вычислением*, каждым шагом которого является *комбинирование двух путей в один*.

Так как сами по себе пути являются независимыми и равноправными, комбинировать их можно в любом порядке — в итоге получится один и тот же полный путь. Следовательно, операция комбинирования путей обязана быть *ассоциативной*.

Но типы быть *изоморфны* друг другу, как, например, `Either[Int, Int] ≅ Boolean => Int`. То есть, мы без потери информации можем преобразовать значения от одного типа к другому, чтобы получить нужные нам возможности. Это значит, что между такими типами есть пара функций, действующих навстречу друг другу, обе композиции которых *не меняют значения* соответствующего типа. Эти композиции оказываются эквивалентны так называемой *тождественной* функции: `def ident(a: A): A = a`, где `A` — любой из этих типов. Таким образом, мы можем рассуждать об изоморфизме типов *не изучая их значения*, но сравнивая композицию морфизмов с тождественной.

Типы отличаются лишь [своим положением на диаграмме типов](https://habr.com/ru/articles/758542/#types). Не важно, как тип называется, но важно, какие функции приводят в него, или исходят из него. Только функции определяют систему типов и возможные шаги для построения пути вычислений.

Все эти диаграммы типов и функций прекрасным образом укладываются в систему $\lambda^\rightarrow$ — [просто типизированного лямбда-исчисления](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Эта система полная, она позволяет успешно решать все задачи программирования. Однако часто приводит к дублирующемуся коду, что намекает на существование *более базовых абстракций*, которые невозможно описать в рамках $\lambda^\rightarrow$.

Абстракции, сильно упрощающие написание качественных алгоритмов, предоставляются более продвинутыми вариантами лямбда-исчисления. В этих системах появляются такие понятия, как [полиморфные функции и типы](https://habr.com/ru/articles/807467/#polymorphic_types), [зависимые типы](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF). Теперь пути вычислений проходят не только через простые, но и через полиморфные типы, и даже через значения. Далеко не все ребра получающегося графа будут обычными функциями.

И тем не менее, задача программиста остаётся прежней — *найти оптимальный путь* от начального условия и конечному состоянию. Но, чтобы корректно сформулировать эту задачу, требуется обобщить понятия «шаг» и «состояние». Это и проводит нас к абстракции, известной в математике под названием «категория».

## Определение и свойства

Поиском, сравнением и другими операциями с путями между точками занимается раздел математики под названием «топология». Именно там и зародилась в середине прошлого века [теория категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9) — *раздел математики, изучающий свойства отношений между объектами, не зависящие от внутренней структуры объектов*.

Упрощённо говоря,
> Категория — это
> - *объекты*,
> - *морфизмы*-стрелки между объектами, среди которых для каждого объекта задан *тождественный морфизм*,
> - *ассоциативная* операция *композиции* морфизмов.

Теория категорий разрабатывалась на основе теории множеств. В связи с этим существует классификация категорий на большие и малые (и промежуточные), в зависимости от того, образуют ли множества объекты и морфизмы. Такая классификация необходима, в частности, при работе с *категорией категорий* (см. далее) для устранения [парадокса Кантора](https://ru.wikipedia.org/wiki/Парадокс_Кантора) — аналога [парадокса Рассела](https://ru.wikipedia.org/wiki/Парадокс_Рассела) из теории множеств.

В программировании же мы имеем дело с типами, а *типы не являются множествами значений*. Эти понятия обладают совершенно разной семантикой. Для множеств *постулируется* существование операции проверки принадлежности объекта множеству. В любом же статически типизированном языке программирования каждый терм (литерал, переменная, выражение) *изначально* имеет собственный тип и вопрос о принадлежности значения типу даже не ставится (проверка возможности *приведения* значения к другому типу — это отдельный вопрос). Сравнение на эквивалентность двух разных типов определяется алгоритмом, который является *частично определённым* — не для всех типов ответ будет получен за конечное время. Говорить о «мощности типа» вообще говоря не корректно, так отношение эквивалентности для значений не фиксируется однозначно и также в общем случае является частично определённой функцией. Даже разные *необитаемые типы вовсе не являются эквивалентными*, в отличие от пустых множеств.

В данном обзоре везде, где в теории категорий упоминаются множества, будут употребляться *совокупности значений каких-либо типов*. Например, когда говорят, что «для малых категорий морфизмы между любыми двумя объектами образуют так называемое Hom-множество» («Hom» записано латиницей), здесь будет говориться о значениях Hom-типа. Это не является ~~серьёзным~~ преступлением, ведь так фактически и поступают во всех адаптациях теории категорий к программированию (просто некорректно ассоциируют типы с множествами).

Очень важно понимать, что для одной и той же совокупности объектов категории могут отличаться значениями Hom-типа. По сути, именно строгое определение Hom-типа и определяет категорию — в типе буде указано, какие используются объекты, и среди значений обязательно должны быть предусмотрены тождественные морфизмы. Остаётся только предоставить ассоциативную операцию комбинирования морфизмов, удовлетворяющую также законам тождественного морфизма (эти законы очень важны, но мы не будем углубляться в предоставление их доказательств).

Далее будут рассмотрены примеры категорий, наиболее востребованные в программировании.

# Категории типов

## Подкатегории типов


# Категории значений

Прежде всего, давайте познакомимся с категорией значений какого-то типа, например, `Any`. Каждому 

```scala
type Morph = Any => Any
extension (f: Morph)
  infix def ∘(g: Morph): Morph = x => f(g(x)) // f compose g
```

```scala
type Hom = (Any, Any) => Morph
val hom: Hom = (a, b) =>
  case x if a.equals(x) => b
```

```scala
// тождественные морфизмы
val id = (a: Any) => hom(a, a)

// дополнительные морфизмы
val custom = Array(
  2 -> 4,
  2 -> 42,  // ещё один морфизм из 2!
  4 -> 42,
  4 -> 42, // равен предыдущему, и это нормально!
).map(hom.tupled)
```

```scala
val f = custom(2) ∘ custom(0) ∘ id(2) // 2 -> 42

f(2) // 42
f(3) // MatchError
```
## Категория функций

# Операции над категориями

## Двойственная (дуальная) категория

## Категориальное произведение






