
Это вторая вводная часть обзора, посвящённого применению теории категорий в программировании. В первой части представлены некоторые основные определения теории, в том числе, hom-типы, их значения-морфизмы, а также их композиция, позволяющая строить пути вычислений в рамках одной категории. В данной же публикации мы рассмотрим, как *пути вычислений можно прокладывать через разные категории*. Фокус заключается в том, что все категории, которые представлены в этом обзоре, вместе образуют ещё одну категорию, которая называется

# Категория категорий

Да, всё так и есть! Ну, почти.

Строго говоря, математики обычно говорят о категории всех [малых (или локально малых) категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9#%D0%9C%D0%B0%D0%BB%D0%B0%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F). Подобного рода ограничения требуются для того, чтобы избежать аналога [парадокса Кантора](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%9A%D0%B0%D0%BD%D1%82%D0%BE%D1%80%D0%B0#:~:text=%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%CC%81%D0%BA%D1%81%20%D0%9A%D0%B0%CC%81%D0%BD%D1%82%D0%BE%D1%80%D0%B0%20%E2%80%94%20%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81%20%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2,%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%BE%D0%B9%20%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0%20%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE.), который получается с *категорией всех категорий*, обязанной включать саму себя.

Впрочем, нам, простым программистам, не нужно забивать голову такими нюансами)). Дело в том, что на практике мы оперируем лишь инструментами конструктивной математикой, которые просто не позволяют получить такого рода парадоксы. Например, если в качестве объектов использовать подкатегории F-типов, то правильнее говорить, что мы получим *категории типов высокого рода*. Объекты такой категории будут индексированы всеми однопараметрическими конструкторами типов `F[_]` ($F: \star \rightarrow \star$).

Но гораздо важнее то, какие *морфизмы* будут нам полезны в подобных категориях. То есть нужно выяснить, каким будет hom-тип, а также единичный морфизм и композиция: 
```scala
type Hom[F[_], G[_]]

type Category[Hom[_[_], _[_]]] = ( // ((* => *, * => *) => *) => **
	identity: [F[_]]             => ()                     => Hom[F, F],
	compose : [F[_], G[_], H[_]] => (Hom[G, H], Hom[F, G]) => Hom[F, H]
)
```

Конечно, мы всегда можем пойти проверенным путём и выбрать, например, константные hom-типы, получая моноиды и проч., как мы это делали в первой части обзора. Однако, категория категорий существенно богаче, и мы получим гораздо больше интересных возможностей, если в качестве морфизмов выберем

# Функторы

Контейнерные типы `F[_]` используются в функциональном программировании для «чистого» (то бишь безопасного) обслуживания различных эффектов, в том числе и побочных. Поэтому часто встречаются задачи по «переключению эффекта» — переносу вычислений из одного одного контейнера в другой:

$$
\begin{split}
F[A] &\Rightarrow& \;F[B] &\Rightarrow& \;F[C] &\Rightarrow& \;F[D]\\
\\
&&& \hspace{1mm} \Downarrow\\
\\
G[A] &\Rightarrow& \;G[B] &\Rightarrow& \;G[C] &\Rightarrow& \;G[D]
\end{split}
$$

Такая стрелка (вниз) должна работать единообразно, *универсально* для всех путей вычислений, проходящих через любые объекты-типы. Это значит, что *каждой* функции `F[A] => F[B]` ставится в соответствие `G[A] => G[B]`, притом должна сохраняться ассоциативная композиция и свойства тождественного морфизма `identity`. Вся диаграмма типов и функций без изменений должна переноситься из подкатегории F-типов в подкатегорию G-типов. 

Впрочем, такое отображение вовсе не гарантирует взаимную однозначность — вполне допустимо, что *разные* `f, g: F[A] => F[B]` могут превратиться в одну и ту же `h: G[A] => G[B]`. Также возможно, что `G[A] =:= G[B]` для двух разных `A` и `B`. Важно лишь то, что отображение сохранит законы композиции морфизмов из исходной подкатегории типов.

Очевидно, что все такие «вертикальные» стрелки между разными подкатегориями типов можно будет композировать друг с другом, причём, эта композиция будет ассоциативной, и удовлетворяющей свойствам тождественного морфизма, переводящую любую категорию в неё же (т.е. ничего не делает). Значит эти стрелки вполне можно считать морфизмами в категории подкатегорий типов. Морфизмы с такими свойствами называются **функторами**.

Вот более общее определение:
>Функтор — это такой морфизм в категории категорий, который каждому морфизму из одной категории ставит в соответствие морфизм из другой категории, сохраняя при этом тождественный морфизм и композицию.

### !!! Диаграмма для функтора

Во многих источниках можно встретить чуть расширенное определение функтора, включающее обязательное *сопоставление* объектов начальной категории с объектами конечной. У [Маклейна](https://www.google.com/search?q=%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8+%D0%B4%D0%BB%D1%8F+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%89%D0%B5%D0%B3%D0%BE+%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0) такое «сопоставление» даже называется «функцией», что может ввести в заблуждение. На самом деле в нашем случае речь идёт *не об обычных функциях*, действующих на значениях, но на конструкторах типов, которые на основе одного типа известной структуры конструируют другой тип. Кроме того, у того же Маклейна приводится и эквивалентное упрощённое определение функтора, аналогичное данному выше. Функтор просто переводит морфизмы одной категории в морфизмы другой, сохраняя все законы морфизмов!

Для произвольных категорий типов hom-тип функтора будет таким:
```scala
type Hom[Hom1[_, _], Hom2[_, _]] = [A, B] => Hom1[A, B] => Hom2[A, B]
```
В отличие от hom-типа категории типов, здесь мы получаем *полиморфную* функцию. Именно функцию, а не какой-то другой тип — в этом заключается особенность функтора на фоне прочих морфизмов в категории категорий. Значения этого типа буквально переводят значения-морфизмы первой категории в морфизмы второй.

В случае же подкатегорий типов, индексированных конструкторами типов, приходим к сигнатуре, упомянутой ранее:
```scala
type Hom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[A] => G[B])
```

Определим метод расширения для функций в подкатегории F-типов:
```scala
extension [F[_], A, B](fab: F[A] => F[B])
  def fmap[G[_]](using functor: Hom[F, G]): G[A] => G[B] =
	  functor(fab)
```
Название метода `fmap` происходит от «function mapping» — отображение функций. Вот пример использования этого метода: 
```scala
given functorOptLst: Hom[Option, List] =
	[A, B] => (fOpt: Option[A] => Option[B]) => (listA: List[A]) =>
		fOpt(listA.headOption).map(_ +: functorOptLst(fOpt)(listA.tail)).toList.flatten
		//                     ↑↑↑                да, я читер)))                ↑↑↑↑↑↑↑

val fOpt: Option[Int] => Option[String] = _.map("строка " + _) // почему бы и нет?..
val gLst: List  [Int] => List  [String] = fopt.fmap[List]

gLst(List(40, 2)) // List(строка 40, строка 2)
```

Сигнатуры таких hom-типа и функции `fmap` отличаются от того, что обычно называют функтором в программировании. Это сделано нарочно, чтобы продемонстрировать саму концепцию функтора. Привычные же формулировки мы получим позже.


### Бесплатные теоремы

Используя типы в качестве базы (совокупности объектов), можно построить совершенно разные категории, выбирая другие hom-типы и/или как-то иначе определяя композицию морфизмов. Тут нас выручит [универсальный полиморфизм](https://habr.com/ru/articles/807467/#polymorphic_types) с его «[бесплатными теоремами](https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/) ([Филипп Вадлер](https://users.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/wadler89.pdf))» — при построении категорий мы будем целиком полагаться на него. Далее мы рассмотрим некоторые категории с другими hom-типами.

## Контравариантные функторы

### Вариантность

> Латинская приставка «co-» часто переводится на русский язык как (внезапно!) «со-». Например «**ко**оператив» — это по сути «**со**вместная деятельность». В теории категорий многие термины имеют такую приставку потому, что отражают *дуальность* соответствующих понятий. Это означает, что с такими понятиями непременно **со**седствует аналогичное, полученное путём обращения всех морфизмов, участвующих в определении. Примеры: копроизведение, копредел, коконец и т.п.
> Но есть и исключения из этого правила. Например, двойственную категорию часто снабжают приставкой «op» от «oposite» — противоположный. (Видимо, англоязычной аудитории не понравилось, как звучит слово «cocategory». Впрочем, «коконцы» совсем не парят русскоговорящих)))
> А вот для вариантности функторов смысл приставки «ко-» хоть и сохраняет основную идею, но несёт немного дургую семантику. **Ко**вариантный функтор преобразует морфизмы **со**направленно `(A => B) => (F[A] => F[B])`, в то время как **контра**вариантный меняет направление морфизмов на **встречное** `(A => B) => (F[B] => F[A])`.

### Функторы для инвариантных конструкторов типов

### Функтор из категории типов в категорию категорий

```scala
type Hom[A, F[_]]
type Hom[F[_], A]
```

# Бифункторы

## Профункторы

# Категория функторов

## 2-категория



## Естественные преобразования


## Эдофункторы

