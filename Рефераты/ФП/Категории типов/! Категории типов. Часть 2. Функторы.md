
Это вторая вводная часть обзора, посвящённого применению теории категорий в программировании. В первой части представлены некоторые основные определения теории, в том числе, hom-типы, их значения-морфизмы, а также их композиция, позволяющая строить пути вычислений в рамках одной категории. В данной же публикации мы рассмотрим, как *пути вычислений можно прокладывать через разные категории*. Фокус заключается в том, что все категории, которые представлены в этом обзоре, вместе образуют ещё одну категорию, которая называется

# Категория категорий

Да, всё так и есть! Ну, почти.

Строго говоря, математики обычно говорят о категории всех [малых (или локально малых) категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9#%D0%9C%D0%B0%D0%BB%D0%B0%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F). Подобного рода ограничения требуются для того, чтобы избежать аналога [парадокса Кантора](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%9A%D0%B0%D0%BD%D1%82%D0%BE%D1%80%D0%B0#:~:text=%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%CC%81%D0%BA%D1%81%20%D0%9A%D0%B0%CC%81%D0%BD%D1%82%D0%BE%D1%80%D0%B0%20%E2%80%94%20%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81%20%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2,%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%BE%D0%B9%20%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0%20%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE.), который получается с *категорией всех категорий*, обязанной включать саму себя.

Впрочем, нам, простым программистам, не нужно забивать голову такими нюансами)). Дело в том, что на практике мы имеем дело лишь с конструктивной математикой, средствами которой просто не возможно получить такого рода парадоксы. Например, если в качестве объектов использовать подкатегории F-типов, то правильнее говорить, что мы получим *категории типов высокого рода*. Объекты такой категории будут индексированы всеми однопараметрическими конструкторами типов `F[_]` ($F: \star \rightarrow \star$).

Но гораздо важнее то, какие *морфизмы* будут нам полезны в подобных категориях. То есть нужно выяснить, каким будет hom-тип, а также единичный морфизм и композиция: 
```scala
type Hom[F[_], G[_]]

type Category[Hom[_[_], _[_]]] = ( // ((* => *, * => *) => *) => **
	identity: [F[_]]             => ()                     => Hom[F, F]
	compose : [F[_], G[_], H[_]] => (Hom[G, H], Hom[F, G]) => Hom[F, H]
)
```

Конечно, мы всегда можем пойти проверенным путём и выбрать, например, константные hom-типы, получая моноиды и проч., как мы это делали в первой части обзора. Однако, категория категорий существенно богаче, и мы получим гораздо больше интересных возможностей, выбрав в качестве морфизмов

# Функторы

В функциональном программировании контейнерные типы `F[_]` используются для «чистого» обслуживания различных эффектов, в том числе и побочных. Поэтому часто встречаются задачи по «переключению эффекта» — переносу вычислений из одного одного контейнера в другой:

$$
\begin{split}
F[A] &\Rightarrow& \;F[B] &\Rightarrow& \;F[C] &\Rightarrow& \;F[D]\\
\\
&&& \hspace{1mm} \Downarrow\\
\\
G[A] &\Rightarrow& \;G[B] &\Rightarrow& \;G[C] &\Rightarrow& \;G[D]
\end{split}
$$


### Бесплатные теоремы

Используя типы в качестве базы (совокупности объектов), можно построить совершенно разные категории, выбирая другие hom-типы и/или как-то иначе определяя композицию морфизмов. Тут нас выручит [универсальный полиморфизм](https://habr.com/ru/articles/807467/#polymorphic_types) с его «[бесплатными теоремами](https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/) ([Филипп Вадлер](https://users.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/wadler89.pdf))» — при построении категорий мы будем целиком полагаться на него. Далее мы рассмотрим некоторые категории с другими hom-типами.

# Вариантность

## Контравариантные функторы


> Латинская приставка «co-» часто переводится на русский язык как (внезапно!) «со-». Например «**ко**оператив» — это по сути «**со**вместная деятельность». В теории категорий многие термины имеют такую приставку потому, что отражают *дуальность* соответствующих понятий. Это означает, что с такими понятиями непременно **со**седствует аналогичное, полученное путём обращения всех морфизмов, участвующих в определении. Примеры: копроизведение, копредел, коконец и т.п.
> Но есть и исключения из этого правила. Например, двойственную категорию часто снабжают приставкой «op» от «oposite» — противоположный. (Видимо, англоязычной аудитории не понравилось, как звучит слово «cocategory». Впрочем, «коконцы» совсем не парят русскоговорящих)))
> А вот для вариантности функторов смысл приставки «ко-» хоть и сохраняет основную идею, но несёт немного дургую семантику. **Ко**вариантный функтор преобразует морфизмы **со**направленно `(A => B) => (F[A] => F[B])`, в то время как **контра**вариантный меняет направление морфизмов на **встречное** `(A => B) => (F[B] => F[A])`.

## Функторы для инвариантных конструкторов типов

## Функтор из категории типов в категорию категорий

```scala
type Hom[A, F[_]]
type Hom[F[_], A]
```

# Бифункторы

## Профункторы

# Категория функторов

## 2-категория



## Естественные преобразования


## Эдофункторы

