
Это вторая вводная часть обзора, посвящённого применению теории категорий в программировании. В первой части представлены некоторые основные определения теории, в том числе, hom-типы, их значения-морфизмы, а также их композиция, позволяющая строить пути вычислений в рамках одной категории. В данной же публикации мы рассмотрим, как *пути вычислений можно прокладывать через разные категории*. Фокус заключается в том, что все категории, которые представлены в этом обзоре, вместе образуют ещё одну категорию, которая называется

# Категория категорий

Да, всё так и есть! Ну, почти.

Строго говоря, математики обычно говорят о категории всех [малых (или локально малых) категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9#%D0%9C%D0%B0%D0%BB%D0%B0%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F). Подобного рода ограничения требуются для того, чтобы избежать аналога [парадокса Кантора](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%9A%D0%B0%D0%BD%D1%82%D0%BE%D1%80%D0%B0#:~:text=%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%CC%81%D0%BA%D1%81%20%D0%9A%D0%B0%CC%81%D0%BD%D1%82%D0%BE%D1%80%D0%B0%20%E2%80%94%20%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81%20%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2,%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%BE%D0%B9%20%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0%20%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE.), который получается с *категорией всех категорий*, обязанной включать саму себя.

Впрочем, нам, простым программистам, не нужно забивать голову такими нюансами)). Дело в том, что на практике мы оперируем лишь инструментами конструктивной математикой, которые просто не позволяют получить такого рода парадоксы. Например, если в качестве объектов использовать подкатегории F-типов, то правильнее говорить, что мы получим *категории типов высокого рода*. Объекты такой категории будут индексированы всеми однопараметрическими конструкторами типов `F[_]` ($F: \star \rightarrow \star$).

Но гораздо важнее то, какие *морфизмы* будут нам полезны в подобных категориях. То есть нужно выяснить, каким будет hom-тип, а также единичный морфизм и композиция: 
```scala
type Hom[F[_], G[_]]

type Category[Hom[_[_], _[_]]] = ( // ((* => *, * => *) => *) => **
	identity: [F[_]]             => ()                     => Hom[F, F],
	compose : [F[_], G[_], H[_]] => (Hom[G, H], Hom[F, G]) => Hom[F, H]
)
```

Конечно, мы всегда можем пойти проверенным путём и выбрать, например, константные hom-типы, получая моноиды и проч., как мы это делали в первой части обзора. Однако, категория категорий существенно богаче, и мы получим гораздо больше интересных возможностей, если в качестве морфизмов выберем

# Функторы

## Мотивация для программистов

Контейнерные типы `F[_]` используются в функциональном программировании для «чистого» (то бишь безопасного) обслуживания различных эффектов, в том числе и побочных. Поэтому часто встречаются задачи по «переключению эффекта» — переносу вычислений из одного контейнера (чаще всего `Id[_]`) в другой:

$$
\begin{split}
F[A] &\Rightarrow& \;F[B] &\Rightarrow& \;F[C] &\Rightarrow& \;F[D]\\
\\
&&& \hspace{1mm} \Downarrow\\
\\
G[A] &\Rightarrow& \;G[B] &\Rightarrow& \;G[C] &\Rightarrow& \;G[D]
\end{split}
$$

Такая стрелка (вниз) должна работать единообразно, *универсально* для всех путей вычислений, проходящих через любые объекты-типы. Это значит, что *каждой* функции `F[A] => F[B]` ставится в соответствие `G[A] => G[B]`, притом должна сохраняться ассоциативная композиция и свойства тождественного морфизма `identity`. Вся диаграмма типов и функций без изменений должна переноситься из подкатегории F-типов в подкатегорию G-типов. 

Впрочем, такое отображение вовсе не гарантирует взаимную однозначность — вполне допустимо, что *разные* `f, g: F[A] => F[B]` превращаются в одну и ту же `h: G[A] => G[B]`. Также возможно, что `G[A] =:= G[B]` для двух разных `A` и `B`. Важно лишь то, что отображение сохранит законы композиции морфизмов из исходной подкатегории типов.

Очевидно, что все такие «вертикальные» стрелки между разными подкатегориями типов можно композировать друг с другом, причём, эта композиция будет ассоциативной, и удовлетворяющей свойствам тождественного морфизма, переводящую любую категорию в неё же (т.е. ничего не делает). Значит эти стрелки вполне можно считать морфизмами в категории подкатегорий типов. Морфизмы с такими свойствами называются **функторами**.

## Определение

Вот более общее определение:
>Функтор — это такой морфизм в категории категорий, который каждому морфизму из одной категории ставит в соответствие морфизм из другой категории, сохраняя при этом тождественный морфизм и композицию.

### !!! Диаграмма для функтора

Во многих источниках можно встретить чуть расширенное определение функтора, включающее обязательное *сопоставление* объектов начальной категории с объектами конечной. У [Маклейна](https://www.google.com/search?q=%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8+%D0%B4%D0%BB%D1%8F+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%89%D0%B5%D0%B3%D0%BE+%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0) такое «сопоставление» даже называется «функцией», что может ввести в заблуждение. На самом деле в нашем случае речь идёт *не об обычных функциях*, действующих на значениях, но на конструкторах типов, которые на основе одного типа известной структуры конструируют другой тип. Кроме того, у Маклейна приводится и эквивалентное упрощённое определение функтора, аналогичное данному выше. Функтор просто переводит морфизмы одной категории в морфизмы другой, сохраняя все законы морфизмов!

Для произвольных категорий типов hom-тип функтора будет таким:
```scala
type Hom[Hom1[_, _], Hom2[_, _]] = [A, B] => Hom1[A, B] => Hom2[A, B]
```
В отличие от hom-типа категории типов, здесь мы получаем *полиморфную* функцию. Именно функцию, а не какой-то другой тип — в этом заключается особенность функтора на фоне прочих морфизмов в категории категорий. Значения этого типа буквально *применяются* к морфизмам первой категории, чтобы получить морфизмы для второй.

В случае же подкатегорий типов, индексированных конструкторами типов, приходим к сигнатуре, упомянутой ранее:
```scala
type Hom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[A] => G[B])
```

Определим метод расширения для функций в подкатегории F-типов:
```scala
extension [F[_], A, B](fab: F[A] => F[B])
  def fmap[G[_]](using functor: Hom[F, G]): G[A] => G[B] =
	  functor(fab)
```
Название метода `fmap` происходит от «**f**unction **map**ping» — отображение функций. Вот пример использования этого метода: 
```scala
given functorOptLst: Hom[Option, List] =
	[A, B] => (fOpt: Option[A] => Option[B]) => (listA: List[A]) =>
		fOpt(listA.headOption).map(_ +: functorOptLst(fOpt)(listA.tail)).toList.flatten
		//                     ↑↑↑                да, я читер)))                ↑↑↑↑↑↑↑

val fOpt: Option[Int] => Option[String] = _.map("строка " + _) // почему бы и нет?))
val gLst: List  [Int] => List  [String] = fopt.fmap[List]

gLst(List(40, 2)) // List(строка 40, строка 2)
```

Сигнатура hom-типа отличается от того, что принято считать функтором в программировании. Обычно начальной категорией выбирается категория всех типов, эквивалентная подкатегории, основанной на конструкторе типов `Id[_]`. В таком случае получается класс типов `Functor`, который зависит лишь от единственного параметра `F[_]`. Причины появления таких упрощённых формулировок мы рассмотрим позже.

> **Бесплатные теоремы** Для обеспечения законов морфизмов, функторов и проч. в категориях типов огромную роль играет параметрический, или [универсальный](https://habr.com/ru/articles/807467/#polymorphic_types) полиморфизм. [Специальный](https://habr.com/ru/articles/807485/#ad_hoc_polymorphism) же полиморфизм, дающий непредсказуемое поведение для специальных случаев типов-параметров, никак не помогает гарантировать выполнение законов. Пожалуй, самый полезный пример небезопасного полиморфизма можно найти в языке C++ с его параметризируемыми шаблонами `template`. Компилятор C++ устроен так, что сигнатура шаблонных типов и методов никак не гарантирует универсальность, одинаковость работы со всеми типами-параметрами.
> Филипп Вадлер [назывет](https://users.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/wadler89.pdf) эту особенность универсального полиморфизма **бесплатными теоремами**. Также о них можно [прочесть](https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/) и у Бартоша Милевски.

### !!! Функтор из категории типов в категорию категорий

```scala
type Hom[A, F[_]]
type Hom[F[_], A]
```

[FP на Scala: Что такое функтор?](https://habr.com/ru/companies/golovachcourses/articles/266905/)


## Контравариантные функторы

Если присмотреться к введённым в предыдущем разделе hom-типам, то станет заметно, что они не покрывают все случаи, удовлетворяющие законам функторов. Функтор должен отображать все пути из исходной категории в конечную, однако, сделать это можно не только в лоб, но и *обратив все стрелки*! Такой функтор будет называться *контравариантным* в отличие от приведённого выше, называемого *ковариантным*:
```scala
type     CovariantHom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[A] => G[B])
type ContravariantHom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[B] => G[A])
//                                                                 ↑       ↑
```

> Латинская приставка «co-» часто переводится на русский язык как (внезапно!) «со-». Например «**ко**оператив» — это по сути «**со**вместная деятельность». В теории категорий многие термины имеют такую приставку потому, что отражают *дуальность* соответствующих понятий. Это означает, что с такими понятиями непременно **со**седствует аналогичное, полученное путём обращения всех морфизмов, участвующих в определении. Примеры: копроизведение, копредел, коконец и т.п.
> Но есть и исключения из этого правила. Например, двойственную категорию часто снабжают приставкой «op» от «oposite» — противоположный. (Видимо, англоязычной аудитории не понравилось, как звучит слово «cocategory». Впрочем, «коконцы» совсем не парят русскоговорящих)))
> А вот для вариантности функторов смысл приставки «ко-» хоть и сохраняет основную идею, но несёт немного другую семантику. **Ко**вариантный функтор преобразует морфизмы **со**направленно, в то время как **контра**вариантный меняет направление морфизмов на **встречное**.

Если исходная и конечная категории фиксированы, то между ними можно построить либо ковариантный функтор, либо контравариантный, либо ни тот, ни другой. И только в очень редких случаях можно построить оба типа функтора. Нас прежде всего интересуют такие подкатегории типов, которые определяются конкретным конструктором типов `F[_]`. Очевидно, что вариантность функторов между двумя такими категориями будет определятся только устройством их конструкторов типов.

За точку отчёта принято брать общую категорию типов. Тогда очевидно, что функтор между ней и подкатегорией на основе `Id[_]` будет ковариантным. Также ковариантными будут функторы между любыми подкатегориями, основанными на `Id`, `List`,  `Option`, `Reader`, `Witer` и проч. С другой стороны, контравариантными будут функторы между этими же категориями, и, например, основанной на таких конструкторах типов:
```scala
type ToString = [A] =>> A => String
type ToInt    = [A] =>> A => Int
```

### !!! Продемонстрировать!!!

А вот функтор между этими двумя категориями будет снова ковариантным!

### !!! Продемонстрировать!!!

И последний пример вариантности. Для подкатегории, основанной на следующем конструкторе типов не получится построить ни ко- ни контравариантный функтор:
```scala
type Inv = [A] =>> A => A
```

Получается, что вариантность функторов выделяет из конструкторов типов классы, в каждом из которых функторы между соответствующими подкатегориями будут ковариантными, а функторы *между* классами окажутся контравариантными. Вариантность функторов переносится на конструкторы типов!

В предыдущем обзоре обобщённых типов [говорилось](https://habr.com/ru/articles/807467/#variance), что вариантность конструкторов типов однозначно определяется «знаками позиций» типа параметра. Если одно упоминание параметра находится слева нечётного количества стрелок `=>` (т.е. нечётное количество раз является аргументом функций), то его позиция *отрицательная*, а иначе — положительная. Если позиции всех упоминаний параметра положительные (`Id`,  `Option` и проч.), то обобщённый тип называется ковариантным, а если все отрицательные (`ToString`, `ToInt`) — контравариантным. Если же в определении параметры встречаются в позициях с разными знаками (`Inv`), такой обобщённый тип будет *инвариантным*.


[Контравариантный функтор в Scala Cats](https://habr.com/ru/companies/otus/articles/568096/)


## Эндофункторы

Вышел был показан пример функтора между подкатегориями `Option` и `List`, который абсолютно бесполезен на практике))). Он был нужен для демонстрации концепции функтора. Дело в том, что реализация вручную функций вида `F[A] => F[B]` — занятие весьма неблагодарное, приводящие к многократному копированию шаблонного кода. Гораздо проще определять функции вида `A => B`, чтобы потом их «поднимать» их в подкатегорию `F[_]` с помощью функтора `Hom[Id, F]`. Именно такие упрощённые функторы и получили распространение в программировании:
```scala
type Functor[F[_]] = Hom[Id, F]
```
### !!! Эндофунктор !!!


Тип `Functor`, так же как и `Hom` для подкатегорий типов, удобнее считать классом типов, неявно передавая его экземпляры через контекст. Для него подходят такие методы расширения:
```scala
extension [A, B](f: A => B)
  inline def lift[F[_]: Functor as functor]: F[A] => F[B] =
    functor(f)

extension[F[_]: Functor as functor, A] (fa: F[A])
  inline def map[B](f: A => B): F[B] =
    f.lift[F](fa)
```

В данном случае метод `lift` не просто отображает функции, как `fmap`, но «поднимает» их в подкатегорию `F`. На практике же чаще по привычке используют более императивный метод `map`, отображающий значения `F[A]` в `F[B]` с помощью функции `A => B`.

### !!! Продемонстрировать!!!

Иногда при обсуждении функторов говорят о «подъёме» не только функций, но и самих значений: `lift: A => F[A]`. Но на самом деле такая функция не имеет прямого отношения к функторам между подкатегориями типов (в лучше случае, между дискретными категориями значений, но это не очень интересно).



## Бифункторы

## Профункторы

## Инвариантные функторы

[Инвариантный функтор в Scala Cats](https://habr.com/ru/companies/otus/articles/568118/)
[FP на Scala: Invariant Functor](https://habr.com/ru/companies/golovachcourses/articles/267087/)
https://typelevel.org/cats/typeclasses/invariant.html
https://ncatlab.org/nlab/show/invariant

## Про наследование классов типов!

Иногда Functor наследуют от Invariant #facepalm


# Категория функторов

## 2-категория



## Естественные преобразования


## Эдофункторы

