
Это вторая вводная часть обзора, посвящённого применению теории категорий в программировании. В первой части представлены некоторые основные определения теории, в том числе, hom-типы, их значения-морфизмы, а также их композиция, позволяющая строить пути вычислений в рамках одной категории. В данной же публикации мы рассмотрим, как *пути вычислений можно прокладывать через разные категории*. Фокус заключается в том, что все категории, которые представлены в этом обзоре, вместе образуют ещё одну категорию, которая называется

# Категория категорий

Да, всё так и есть! Ну, почти.

Строго говоря, математики обычно говорят о категории всех [малых (или локально малых) категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9#%D0%9C%D0%B0%D0%BB%D0%B0%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F). Подобного рода ограничения требуются для того, чтобы избежать аналога [парадокса Кантора](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%9A%D0%B0%D0%BD%D1%82%D0%BE%D1%80%D0%B0#:~:text=%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%CC%81%D0%BA%D1%81%20%D0%9A%D0%B0%CC%81%D0%BD%D1%82%D0%BE%D1%80%D0%B0%20%E2%80%94%20%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81%20%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2,%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%BE%D0%B9%20%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0%20%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE.), который получается с *категорией всех категорий*, обязанной включать саму себя.

Впрочем, нам, простым программистам, не нужно забивать голову такими нюансами)). Дело в том, что на практике мы оперируем лишь инструментами конструктивной математикой, которые просто не позволяют получить такого рода парадоксы. Например, если в качестве объектов использовать подкатегории F-типов, то правильнее говорить, что мы получим *категории типов высокого рода*. Объекты такой категории будут индексированы всеми однопараметрическими конструкторами типов `F[_]` ($F: \star \rightarrow \star$).

Но гораздо важнее то, какие *морфизмы* будут нам полезны в подобных категориях. То есть нужно выяснить, каким будет hom-тип, а также единичный морфизм и композиция: 
```scala
type Hom[F[_], G[_]]

type Category[Hom[_[_], _[_]]] = ( // ((* => *, * => *) => *) => **
	identity: [F[_]]             => ()                     => Hom[F, F],
	compose : [F[_], G[_], H[_]] => (Hom[G, H], Hom[F, G]) => Hom[F, H]
)
```

Конечно, мы всегда можем пойти проверенным путём и выбрать, например, константные hom-типы, как мы это делали в первой части обзора. Однако, категория категорий существенно богаче, и мы получим гораздо больше интересных возможностей, если в качестве морфизмов выберем

# Мотивация для программистов

Контейнерные типы `F[_]` используются в функциональном программировании для «чистого» (то бишь безопасного) обслуживания различных эффектов, в том числе и побочных. Поэтому часто встречаются задачи по «переключению эффекта» — переносу вычислений из одного контейнера (чаще всего `Id[_]`) в другой:

$$
\begin{split}
F[A] &\rightarrow& \;F[B] &\rightarrow& \;F[C] &\rightarrow& \;F[D]\\
\\
&&& \hspace{1mm} \Downarrow\\
\\
G[A] &\rightarrow& \;G[B] &\rightarrow& \;G[C] &\rightarrow& \;G[D]
\end{split}
$$

Стрелка $\Downarrow$ должна работать единообразно, *универсально* для всех путей вычислений, проходящих через любые объекты-типы. Это значит, что *каждой* функции `F[A] => F[B]` ставится в соответствие `G[A] => G[B]`, притом должна сохраняться ассоциативная композиция и свойства тождественного морфизма `identity`. Вся диаграмма типов и функций без изменений должна переноситься из подкатегории F в подкатегорию G.

Впрочем, такое отображение не обязано быть взаимно однозначным — вполне допустимо, что *разные* `f, g: F[A] => F[B]` превращаются в одну и ту же `h: G[A] => G[B]`. Важно лишь то, что отображение сохранит законы композиции морфизмов из основной подкатегории типов.

Очевидно, что все такие «вертикальные» стрелки между разными подкатегориями типов можно композировать друг с другом, причём, эта композиция будет ассоциативной, и удовлетворяющей свойствам тождественного морфизма, переводящую любую категорию в неё же (т.е. ничего не делает). Значит эти стрелки вполне можно считать морфизмами в категории подкатегорий типов. Морфизмы с такими свойствами называются **функторами**.


# Определение

Вот более общее определение:
>Функтор — это такой морфизм в категории категорий, который каждому морфизму из одной категории ставит в соответствие морфизм из другой категории, сохраняя при этом тождественный морфизм и композицию.

## !!! Диаграмма для функтора

Следуя Милевски, функторы как бы «встраивают» исходную категорию в целевую. Функтор *моделирует* всю исходную категорию внутри конечной.

Во многих источниках можно встретить чуть расширенное определение функтора, включающее обязательное *сопоставление* объектов начальной категории с объектами конечной. [В книге Маклейна](https://www.google.com/search?q=%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8+%D0%B4%D0%BB%D1%8F+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%89%D0%B5%D0%B3%D0%BE+%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0) такое «сопоставление» даже называется «функцией», что может ввести в заблуждение. На самом деле в нашем случае речь идёт *не об обычных функциях*, действующих на значениях, но на конструкторах типов, которые на основе одного типа известной структуры конструируют другой тип.

Но задача функтора — трансформировать морфизмы одной категории в морфизмы другой! Только если предоставлена *реализация такой трансформации*, то можно говорить о том, что у нас есть функтор между категориями. (Впрочем, у Маклейна также приводится и упрощённое определение функтора, аналогичное нашему.)

Для произвольных категорий типов hom-тип функтора будет таким:
```scala
type Hom[Hom1[_, _], Hom2[_, _]] = [A, B] => Hom1[A, B] => Hom2[A, B]
```
В отличие от hom-типа категории типов, здесь мы получаем *полиморфную* функцию. Именно функцию, а не какой-то другой тип — в этом заключается особенность функтора на фоне прочих морфизмов в категории категорий. Значения этого типа буквально *применяются* к морфизмам первой категории, чтобы получить морфизмы для второй.



# Функторы в подкатегориях типов


В случае же подкатегорий типов, индексированных конструкторами типов, приходим к сигнатуре, упомянутой ранее:
```scala
type Hom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[A] => G[B])
```

Тривиальный морфизм и композиция определяются так:
```scala
type Category = (
  identity: [F[_]]             => ()                     => Hom[F, F],
  compose : [F[_], G[_], H[_]] => (Hom[G, H], Hom[F, G]) => Hom[F, H]
)

given category: Category = (
  identity = [F[_]] => () =>
    [A, B] => (fab: F[A] => F[B]) => fab,
  
  compose  = [F[_], G[_], H[_]] => (gh: Hom[G, H], fg: Hom[F, G]) =>
    [A, B] => (fab: F[A] => F[B]) => (gh[A, B] compose fg[A, B])(fab)
)
```

Определим метод расширения для функций в подкатегории F-типов:
```scala
extension [F[_], A, B](fab: F[A] => F[B])
  def fmap[G[_]](using functor: Hom[F, G]): G[A] => G[B] =
	  functor(fab)
```
Название метода `fmap` происходит от «**f**unction **map**ping» — отображение функций. Вот пример использования этого метода: 
```scala
given functorOptLst: Hom[Option, List] =
	[A, B] => (fOpt: Option[A] => Option[B]) => (listA: List[A]) =>
		fOpt(listA.headOption).map(_ +: functorOptLst(fOpt)(listA.tail)).toList.flatten
		//                     ↑↑↑                да, я читер)))                ↑↑↑↑↑↑↑

val fOpt: Option[Int] => Option[String] = _.map("строка " + _) // почему бы и нет?))
val gLst: List  [Int] => List  [String] = fopt.fmap[List]

gLst(List(40, 2)) // List(строка 40, строка 2)
```

Сигнатура hom-типа отличается от того, что принято считать функтором в программировании. Обычно начальной выбирается категория всех типов, эквивалентная подкатегории, основанной на конструкторе типов `Id[_]`. В таком случае получается класс типов `Functor`, который зависит лишь от единственного параметра `F[_]`. Причины появления таких упрощённых формулировок мы рассмотрим позже.

> **Бесплатные теоремы** Для обеспечения законов морфизмов, функторов и проч. в категориях типов огромную роль играет параметрический, или [универсальный](https://habr.com/ru/articles/807467/#polymorphic_types) полиморфизм. [Специальный](https://habr.com/ru/articles/807485/#ad_hoc_polymorphism) же полиморфизм, дающий непредсказуемое поведение для специальных случаев типов-параметров, никак не помогает гарантировать выполнение всех законов. Типичный пример небезопасного полиморфизма можно найти в языке C++ с его параметризируемыми шаблонами `template`. Компилятор C++ устроен так, что сигнатура шаблонных типов и методов никак не гарантирует универсальность, одинаковость работы со всеми типами-параметрами.
> 
> Филипп Вадлер [назывет](https://users.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/wadler89.pdf) эту особенность универсального полиморфизма **бесплатными теоремами**. Также о них можно [прочесть](https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/) и у Бартоша Милевски.

## !!! Функтор из категории типов в категорию категорий

```scala
type Hom[A, F[_]]
type Hom[F[_], A]
```

[FP на Scala: Что такое функтор?](https://habr.com/ru/companies/golovachcourses/articles/266905/)


# Изоморфизм категорий

В **предыдущей части обзора** был определён изоморфизм объектов категории — это соотношение эквивалентности, задаваемое двумя противоположно направленными морфизмами между объектами, причём обе их композиции равны тождественным морфизмам. Теперь мы работаем с категорией подкатегорий типов — как тут обстоят дела с изоморфизмами подкатегорий $\mathcal{C} \cong \mathcal{D}$?

Формально тут всё как и всегда — чтобы между объектами `C[_]` и `D[_]` существовал изоморфизм, нужно предоставить два функтора `f: Hom[C, D]` и `g: Hom[D, C]`, так, чтобы
- `summon[Category].compose(f, g)` совпадало с `summon[Category].identity[D]()` 
- `summon[Category].compose(g, f)` совпадало с `summon[Category].identity[C]()` 

Давайте проверим, как это работает для категорий на основе очевидно изоморфных конструкций
```scala
type Pair[X] = X × X
type Pow2[X] = Boolean => X  // X²
```

Сперва определяем встречные функторы
```scala
val functorPairPow2: Hom[Pair, Pow2] =
	[A, B] => (f: Pair[A] => Pair[B]) => (a2: Pow2[A]) =>
		(b: Boolean) =>
			val pairB = f(a2(false), a2(true))
			if b then pairB._2 else pairB._1

val functorPow2Pair: Hom[Pow2, Pair] =
	[A, B] => (f: Pow2[A] => Pow2[B]) => (pairA: Pair[A]) =>
		val b2 = f(b => if b then pairA._2 else pairA._1)
		b2(false) -> b2(true)
```

Затем, строим любую их композицию. Для простоты, такую:
```scala
val roundUp: Hom[Pair, Pair]  = summon[Category].compose(functorPow2Pair, functorPairPow2)
```

А теперь продемонстрируем, что эта композиция эквивалентна тождественному морфизму
```scala
val morph1: Pair[Int] => Pair[Int] = p => (p._1 * 2, p._2 + 2)
val morph2: Pair[Int] => Pair[Int] = roundUp(morph1) // roundUp сохраняет исходный морфизм!

// проверяем, что мы получили ту же самую функцию
morph1(21, 40) // (42,42)
morph2(21, 40) // (42,42)
```

Путь вычисления `morph2` начинается в категории `Pair[Int]`, затем идёт в категорию `Pow2[_]` и возвращается обратно. И этот длинный путь не меняет ничего, как будто мы и не покидали исходную категорию `Pair[_]`!




# Контравариантные функторы

Если присмотреться к введённым в предыдущем разделе hom-типам, то станет заметно, что они не покрывают все случаи, удовлетворяющие законам функторов. Функтор должен отображать все пути из исходной категории в конечную, однако, сделать это можно не только в лоб, но и *обратив все стрелки*! Такой функтор будет называться *контравариантным* в отличие от приведённого выше, называемого *ковариантным*:
```scala
type     CovariantHom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[A] => G[B])
type ContravariantHom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[B] => G[A])
//                                                                 ↑       ↑
```

Для контравариантного функтора обычно используются методы с такими названиями:
```scala
extension [F[_], A, B](fab: F[A] => F[B])
  inline def fcontramap[G[_]](using contraFunctor: ContravariantHom[F, G]): G[B] => G[A] =
    contraFunctor(fab)

extension [G[_], A](ga: G[A])
  inline def contramap[F[_], B](f: F[B] => F[A])(using ContravariantHom[F, G]): G[B] =
    f.fcontraMap[G](ga)
```

Контравариантные функторы иногда удобнее воспринимать как обычные, ковариантные, но в которых исходная категория заменена на **дуальную** (см. предыдущую часть обзора):
$$
F_{contaV}(\mathcal{C}, \mathcal{D}) \equiv F_{coV}(\mathcal{C}^{op}, \mathcal{D})
$$
Для двух заданных категорий обычно не ставится вопрос «какой вариантности функтор между ними выбрать?» Скорее приходится выяснять, если между ними можно построить функтор, то он будет ко- или контравариантным.

> Латинская приставка «co-» часто переводится на русский язык как (внезапно!) «со-». Например, «**ко**оператив» — это по сути «**со**вместная деятельность». В теории категорий многие термины имеют такую приставку потому, что отражают *дуальность* соответствующих понятий. Это означает, что с такими понятиями непременно **со**седствует аналогичное, полученное путём обращения всех морфизмов, участвующих в определении. Примеры: копроизведение, копредел, коконец и т.п.
> Но есть и исключения из этого правила. Двойственную категорию часто снабжают приставкой «op» от «oposite» — противоположный. (Видимо, англоязычной аудитории не понравилось, как звучит слово «cocategory». Впрочем, «коконцы» совсем не парят русскоговорящих)))
> А вот для вариантности функторов смысл приставки «ко-» хоть и сохраняет основную идею, но несёт немного другую семантику. **Ко**вариантный функтор преобразует морфизмы **со**направленно, в то время как **контра**вариантный меняет направление морфизмов на **встречное**.

Если исходная и конечная категории фиксированы, то между ними можно построить либо ковариантный функтор, либо контравариантный, либо ни тот, ни другой. И только в очень редких случаях можно построить оба типа функтора. Нас прежде всего интересуют такие подкатегории типов, которые определяются конкретным конструктором типов `F[_]`. Очевидно, что вариантность функторов между двумя такими категориями будет определятся только устройством их конструкторов типов.

За точку отчёта принято брать общую категорию типов. Тогда очевидно, что функтор между ней и подкатегорией на основе `Id[_]` будет ковариантным. Также ковариантными будут функторы между любыми подкатегориями, основанными на `Id`, `List`,  `Option`, `Reader`, `Witer` и проч. С другой стороны, контравариантными будут функторы между этими же категориями, и, например, основанной на таких конструкторах типов:
```scala
type ToString = [A] =>> A => String
type ToInt    = [A] =>> A => Int
```

## !!! Продемонстрировать!!!

А вот функтор между этими двумя категориями будет снова ковариантным!

## !!! Продемонстрировать!!!

И последний пример вариантности. Для подкатегории, основанной на следующем конструкторе типов не получится построить ни ко- ни контравариантный функтор:
```scala
type Inv = [A] =>> A => A
```

Получается, что вариантность функторов выделяет из конструкторов типов классы, в каждом из которых функторы между соответствующими подкатегориями будут ковариантными, а функторы *между* классами окажутся контравариантными. Вариантность функторов переносится на конструкторы типов!

В предыдущем обзоре обобщённых типов [говорилось](https://habr.com/ru/articles/807467/#variance), что вариантность конструкторов типов однозначно определяется «знаками позиций» типа параметра. Если одно упоминание параметра находится слева нечётного количества стрелок `=>` (т.е. нечётное количество раз является аргументом функций), то его позиция *отрицательная*, а иначе — положительная. Если позиции всех упоминаний параметра положительные (`Id`,  `Option` и проч.), то обобщённый тип называется ковариантным, а если все отрицательные (`ToString`, `ToInt`) — контравариантным. Если же в определении параметры встречаются в позициях с разными знаками (`Inv`), такой обобщённый тип будет *инвариантным*.

В Scala можно явно проставить у типа параметра его знак, если он одинаковый для всех упоминаний в определении типа:
```scala
type ToString[-A] =         A       => String   // `A` упомянут левее ОДНОЙ стрелки
type MyOption[+A] = [X] => (A => X) => (X => X) // `A` упомянут левее ДВУХ  стрелок 
```
Если знак указан явно, то его придётся учитывать в некоторых случаях композиции конструкторов типов, когда у компилятора не будет возможности выяснить знак самостоятельно.

Конструктор типов `MyOption` записан в кодировке Чёрча, когда тип описывается только функциями, показывающими как использовать значения этого типа. В частности, данный тип функции соответствует сигнатуре метода `Option.fold`, полностью описывающего тип `Option[_]`. Обобщённые типы `MyOption`  и `Option` изоморфны.

Я акцентирую внимание на кодировке Чёрча потому, что с её помощью можно представить интерпретацию любого типа без упоминания тех же сумм и произведений — останутся только экспоненциалы-функции (в общем случае, высокого порядка). Но при этом вариантность обобщённых типов не меняется! Таким образом, любой тип можно переписать по Чёрчу и подсчитать, левее скольких стрелок окажутся все вхождения типа-параметра.

## !!!! Переписать этот бред про знаки позиций!!!!

Важность выражения типов виде функций высокого порядка в том, что получается древовидная структура `T[A]`,  представляющая собой либо функцию вида `T[A] => T[A]`, либо тип-параметр `A`, либо какой-то простой непараметризированный тип.

Функторы подкатегорий типов должны как-то встраивать в эту конструкцию функцию `G[A] => G[X]`, или `G[X] => G[A]` из исходной категории. Для этого нужно рекурсивно пробежать дерево и только случай `T[A] => T[A]` представляет интерес. Дело в том, что при встраивании в правую часть выражения нам подойдёт только функция вида `G[A] => G[X]`.

, *скомпозировать* её со всеми составляющими её «маленькими» функциями, в которых встречается тип-параметр. А каждая такая композиция будет превращать «маленькую» `A => B` либо в `A => X`, либо в `X => B`, в зависимости от того, какой тип является параметром — правый `B`, или левый `A`. А это уже влияет на то, какого вида функцию можно использовать для такого превращения — будет ли целевой тип-параметр `X` стоять справа, или слева. Тогда в первом случае мы получим сигнатуру ковариантного преобразование, а во втором — контравариантное.


[Контравариантный функтор в Scala Cats](https://habr.com/ru/companies/otus/articles/568096/)



# Эндофункторы

Выше был показан пример функтора между подкатегориями `Option` и `List`, который абсолютно бесполезен на практике))). Он был нужен для демонстрации концепции функтора. Дело в том, что реализация вручную функций вида `F[A] => F[B]` — занятие весьма неблагодарное, приводящие к многократному копированию шаблонного кода. Гораздо проще определять функции вида `A => B`, чтобы потом их «поднимать» их в подкатегорию `F[_]` с помощью функтора `Hom[Id, F]`. Именно такие упрощённые функторы и получили распространение в программировании:
```scala
type Functor[F[_]] = Hom[Id, F]
```

Этот функтор связывает общую категорию типов с её подкатегорией, значит он начинается и заканчивается во всё той же категории типов! Функторы, чьи начальная и конечная категория совпадают, называются *эндофункторами*. Замечательным свойством эндофункторов является то, что их можно применять многократно, переходя ко всё более глубоким слоям «матрёшки» подкатегорий. А за «разматрёшивание» отвечает как раз концепция монады, которая и будет основным объектом изучения в данном обзоре. Но мы придём к ней позднее.

Тип `Functor`, так же как и `Hom` для подкатегорий типов, удобнее использовать как класс типов, неявно передавая его экземпляры через контекст. С ним удобно использовать такие методы расширения:
```scala
extension [A, B](f: A => B)
  inline def lift[F[_]: Functor as functor]: F[A] => F[B] =
    functor(f)

extension[F[_]: Functor as functor, A] (fa: F[A])
  inline def map[B](f: A => B): F[B] =
    f.lift[F](fa)
```

В данном случае метод `lift` не просто отображает функции, как `fmap`, но «поднимает» их в подкатегорию `F`. На практике же по привычке чаще используют более императивный метод `map`, *отображающий* значения `F[A]` в `F[B]` с помощью функции `A => B`.

## !!! Продемонстрировать `map` !!!

В библиотеке Cats ковариантный и контравариантный функторы представлены классами типов [Functor](https://typelevel.org/cats/typeclasses/functor.html) и [Contravariant](https://typelevel.org/cats/typeclasses/contravariant.html).

При обсуждении функторов иногда говорят о «подъёме» не только функций, но и самих значений: `lift: A => F[A]`.  В Haskell есть так называемый «pointed functor» — стандартный эндофунктор, дополненный функцией `point`, «поднимающей» значения. Но на самом деле эта функция не имеет прямого отношения к функторам между подкатегориями типов.

Конструкторов типов (`Option`, `List`, …) часто самих некорректно называют функторами. Причина кроется в тяжёлом наследии языка Haskell — основоположника статически типизированного функционального программирования. Дело в том, что там у классов типов допускается только единственная реализация. То есть, даже для типа целых чисел в Haskell не получится сделать разные реализации моноида (только через извращения).

Получается, что с каждым конструктором типов в Haskell может ассоциироваться единственный экземпляр эндофунктора. В этом случае и не будет большой ошибкой конструкторы типов попросту называть (эндо)функторами. К сожалению, эта привычка глубоко укоренилась в сознании программистов и часто мешает пониманию простых идей, лежащих в фундаменте всех этих инструментов. На самом же деле, эндофункторы для категории типов, отображающие эту категорию саму в себя, являются наглядным примером того, что между категориями можно построить более одного полезного функтора.


# Функториальность и подтипизация

В Scala, как и некоторых других языках программирования, основное назначение механизма контроля вариантности конструкторов типов типов `F[_]` заключается в «пробросе подтипизации». Напомню, если `A <:< B`, то для ковариантного `F[+_]` будет `F[A] <:< F[B]`, а для контравариантного `G[-_]` — `G[B] <:< G[A]`.

Фишка в том, что подтипизация — это, по определению, возможность использовать термы ($\simeq$ значения) подтипа там, где ожидается супертип. В таких случаях *неявно вызывается функция приведения типа*. Таким образом, вариантность конструкторов типов можно перефразировать в функциях так: для `F[+_]` и любых `A` и `B`, если предоставлена функция (неявного приведения) `A => B`, то мы *автоматически* получаем функцию (неявного приведения) `F[A] => F[B]`. Ничего не напоминает?

Да, это уже знакомый нам ковариантный эндофунктор, основанный на `F[+_]`! И для контравариантных `G[-_]` мы также имеем поведение соответствующего эндофунктора. То есть, компилятор уже умеет предоставлять доказательства функториальности конструкторов типов!

К сожалению, исторически сложилось так, что в современных популярных языках программирования этот механизм безнадёжно сломан. Изначально он появился как ООП-шный инструмент работы с иерархией наследования классов — организация размещения объекта в памяти такова, что смена типа от подкласса к суперклассу происходит совершенно *бесплатно ещё на этапе компиляции*. Позднее добавилась странная, слабо обоснованная подтипизация числовых типов данных и появились специальные типы (`Any`, `Nothing`), для которых в систему подтипизации встраивались отдельные костыли, также не связанные с ООП.

А сейчас программистам разрешено поверх всего это писать свои собственные функции неявного приведения типов. Они ведут себя практически также, как и подтипизация, но вот только компилятор их таковыми не считает и не задействует в механизме вариантности конструкторов типов.

И даже в таком языке, как Scala нет встроенной поддержки эндофункторов, позволяющей без лишних телодвижений вручную переводить `F[A]` в `F[B]`, если есть функция `A => B`, для *любых* `F[+_]`. Для этого приходится подключать хоть и популярные, но разношёрстные сторонние библиотеки, вроде [Scalaz](https://eed3si9n.com/learning-scalaz/Functor.html), или [Cats](https://eed3si9n.com/herding-cats/Functor.html), или велосипедить функторы вручную.




# Бифункторы

В предыдущей части обзора **упоминалось**, что из двух любых категорий всегда можно построить новую, которая будет называться произведением категорий. Её объектами будут пары объектов, а морфизмами — пары морфизмов.

Функтор из произведения категорий в другую категорию называется **бифунктором** (латинская приставка «bi-» означает «двойной»):
$$
Bifunctor:\;\mathcal{C}\times\mathcal{D} \Rightarrow \mathcal{E}
$$

В случае категорий типов бифунктор определяется двухпараметрическим конструктором типов:
```scala
type Bi[A, B] // (*, *) => *
```
Он переводит объекты категориального произведения в категорию типов. Сам же функтор должен преобразовывать морфизмы. Соответсвующий hom-тип будет иметь вид
```scala
type Bifunctor[Bi[_, _]] = [A, B, C, D] => (A => C, B => D) => (Bi[A, B] => Bi[C, D])
```

Очевидно, что такой бифунктор представляет сразу два (ковариантных) функтора — по одному для каждой исходной категории (для каждого параметра `Bi[_, _]`). В библиотеке Cats у класса типа [Bifunctor](https://typelevel.org/cats/typeclasses/bifunctor.html) есть методы получения обеих функторов, а также методы расширения `map` и `leftMap` для преобразования правого и левого параметров соответственно.

Для бифунктора привычны такие методы расширения:
```scala
extension [A, B, C, D] (fg: (A => C, B => D))
  inline def fbimap[Bi[_, _]: Bifunctor as bifunctor] = bifunctor[A, B, C, D].tupled(fg)

extension [Bi[_, _]: Bifunctor, A, B] (biab: Bi[A, B])
  inline def bimap[C, D](f: A => C, g: B => D) = (f, g).fbimap[Bi](biab)
```

Самые важные бифункторы связаны с суммой и произведением типов:
```scala
infix type + = [A, B] =>>  A Either B
infix type × = [A, B] =>> (A   ,    B)
//             ↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑↑↑
//         произведение     категория
//          категорий         типов
```

Классы типов `Bifunctor` реализуются для них так:
```scala
given sumBifunctor: Bifunctor[+] =
	[A, B, C, D] => (f: A => C, g: B => D) => (ab: A + B) =>
		ab.map(g).left.map(f)

given prodBifunctor: Bifunctor[×] =
	[A, B, C, D] => (f: A => C, g: B => D) => (ab: A × B) =>
		f(ab._1) -> g(ab._2)
```

А вот пример использования:
```scala
val stringOrInt: String + Int = Left("2b")

stringOrInt.bimap(
  "To be or not to be? " + _,
  _ => 42
) // каков же ответ?
```

По аналогии с бифункторами определяются и *мультифункторы* на основе конструкторов типов от большего числа параметров. Например:
```scala
type Trifunctor[Tri[_, _, _]] = [A1, A2, A3, B1, B2, B3] =>
  (A1 => B1, A2 => B2, A3 => B3) => (Tri[A1, A2, A3] => Tri[B1, B2, B3])
```


# Диагональный функтор

Если в определении бифунктора обратить стрелку, по мы получим *диагональный функтор*:
$$
\Delta:\: \mathcal{C} \Rightarrow \mathcal{D} \times \mathcal{E}
$$

Он как бы встраивает категорию $\mathcal{C}$ в произведение $\mathcal{D}\times\mathcal{E}$ «по диагонали».

## !!! Картинка для диагонального функтора !!!

Реализовать соответствующий конструктор типов сложнее, так как объекты конечной категории представляют собой пары типов, а не отдельные типы. И, тем не менее, это возможно:
```scala
type Δ[A] =  [Bi[_, _]   ] =>> Bi[A, A]
//     *  => ((*, *) => *) =>  *
//           ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ - произведение категорий типов в кодировке Чёрча
```
Тут нас выручает кодирование Чёрча — чем бы ни было то, что мы хотим использовать, важно лишь то, *как именно мы будем это использовать*! В данном случае показано, что чтобы воспользоваться парой типов, нужно предоставить двухпараметрический конструктор `Bi[_, _]`.

Hom-тип диагонального функтора будет такой полиморфной функцией:
```scala
type FunctorDiag = [A, B] => (A => B) => [Bi[_, _]: Bifunctor] => (Bi[A, A] => Bi[B, B])
```

Этот hom-тип сам по себе не параметризирован и его реализация по сути единственна, поэтому опишем её как обычную функцию, которую не нужно неявно передавать через контекст:
```scala
val functorDiag: FunctorDiag =
	[A, B] => (f: A => B) => [Bi[_, _]: Bifunctor] => (aa: Bi[A, A]) =>
		aa.bimap(f, f)
```

Для удобства использования определим такие методы расширения:
```scala
extension [A, B](f: A => B)
	inline def fmapBi[Bi[_, _] : Bifunctor]: Bi[A, A] => Bi[B, B] = functorDiag(f)[Bi]

extension [Bi[_, _] : Bifunctor, A](biaa: Bi[A, A])
	inline def mapBi[B](f: A => B): Bi[B, B] = f.fmapBi[Bi](biaa)

val unitPair: Unit × Unit = () -> ()
val makePair: [A] => A => Δ[A][×] =
	[A] => (a: A) => unitPair.mapBi(_ => a) // экземпляр Bifunctor[×] уже есть в контексте

makePair(42) // (42,42)
```


# Профункторы

Бифункторы, представленные ранее являлись ковариантными по обеим параметрам. Переставив пару параметров местами (или обратив пару стрелок), можно получить контравариантный бифунктор, который также может быть полезен, но, признаться, не встречал необходимости его использования на практике.

Гораздо большее значение имеют бифункторы, которые контравариантны лишь по одному параметру: `Pro[-_, +_]`. Бифунктор, в котором в произведении категорий одна из них выбрана дуальной имеет отдельное название — *профунктор*:
$$
Profunctor:\;\mathcal{C}^{op}\times\mathcal{D} \Rightarrow \mathcal{E}
$$

Важность профункторов в программировании помогает раскрыть, пожалуй, самый простой из них:
```scala
infix type =>[-A, +B] = Function[A, B] 
```
Профункторы в категориях типов представляют функциональные отношения! Да, контравариантность сама по себе всегда подразумевает функции, но профункторы одновременно параметризированы как входом, так выходом. Также, как и бифунктор, профунктор можно разложить на два функтора — ко- и контраваринатный.

Если вам показалось, что профункторы могут быть только функции вида `F[A] => G[B]`, то посмотрите на такой пример:
```scala
type MyPro[-A, +B] = (A, B => String) => String

val myPro1: MyPro[Boolean, Int] = (b: Boolean, intToStr: Int => String) =>
  intToStr(if b then 42 else 0)
//         ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ это Functon[Boolean, Int]

val myPro2: MyPro[Boolean, Int] = (b: Boolean, intToStr: Int => String) =>
  if b then intToStr(42) else "это ложь!"
```

Hom-тип профунктора строится по аналогии с бифунктором:
```scala
type Profunctor[==>[_, _]] = [A, B, C, D] => (C => A, B => D) => (A ==> B) => (C ==> D)
//                                            ↑    ↑ - поменялись местами
```

Для него характерны такие методы расширения:
```scala
extension [A, B, C, D] (fg: (C => A, B => D))
  inline def fdimap[==>[_, _]: Profunctor as profunctor] = profunctor[A, B, C, D].tupled(fg)

extension [==>[_, _]: Profunctor, A, B] (ab: A ==> B)
  inline def dimap[C, D](f: C => A, g: B => D) = (f, g).fdimap[==>](ab)
```

Так как латинская приставка «bi-» уже занята для бифунктора, то тут используется греческая приставка «di-», которая означает (кто бы мог подумать?) то же самое!)))

В Cats также есть класс типов [Profunctor](https://typelevel.org/cats/api/cats/arrow/Profunctor.html), в котором, помимо `dimap`, есть его частные случаи — методы `lmap`, `rmap` с очевидной реализацией. Но более интересна такая разновидность профункторов, как


# Стрелки

Профункторы представляют функциональные отношения в категории типов. И технически они могут быть морфизмами, но для этого нужно предоставить для них законопослушную композицию и тождественный морфизм. Если для некого `Pro[-_, +_]` есть экземпляры классов типов `Profunctor[Pro]` и `Category[Pro]` (см. **предыдущую часть обзора**), то такой профунктор называется **стрелкой**.

```scala
type Arrow[==>[_, _]] = Profunctor[==>] × Category[==>]
```

В предыдущей части обзора упоминался hom-тип категории Клейсли
```scala
type Kleisli[F[+_]] = [A, B] =>> A => F[B]
```
Такие морфизмы описывают вычисления «с эффектами»,  определёнными конструктором типов `F[+_]`. Класс типов `Category[Kleisli[F]]` даст удобные средства для построения цепочки эффективных вычислений, а, в свою очередь, `Profunctor[Kleisli[F]]` позволит встраивать в эту цепочку простые (типа, «чистые») функции вида `A => B`. В этом и заключается идея объединения возможностей `Profunctor` и `Category` в один класс типов `Arrow`.

## !!! неявные преобразования стрелок в профунктор и категорию и обратно

Стрелки отвечают за композицию вычислений, поэтому их зачастую снабжают дополнительными возможностями. В библиотеке Cats класс типов [Arrow](https://www.javadoc.io/doc/org.typelevel/cats-core_3/latest/cats/arrow/Arrow.html) наследует не просто профунктор, но так называемы «сильный профунктор» [Strong](https://www.javadoc.io/doc/org.typelevel/cats-core_3/latest/cats/arrow/Strong.html), который позволяет стрелке `Pro[_, _]` коммутировать с произведением типов, расщепляя путь вычисления на два *параллельных* (независимых). В той же библиотеке есть [ArrowChoice](https://www.javadoc.io/doc/org.typelevel/cats-core_3/latest/cats/arrow/ArrowChoice.html) который помимо прочего позволяет стрелке коммутировать с суммой типов, расщепляя путь вычисления на два *альтернативных*.

Стрелки [рассматривались в одном из моих предыдущих обзоров](https://habr.com/ru/articles/807495/#arrows) и, возможно, мы вернёмся к этой теме под конец данного.



# Инвариантные функторы

Существуют такие конструкторы типов `F[_]`, в которых тип-параметр встречается как в положительных, так и в отрицательных позициях. В таких ситуациях не получится честно предоставить экземпляр ни ко-, ни контравариантного эндофунктора для `F[_]`. Но, как вы возможно уже догадались, нас выручит профунктор!

Действительно, любой `F[_]` всегда можно переписать в виде `Pro[-_, +_]` так, чтобы `F[A] = Pro[-A, +A]`. Если при этом предоставить корректное преобразование `Pro[A, A] => Pro[B, B]` на основе функций из общей категории типов, то мы получим **инвариантный функтор**:
```scala
type Invariant[F[_]] = [A, B] => (A => B, B => A) => (F[A] => F[B])
```

Вот типичные методы расширения для инвариантного функтора:
```scala
extension [A, B] (fg: (A => B, B => A))
  inline def fimap[F[_]: Invariant as ifunctor] = ifunctor[A, B].tupled(fg)

extension [F[_]: Invariant, A] (fa: F[A])
  inline def imap[B](f: A => B, g: B => A) = (f, g).fimap[F](fa)
```

Инвариантные `F[_]` обычно описывают *процессы обработки значений одного типа*. Т.е. по сути они являются частным случаем `Pro[-_, +_]`, когда в обе дырки подставлен один и тот же тип. Это могут быть, например механизмы [сериализации/десериализации](https://github.com/circe/circe/blob/v0.14.13/modules/core/shared/src/main/scala/io/circe/Codec.scala#L58) (даже будучи распределённым, это один самосогласованный процесс), или реализация бинарной операции ([полугруппа](https://typelevel.org/cats/api/cats/Invariant$.html#catsInvariantMonoidalForSemigroup:cats.InvariantMonoidal[cats.Semigroup])) и т.п.

[Инвариантный функтор в Scala Cats](https://habr.com/ru/companies/otus/articles/568118/)
[FP на Scala: Invariant Functor](https://habr.com/ru/companies/golovachcourses/articles/267087/)
https://typelevel.org/cats/typeclasses/invariant.html
https://ncatlab.org/nlab/show/invariant



# Функторы для любых `F[_]`

В моих **предыдущих** **обзорах** демонстрировалось, что любой тип можно представить в виде алгебраического выражения, состоящего из некоторых предустановленных типов (`Nothing`, `Unit`, …) а также сумм, произведений и  экспоненциалов. Такие алгебраические выражения можно *композировать*, встраивать друг в друга, получая более сложные типы. И эта система была бы не полной без **неподвижных точек конструкторов типов**, отвечающих за рекурсивную композицию, без которой не были бы возможны списки, деревья и прочие рекурсивные типы.

Сейчас, мы видели, что для суммы, произведения и экспоненциала типов типов есть свои очевидные реализации ко-, контравариантных функторов (напомню, профунктор для экспоненциала представляет собой пару функторов разной вариантности). Для константных конструкторов типов реализация всех функторов вообще тривиальна. А можно ли столь же естественным образом *автоматически предоставлять функтор для любых конструкторов типов* `F[_]`?

Компилятор Scala, с его механизмом вычисления вариантности конструкторов типов, как бы намекает, что можно. И это действительно так!

Не будем полагаться на магию компилятора и проверим, как, например, ковариантные эндофункторы прокидываются через композицию конструкторов типов `F ∘ G`. автоматический вывод композитного функтора можно организовать так:
```scala
given compFunctor: [F[_] : Functor as fFunctor, G[_] : Functor as gFunctor] => Functor[F ∘ G] =
	[A, B] => (f: A => B) => (fFunctor[G[A], G[B]] compose gFunctor[A, B])(f)
```

Пусть у нас есть экземпляры функторов для `List[_]` и `WighLog[_]`:
```scala
given listFunctor: Functor[List] = [A, B] => (f: A => B) => (_: List[A]) map f

type WithLog[A] = (String, A)
given loggerFunctor: Functor[WithLog] = [A, B] => (f: A => B) =>
	(withLog: WithLog[A]) => withLog.copy(_2 = f(withLog._2))
```

Тогда мы можем любую функцию «поднять»  в категорию `List ∘ WithLog` (композитный функтор будет выведен автоматически):
```scala
val getStrLength = (_: String).length
val getLengths = getStrLength.lift[List ∘ WithLog] // using compFunctor
```

Убеждаемся, что всё работает как задумано:
```scala
val lst: (List ∘ WithLog)[String] = List("журнал 1" -> "0", "журнал 2" -> "42")
getLenghts(lst) // List(("журнал 1", 1), ("журнал 2", 2))
```

Автоматический вывод функтора можно найти в библиотеке [Kittens](https://github.com/typelevel/kittens) из экосистемы Cats. Соответствующий класс типов можно привязать к обобщённому классу явно с помощью ключевого слова `derives`:
```scala
import cats.derived.*

enum CList[+A] derives Functor:
  case CNil
  case CCons(head: A, tail: CList[A])
```

Также это можно сделать в полностью автоматическом режиме, просто импортировав в контекст `cats.derived.auto.functor.given` — функторы станут доступны для произвольных конструкторов типов.



# Промежуточный итог

Итак, в этой части мы познакомились с самой концепцией функтора — морфизма в категории категорий, рассмотрели основные свойства функторов между категориями типов, а также перечислили наиболее важные разновидности — они пригодятся нам в дальнейшем.

Возможно вас удивит, почему при обсуждении разновидностей функторов здесь не упоминались аппликативные. Дело в том, что такого понятия нет в теории категорий. Аппликативные, так же как и указывающие функторы придумали хаскелисты, посчитав их удобными инструментами для программирования. Но сами эти концепции сложнее, чем просто функторы и мы рассмотрим их в последующих частях обзора.

В предыдущей части были представлены подкатегории типов, основанные на конструкторах типов `F[_]`. И, не смотря не то, что с одним и тем же `F[_]` можно построить множество категорий, выбирая разные hom-типы и способы композиции морфизмов, мы договорились, что по умолчанию морфизмами всегда будут функции. Тождественный морфизм и композиция для них естественны и встроены в основную библиотеку Scala. В этом смысле конструкторы типов удобно ассоциировать с подкатегориями, говоря, например, о категориях List, или Option. Но даже тут я стараюсь избегать фраз типа «List — это категория».

Традиционно эти же рассуждения переносятся на функторы — так как для каждого `F[_]` есть свои естественные реализации функторов, то часто можно услышать что «List и Option — это функторы». Меня каждый раз коробит, когда слышу такое, а тут ещё самому пришлось написать))). Отчасти такая точка зрения возникла из ограничений Haskell, где у любого класса типов (`Functor`) возможна лишь единственная реализация. Иногда это оправдывают тем, что обобщённые классы List и Option в Scala имеют встроенные методы `map`, т.е. они «владеют основной возможностью функтора». Тем не менее, такие фразы *объективно некорректны*!

Основная задача эндофункторов в программировании заключается в переводе морфизмов-функций общей категории типов в морфизмы её F-подкатегории. Т.е. наиболее правильно реализовывать эту возможность в экземплярах класса `Functor` для типа `F[_]`. И стоит учитывать, что технически эти реализации могут быть разными. Другими словами, только конкретные `fFunctor: Functor[F]` можно справедливо называть функторами!

Но, как и с категориями, мы всегда можем рассуждать о «функторах для Option», или «функторах List». 

Ещё одна беда, связанная с традиционной реализацией функторов в Scala, заключается в использовании *наследования*… Например, в той же Cats ко- и контравариантные функторы наследуют инвариантный. То есть получается, что инвариантный функтор — это не произведение ко- и контравариантных функторов, но их сумма (да ещё плюс он сам как таковой)!

Этот лютый бред оправдывается задачами оптимизации в объектно-ориентированной среде JVM, но архитектурно он совершенно некорректен, привносит ненужные ограничения и вводит в заблуждение программистов. В общем, будьте внимательны и пусть ясность ваших мыслей не будет затуманена)).

В первой части обзора мы познакомились с категориями типов, а в этой части мы работали в категории подкатегорий типов. Но до монад всё ещё добрались)). А это значит, что

![[go deeper.png]]

В следующей части мы будет работать уже с категорией функторов!

## !!! Ссылки по всему тексту !!

