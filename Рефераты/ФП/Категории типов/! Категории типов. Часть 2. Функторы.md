
Это вторая вводная часть обзора, посвящённого применению теории категорий в программировании. В первой части представлены некоторые основные определения теории, в том числе, hom-типы, их значения-морфизмы, а также их композиция, позволяющая строить пути вычислений в рамках одной категории. В данной же публикации мы рассмотрим, как *пути вычислений можно прокладывать через разные категории*. Фокус заключается в том, что все категории, которые представлены в этом обзоре, вместе образуют ещё одну категорию, которая называется

# Категория категорий

Да, всё так и есть! Ну, почти.

Строго говоря, математики обычно говорят о категории всех [малых (или локально малых) категорий](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9#%D0%9C%D0%B0%D0%BB%D0%B0%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F). Подобного рода ограничения требуются для того, чтобы избежать аналога [парадокса Кантора](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%9A%D0%B0%D0%BD%D1%82%D0%BE%D1%80%D0%B0#:~:text=%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%CC%81%D0%BA%D1%81%20%D0%9A%D0%B0%CC%81%D0%BD%D1%82%D0%BE%D1%80%D0%B0%20%E2%80%94%20%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81%20%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2,%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%BE%D0%B9%20%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0%20%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE.), который получается с *категорией всех категорий*, обязанной включать саму себя.

Впрочем, нам, простым программистам, не нужно забивать голову такими нюансами)). Дело в том, что на практике мы оперируем лишь инструментами конструктивной математикой, которые просто не позволяют получить такого рода парадоксы. Например, если в качестве объектов использовать подкатегории F-типов, то правильнее говорить, что мы получим *категории типов высокого рода*. Объекты такой категории будут индексированы всеми однопараметрическими конструкторами типов `F[_]` ($F: \star \rightarrow \star$).

Но гораздо важнее то, какие *морфизмы* будут нам полезны в подобных категориях. То есть нужно выяснить, каким будет hom-тип, а также единичный морфизм и композиция: 
```scala
type Hom[F[_], G[_]]

type Category[Hom[_[_], _[_]]] = ( // ((* => *, * => *) => *) => **
	identity: [F[_]]             => ()                     => Hom[F, F],
	compose : [F[_], G[_], H[_]] => (Hom[G, H], Hom[F, G]) => Hom[F, H]
)
```

Конечно, мы всегда можем пойти проверенным путём и выбрать, например, константные hom-типы, получая моноиды и проч., как мы это делали в первой части обзора. Однако, категория категорий существенно богаче, и мы получим гораздо больше интересных возможностей, если в качестве морфизмов выберем

# Мотивация для программистов

Контейнерные типы `F[_]` используются в функциональном программировании для «чистого» (то бишь безопасного) обслуживания различных эффектов, в том числе и побочных. Поэтому часто встречаются задачи по «переключению эффекта» — переносу вычислений из одного контейнера (чаще всего `Id[_]`) в другой:

$$
\begin{split}
F[A] &\Rightarrow& \;F[B] &\Rightarrow& \;F[C] &\Rightarrow& \;F[D]\\
\\
&&& \hspace{1mm} \Downarrow\\
\\
G[A] &\Rightarrow& \;G[B] &\Rightarrow& \;G[C] &\Rightarrow& \;G[D]
\end{split}
$$

Такая стрелка (вниз) должна работать единообразно, *универсально* для всех путей вычислений, проходящих через любые объекты-типы. Это значит, что *каждой* функции `F[A] => F[B]` ставится в соответствие `G[A] => G[B]`, притом должна сохраняться ассоциативная композиция и свойства тождественного морфизма `identity`. Вся диаграмма типов и функций без изменений должна переноситься из подкатегории F-типов в подкатегорию G-типов. 

Впрочем, такое отображение вовсе не гарантирует взаимную однозначность — вполне допустимо, что *разные* `f, g: F[A] => F[B]` превращаются в одну и ту же `h: G[A] => G[B]`. Также возможно, что `G[A] =:= G[B]` для двух разных `A` и `B`. Важно лишь то, что отображение сохранит законы композиции морфизмов из исходной подкатегории типов.

Очевидно, что все такие «вертикальные» стрелки между разными подкатегориями типов можно композировать друг с другом, причём, эта композиция будет ассоциативной, и удовлетворяющей свойствам тождественного морфизма, переводящую любую категорию в неё же (т.е. ничего не делает). Значит эти стрелки вполне можно считать морфизмами в категории подкатегорий типов. Морфизмы с такими свойствами называются **функторами**.

# Определение

Вот более общее определение:
>Функтор — это такой морфизм в категории категорий, который каждому морфизму из одной категории ставит в соответствие морфизм из другой категории, сохраняя при этом тождественный морфизм и композицию.

## !!! Диаграмма для функтора

Во многих источниках можно встретить чуть расширенное определение функтора, включающее обязательное *сопоставление* объектов начальной категории с объектами конечной. [В книге Маклейна](https://www.google.com/search?q=%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8+%D0%B4%D0%BB%D1%8F+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%89%D0%B5%D0%B3%D0%BE+%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0) такое «сопоставление» даже называется «функцией», что может ввести в заблуждение. На самом деле в нашем случае речь идёт *не об обычных функциях*, действующих на значениях, но на конструкторах типов, которые на основе одного типа известной структуры конструируют другой тип.

Но задача функтора — трансформировать морфизмы одной категории в морфизмы другой! Только если предоставлена *реализация такой трансформации*, то можно говорить о том, что у нас есть функтор между категориями. (Впрочем, у Маклейна также приводится и упрощённое определение функтора, аналогичное нашему.)

Для произвольных категорий типов hom-тип функтора будет таким:
```scala
type Hom[Hom1[_, _], Hom2[_, _]] = [A, B] => Hom1[A, B] => Hom2[A, B]
```
В отличие от hom-типа категории типов, здесь мы получаем *полиморфную* функцию. Именно функцию, а не какой-то другой тип — в этом заключается особенность функтора на фоне прочих морфизмов в категории категорий. Значения этого типа буквально *применяются* к морфизмам первой категории, чтобы получить морфизмы для второй.

В случае же подкатегорий типов, индексированных конструкторами типов, приходим к сигнатуре, упомянутой ранее:
```scala
type Hom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[A] => G[B])
```

Определим метод расширения для функций в подкатегории F-типов:
```scala
extension [F[_], A, B](fab: F[A] => F[B])
  def fmap[G[_]](using functor: Hom[F, G]): G[A] => G[B] =
	  functor(fab)
```
Название метода `fmap` происходит от «**f**unction **map**ping» — отображение функций. Вот пример использования этого метода: 
```scala
given functorOptLst: Hom[Option, List] =
	[A, B] => (fOpt: Option[A] => Option[B]) => (listA: List[A]) =>
		fOpt(listA.headOption).map(_ +: functorOptLst(fOpt)(listA.tail)).toList.flatten
		//                     ↑↑↑                да, я читер)))                ↑↑↑↑↑↑↑

val fOpt: Option[Int] => Option[String] = _.map("строка " + _) // почему бы и нет?))
val gLst: List  [Int] => List  [String] = fopt.fmap[List]

gLst(List(40, 2)) // List(строка 40, строка 2)
```

Сигнатура hom-типа отличается от того, что принято считать функтором в программировании. Обычно начальной категорией выбирается категория всех типов, эквивалентная подкатегории, основанной на конструкторе типов `Id[_]`. В таком случае получается класс типов `Functor`, который зависит лишь от единственного параметра `F[_]`. Причины появления таких упрощённых формулировок мы рассмотрим позже.

> **Бесплатные теоремы** Для обеспечения законов морфизмов, функторов и проч. в категориях типов огромную роль играет параметрический, или [универсальный](https://habr.com/ru/articles/807467/#polymorphic_types) полиморфизм. [Специальный](https://habr.com/ru/articles/807485/#ad_hoc_polymorphism) же полиморфизм, дающий непредсказуемое поведение для специальных случаев типов-параметров, никак не помогает гарантировать выполнение всех законов. Типичный пример небезопасного полиморфизма можно найти в языке C++ с его параметризируемыми шаблонами `template`. Компилятор C++ устроен так, что сигнатура шаблонных типов и методов никак не гарантирует универсальность, одинаковость работы со всеми типами-параметрами.
> 
> Филипп Вадлер [назывет](https://users.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/wadler89.pdf) эту особенность универсального полиморфизма **бесплатными теоремами**. Также о них можно [прочесть](https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/) и у Бартоша Милевски.

## !!! Функтор из категории типов в категорию категорий

```scala
type Hom[A, F[_]]
type Hom[F[_], A]
```

[FP на Scala: Что такое функтор?](https://habr.com/ru/companies/golovachcourses/articles/266905/)


# Контравариантные функторы

Если присмотреться к введённым в предыдущем разделе hom-типам, то станет заметно, что они не покрывают все случаи, удовлетворяющие законам функторов. Функтор должен отображать все пути из исходной категории в конечную, однако, сделать это можно не только в лоб, но и *обратив все стрелки*! Такой функтор будет называться *контравариантным* в отличие от приведённого выше, называемого *ковариантным*:
```scala
type     CovariantHom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[A] => G[B])
type ContravariantHom[F[_], G[_]] = [A, B] => (F[A] => F[B]) => (G[B] => G[A])
//                                                                 ↑       ↑
```


Контравариантные функторы иногда удобнее воспринимать как обычные, ковариантные, но в которых исходная категория заменена на **дуальную** (см. предыдущую часть обзора):
$$
F_{contaV}(\mathcal{C}, \mathcal{D}) \equiv F_{coV}(\mathcal{C}^{op}, \mathcal{D})
$$
Для двух заданных категорий обычно не ставится вопрос «какой вариантности функтор между ними выбрать?» Скорее приходится выяснять, если между ними можно построить функтор, то он будет ко- или контравариантным.

> Латинская приставка «co-» часто переводится на русский язык как (внезапно!) «со-». Например, «**ко**оператив» — это по сути «**со**вместная деятельность». В теории категорий многие термины имеют такую приставку потому, что отражают *дуальность* соответствующих понятий. Это означает, что с такими понятиями непременно **со**седствует аналогичное, полученное путём обращения всех морфизмов, участвующих в определении. Примеры: копроизведение, копредел, коконец и т.п.
> Но есть и исключения из этого правила. Двойственную категорию часто снабжают приставкой «op» от «oposite» — противоположный. (Видимо, англоязычной аудитории не понравилось, как звучит слово «cocategory». Впрочем, «коконцы» совсем не парят русскоговорящих)))
> А вот для вариантности функторов смысл приставки «ко-» хоть и сохраняет основную идею, но несёт немного другую семантику. **Ко**вариантный функтор преобразует морфизмы **со**направленно, в то время как **контра**вариантный меняет направление морфизмов на **встречное**.

Если исходная и конечная категории фиксированы, то между ними можно построить либо ковариантный функтор, либо контравариантный, либо ни тот, ни другой. И только в очень редких случаях можно построить оба типа функтора. Нас прежде всего интересуют такие подкатегории типов, которые определяются конкретным конструктором типов `F[_]`. Очевидно, что вариантность функторов между двумя такими категориями будет определятся только устройством их конструкторов типов.

За точку отчёта принято брать общую категорию типов. Тогда очевидно, что функтор между ней и подкатегорией на основе `Id[_]` будет ковариантным. Также ковариантными будут функторы между любыми подкатегориями, основанными на `Id`, `List`,  `Option`, `Reader`, `Witer` и проч. С другой стороны, контравариантными будут функторы между этими же категориями, и, например, основанной на таких конструкторах типов:
```scala
type ToString = [A] =>> A => String
type ToInt    = [A] =>> A => Int
```

## !!! Продемонстрировать!!!

А вот функтор между этими двумя категориями будет снова ковариантным!

## !!! Продемонстрировать!!!

И последний пример вариантности. Для подкатегории, основанной на следующем конструкторе типов не получится построить ни ко- ни контравариантный функтор:
```scala
type Inv = [A] =>> A => A
```

Получается, что вариантность функторов выделяет из конструкторов типов классы, в каждом из которых функторы между соответствующими подкатегориями будут ковариантными, а функторы *между* классами окажутся контравариантными. Вариантность функторов переносится на конструкторы типов!

В предыдущем обзоре обобщённых типов [говорилось](https://habr.com/ru/articles/807467/#variance), что вариантность конструкторов типов однозначно определяется «знаками позиций» типа параметра. Если одно упоминание параметра находится слева нечётного количества стрелок `=>` (т.е. нечётное количество раз является аргументом функций), то его позиция *отрицательная*, а иначе — положительная. Если позиции всех упоминаний параметра положительные (`Id`,  `Option` и проч.), то обобщённый тип называется ковариантным, а если все отрицательные (`ToString`, `ToInt`) — контравариантным. Если же в определении параметры встречаются в позициях с разными знаками (`Inv`), такой обобщённый тип будет *инвариантным*.

В Scala можно явно проставить у типа параметра его знак, если он одинаковый для всех упоминаний в определении типа:
```scala
type ToString[-A] =         A       => String   // `A` упомянут левее ОДНОЙ стрелки
type MyOption[+A] = [X] => (A => X) => (X => X) // `A` упомянут левее ДВУХ  стрелок 
```
Если знак указан явно, то его придётся учитывать в некоторых случаях композиции конструкторов типов, когда у компилятора не будет возможности выяснить знак самостоятельно.

Почему так важны пресловутые «знаки позиций» типа-параметра для определения класса вариантности конструктора типа будет рассказано позднее в этой части обзора.



[Контравариантный функтор в Scala Cats](https://habr.com/ru/companies/otus/articles/568096/)




# Эндофункторы

Выше был показан пример функтора между подкатегориями `Option` и `List`, который абсолютно бесполезен на практике))). Он был нужен для демонстрации концепции функтора. Дело в том, что реализация вручную функций вида `F[A] => F[B]` — занятие весьма неблагодарное, приводящие к многократному копированию шаблонного кода. Гораздо проще определять функции вида `A => B`, чтобы потом их «поднимать» их в подкатегорию `F[_]` с помощью функтора `Hom[Id, F]`. Именно такие упрощённые функторы и получили распространение в программировании:
```scala
type Functor[F[_]] = Hom[Id, F]
```

Этот функтор связывает общую категорию типов с её подкатегорией, значит он начинается и заканчивается во всё той же категории типов! Функторы, чьи начальная и конечная категория совпадают, называются *эндофункторами*. Замечательным свойством эндофункторов является то, что их можно применять многократно, переходя ко всё более глубоким слоям «матрёшки» подкатегорий. А за «разматрёшивание» отвечает как раз концепция монады, которая и будет основным объектом изучения в данном обзоре. Но мы придём к ней позднее.

Тип `Functor`, так же как и `Hom` для подкатегорий типов, удобнее использовать как класс типов, неявно передавая его экземпляры через контекст. С ним удобно использовать такие методы расширения:
```scala
extension [A, B](f: A => B)
  inline def lift[F[_]: Functor as functor]: F[A] => F[B] =
    functor(f)

extension[F[_]: Functor as functor, A] (fa: F[A])
  inline def map[B](f: A => B): F[B] =
    f.lift[F](fa)
```

В данном случае метод `lift` не просто отображает функции, как `fmap`, но «поднимает» их в подкатегорию `F`. На практике же по привычке чаще используют более императивный метод `map`, *отображающий* значения `F[A]` в `F[B]` с помощью функции `A => B`.

## !!! Продемонстрировать!!!

При обсуждении функторов иногда говорят о «подъёме» не только функций, но и самих значений: `lift: A => F[A]`.  В Haskell есть так называемый «pointed functor» — стандартный эндофунктор, дополненный функцией `point`, «поднимающей» значения. Но на самом деле эта функция не имеет прямого отношения к функторам между подкатегориями типов. Аналогичные функции можно найти и в Scala, например, у так называемого аппликативного функтора, но это также имеет мало отношения к категориальным функторам)).

Конструкторов типов (`Option`, `List`, …) часто самих некорректно называют функторами. Причина кроется в тяжёлом наследии языка Haskell — основоположника статически типизированного функционального программирования. Дело в том, что там у классов типов допускается только единственная реализация. То есть, даже для типа целых чисел в Haskell не получится сделать разные реализации моноида (только через извращения).

Получается, что с каждым конструктором типов в Haskell может ассоциироваться единственный экземпляр эндофунктора. В этом случае и не будет большой ошибкой конструкторы типов попросту называть (эндо)функторами. К сожалению, эта привычка глубоко укоренилась в сознании программистов и часто мешает пониманию простых идей, лежащих в фундаменте всех этих инструментов…



# Бифункторы

В предыдущей части обзора **упоминалось**, что из двух любых категорий всегда можно построить новую, которая будет называться произведением категорий. Её объектами будут пары объектов, а морфизмами — пары морфизмов.

Функтор из произведения категорий типов в другую категорию называется **бифунктором** (латинская приставка «bi-» можно перевести как «двойной»). В случае категорий типов бифунктор определяется двухпараметрическим конструктором типов:
```scala
type Bi[A, B] // (*, *) => *
```
Он переводит объекты категориального произведения в категорию типов. Сам же функтор должен преобразовывать морфизмы. Соответсвующий hom-тип будет иметь вид
```scala
type Bifunctor[Bi[_, _]] = [A, B, C, D] => (A => C, B => D) => (Bi[A, B] => Bi[C, D])
```
Композиция с эндофункторами в категории типов определяются очевидным образом. 

У контравариантного бифунктора (если он вдруг кому-то нужен))) в паре исходных морфизмов будут переставлены параметры.

Для бифунктора причны такие методы расширения:
```scala
extension [A, B, C, D] (fg: (A => C, B => D))
  inline def fbimap[Bi[_, _]: Bifunctor as bifunctor] = bifunctor[A, B, C, D].tupled(fg)

extension [Bi[_, _]: Bifunctor as bifunctor, A, B] (biab: Bi[A, B])
  inline def bimap[C, D](f: A => C, g: B => D) = bifunctor(f, g)(biab)
```

Самые важные бифункторы связаны с суммой и произведением типов:
```scala
infix type + = [A, B] =>>  A Either B
infix type × = [A, B] =>> (A   ,    B)
//             ↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑↑↑
//         произведение     категория
//          категорий         типов
```

Классы типов `Bifunctor` реализуются для них так:
```scala
given sumBifunctor: Bifunctor[+] =
	[A, B, C, D] => (f: A => C, g: B => D) => (ab: A + B) =>
		ab.map(g).left.map(f)

given prodBifunctor: Bifunctor[×] =
	[A, B, C, D] => (f: A => C, g: B => D) => (ab: A × B) =>
		f(ab._1) -> g(ab._2)
```


## !!! Диагональный функтор

Что делает диагональный функтор?

- Он "встраивает" категорию C в произведение C × C по диагонали.

## !!! Мультифункторы





# Профункторы

# Инвариантные функторы

[Инвариантный функтор в Scala Cats](https://habr.com/ru/companies/otus/articles/568118/)
[FP на Scala: Invariant Functor](https://habr.com/ru/companies/golovachcourses/articles/267087/)
https://typelevel.org/cats/typeclasses/invariant.html
https://ncatlab.org/nlab/show/invariant

# Функторы для суммы, произведения и экспоненциала

## !! Почему на вариантность влияет знак позиции параметра
## !! представление Чёрча для суммы и произведения (сохранение вариантности)



# Промежуточный итог

## !!! Про наследование классов типов!

Иногда Functor наследуют от Invariant #facepalm


## !!! Про называние `F[_]` функтором

