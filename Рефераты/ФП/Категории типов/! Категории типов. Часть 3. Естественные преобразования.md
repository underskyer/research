         
Это третья часть обзора и она всё также вводная)). **В первой** было рассказано о категориях типов, а **во второй** — о категории подкатегорий типов с её морфизмами-функторами. В этот же раз нам предстоит разобраться, как эти самые функторы взаимодействуют между собой.

# Мотивация

Для компьютерных программ необходимо построить путь вычислений как композицию различных *функций* так, чтобы на вход подавалось значение типа начальных условий, и в конце формировалось значение целевого типа. Когда мы работаем в единственной категории типов, то тут всё очевидно — любые морфизмы-функции, связанные друг с другом промежуточными типами-состояниями, композируются в цепочку посредством последовательного применения:
```scala
val f: A => B = ???
val g: B => C = ???
val h: C => D = ???

val program: A => D = (a: A) => h(g(f(a))) // val program = h compose g compose f
```

Стремление повысить (в самом широком смысле) качество программ приводит к необходимости, прокладывать пути функциональных вычислений через разные категории. В этом нам помогают функторы, которые в нашем случае сами являются функциями — они применяются к морфизмам одной категории, чтобы получить морфизмы другой. Но этого не достаточно!

Помимо преобразования между категориями морфизмов-функций, необходимо также преобразовывать и сами объекты. Проще говоря, нам нужны *функции между объектами разных категорий*. Для подкатегорий F-типов в общем случае это будут профункторы вида `type ProfFG[A, B] = F[A] => G[B]` и аналогичные им. Но с такими конструкциям не очень-то удобно работать. К профункторам мы ещё вернёмся в дальнейшем, а сейчас нам будет достаточно рассмотреть более простые функции:
```scala
infix type ~>[F[_], G[_]] = [X] => F[X] => G[X]
```

Это *полиморфные функции*, единообразно работающие для любого типа `X` — объекта категории типов. Например,
```scala
val lstToOpt: List ~> Option =
  [A] => (lstA: List[A]) => lstA.headOption

optToList(List(42)) // Some(42)
```

Оказывается, что не все такие функции одинаково полезны. Ранее мы уже рассматривали возможности функторов, переводящих морфизмы одной категории в другую, и в частности, функции `A => B` в `F[A] => F[B]`. Функторы позволяют существенно упростить программный код, и не хотелось бы упускать это преимущество. Однако, некоторые реализации преобразований вида `F ~> G` ведут себя «неестественно» по отношению к выбранным функторам, внося непредсказуемость в цепочки вычислений. Чтобы избежать таких проблем, необходимо ввести дополнительные законы, согласующие эти преобразования с функторами. Функции `F ~> G`, удовлетворяющие таким законам, имеют устоявшееся название —


# Естественные преобразования

Чтобы понять, как подобные преобразования могут согласоваться с функторами рассмотрим следующую категориальную диаграмму:
![[Естеств.png|Красными волнистыми стрелками обозначены естественное преобразование $\alpha$ для функторов $F$ и $G$, а также его компоненты — обычные функции $\alpha_a$ и $\alpha_b.$|800]]
Здесь стрелки $F$ и $G$ — это два *разных* функтора, действующих между категориями $\mathcal{C}$ и $\mathcal{D}$. Функторы переводят морфизмы $f$ из исходной категории в *разные* морфизмы конечной. В категории $\mathcal{D}$ морфизмы образуют квадратный ориентированный граф, демонстрирующий наличие двух путей между $F\, a$ и $G\, b$, отличающихся тем, когда именно применяется преобразование $\alpha$ — до или после «поднятого» морфизма $f$.

Было бы здорово, если бы эта диаграмма коммутировала, то есть оба эти пути были одинаковыми. Ведь тогда, имея скомпозированный морфизм из $F\, a$ в $G\, b$, не было бы причины уточнять, как он устроен, и его поведение было бы более *предсказуемым*.

Условие коммутативности данной диаграммы накладывается на преобразование $\alpha$, которое в таком случае можно называть *естественным* по отношению к функторам $F$ и $G$.

Касательно программирования, мы чаще всего имеем дело с естественными преобразованиями между эндофункторами категории типов. Так что в коде условие естественности можно формально записать так:
```scala
val f: A => B = ???

given   listFunctor: Functor[List  ] = [A, B] => (f: A => B) => (_: List  [A]).map(f) // встроенный метод
given optionFunctor: Functor[Option] = [A, B] => (f: A => B) => (_: Option[A]).map(f) // встроенный метод

val α: Option ~> List = [A] => (optA: Option[A]) => optA.toList                       // встроенный метод

val path1: Option[A] => List[B] = α[B] compose f.lift[Option]
val path2: Option[A] => List[B] = f.lift[List] compose α[A]

assert(path1(optA) == path2(optA)) // для любых optA: Option[A]
```

Если наше преобразование кристально чистое и универсально полиморфное, не гарантирует ли это его естественность автоматически? На самом деле нет. Приведённое выше преобразование вполне себе естественно для пары функторов, представленных встроенными методами `List.map` и `Option.map`. Но если первый функтор заменить на `darkFunctor: Functor[List]` из **предыдущей части обзора**, то естественность сразу теряется:
### !!! ПРИМЕР

Для `darkFunctor` (в паре с `Option.map`) естественным будет такое преобразование:
### !!! ПРИМЕР
Очевидно, что оно уже неестественно для варианта с `List.map`.

Замечу также, что фраза «естественное преобразование функторов» не совсем корректна, так как с его помощью мы не преобразуем существующий функтор, получая новый. Тем не менее, условие естественности говорит нам, что для такого преобразования обязательно должны быть заданы не только пара категорий, но и два сонаправленных функтора между ними.

### !!! Ссылки
https://bartoszmilewski.com/2015/04/07/natural-transformations/




# Категории функторов

Полиморфные функции `F ~> G` композируются между собой и с их помощью можно построить *ещё одну* категорию подкатегорий типов (используется класс типов `Category`, **определённый в предыдущей части**):
```scala
val cat: Category[~>] = (
  identity = [F[_]] => () =>
    [A] => (fa: F[A]) => fa,
  compose  = [F[_], G[_], H[_]] => (gh: G ~> H, fg: F ~> G) =>
    [A] => (fa: F[A]) => (gh[A] compose fg[A])(fa)
)

extension [H[_], G[_]] (gh: G ~> H)(using cat: Category[~>])
  @targetName("verticalComposition")
  infix def ⋅[F[_]](fg: F ~> G): F ~> H = cat.compose(gh, fg)
```
Cимвол `⋅` для композиции естественных преобразований позаимствован из **книги МакЛейна** (также **поступил и Милевски**). Вот пример использования:
```scala
val idToList: Id   ~> List   = [A] => (a: A) => List(a)
val lstToOpt: List ~> Option = [A] => (lstA: List[A]) => lstA.headOption    
val idToOpt:  Id   ~> Option = lstToOpt ⋅ idToList

idToOpt(42) // Some(42)
```

Частным случаем `F ~> G` будут и естественные преобразования. Они также являются морфизмами в определённой только что категории, но любопытно то, что их ещё можно рассматривать в качестве морфизмов в *категории функторов*!

Действительно, рассмотрим такую диаграмму:

![[Pasted image 20250608180811.png]]
### !!! перерисовать !!!

Преобразование $\alpha$, заданное для функторов $F$ и $G$, можно скомпозировать с $\beta$,  определённом для $G$ и $H$. При этом получается преобразование $\gamma$ для функторов $F$ и $H$. Причём композиция получается ассоциативная и уважающая тождественное преобразование.

Объектами полученной категории являются все возможные функторы, но только между двумя фиксированными категориям. Например, категорию образуют все возможные *значения* эндофукнкторов `Functor[F]` для всех конструкторов типов `F[_]`. Hom-типы в таких категориях будут зависеть от значений-функторов, но, думаю, тему зависимых типов лучше будет раскрыть в другом обзоре.

https://bartoszmilewski.com/2017/09/06/monads-monoids-and-categories/


# 2-категория и эдофункторы

Структура категории категорий оказывается очень богатой. Морфизмами здесь являются функторы, которые в свою очередь образуют свою категорию с помощью естественных преобразований. Получается такая иерархия:
- категории — 0-ячейки;
- функторы — 1-ячейки (1-морфизмы);
- естественные преобразования — 2-ячейки (2-морфизмы).

Это и привело к появлению нового термина — «2-категория». Если возникнет необходимость, то технически возможна и категория естественных преобразований с новым видом морфизмов (3-ячейки) и так далее по индукции. Идея в том, что на каждом (кроме нулевого) уровне иерархии объекты являются одновременно и морфизмами в предыдущей категории. В этом смысле уровни аналогичны друг другу, что упрощает работу с ними. Таким образом в теории категорий и появляются N-категории. В прочем, в программировании обычно достаточно только второго уровня. 

«Богатство» 2-категории обусловлено *взаимодействием морфизмов* из разных уровней между собой. Например, выше мы уже видели, что 2-ячейки (естественные преобразования) могут выступать в качестве морфизмов между 0-ячейками (категориями конструкторов типов). А сейчас мы рассмотрим другие аспекты такого взаимодействия.

Пожалуй, наиболее интересной является возможность композиции двух независимых естественных преобразований, от четырёх разных функторов.
![[9_horizontal.jpg|Горизонтальная композиция естественных преобразовании]]
## !! Перерисовать!

```scala
extension[F1[_], F2[_]] (α: F1 ~> F2)
  @targetName("horizontalComposition")
  infix def ∘[G1[_], G2[_]: Functor](β: G1 ~> G2): (G1 ∘ F1) ~> (G2 ∘ F2) =
    [A] => (fga: (G1 ∘ F1)[A]) => (α[A].lift[G2] compose β[F1[A]])(fga)
```

# Изоморфизм функторов



# !! преобразования для контравариантных функторов

# Применение (вместо заключения)
## !!! упомянуть свободные контейнеры

