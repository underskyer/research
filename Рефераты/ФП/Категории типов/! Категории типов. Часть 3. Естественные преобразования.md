         
Это третья часть обзора и она всё также вводная)). **В первой** было рассказано о категориях типов, а **во второй** — о категории подкатегорий типов с её морфизмами-функторами. В этот же раз нам предстоит разобраться, как эти самые функторы взаимодействуют между собой.

Эта часть обзора опирается в основном на публикацию Бартоша Милевски [Natural Transformations](https://bartoszmilewski.com/2015/04/07/natural-transformations/).



# Мотивация

Для компьютерных программ необходимо построить путь вычислений как композицию различных *функций* так, чтобы на вход подавалось значение типа начальных условий, и в конце формировалось значение целевого типа. Когда мы работаем в единственной категории типов, то тут всё очевидно — любые морфизмы-функции, связанные друг с другом промежуточными типами-состояниями, композируются в цепочку посредством последовательного применения:
```scala
val f: A => B = ???
val g: B => C = ???
val h: C => D = ???

val program: A => D = (a: A) => h(g(f(a))) // val program = h compose g compose f
```

Стремление повысить (в самом широком смысле) качество программ приводит к необходимости, прокладывать пути функциональных вычислений через разные категории. В этом нам помогают функторы, которые в нашем случае сами являются функциями — они применяются к морфизмам одной категории, чтобы получить морфизмы другой. Но этого не достаточно!

Помимо преобразования между категориями морфизмов-функций, необходимо также преобразовывать и сами объекты. Проще говоря, нам нужны *функции между объектами разных категорий*. Для подкатегорий F-типов в общем случае это будут профункторы вида `type ProfFG[A, B] = F[A] => G[B]` и аналогичные им. Но с такими конструкциям не очень-то удобно работать. К профункторам мы ещё вернёмся в дальнейшем, а сейчас нам будет достаточно рассмотреть более простые функции:
```scala
infix type ~>[F[_], G[_]] = [X] => F[X] => G[X]
```

Это *полиморфные функции*, единообразно работающие для любого типа `X` — объекта категории типов. Например,
```scala
val lstToOpt: List ~> Option =
  [A] => (lstA: List[A]) => lstA.headOption

optToList(List(42)) // Some(42)
```

Оказывается, что не все такие функции одинаково полезны. Ранее мы уже рассматривали возможности функторов, переводящих морфизмы одной категории в другую, и в частности, функции `A => B` в `F[A] => F[B]`. Функторы позволяют существенно упростить программный код, и не хотелось бы упускать это преимущество. Однако, некоторые реализации преобразований вида `F ~> G` ведут себя «неестественно» по отношению к выбранным функторам, внося непредсказуемость в цепочки вычислений. Чтобы избежать таких проблем, необходимо ввести дополнительные законы, согласующие эти преобразования с функторами. Функции `F ~> G`, удовлетворяющие таким законам, имеют устоявшееся название —


# Естественные преобразования

Чтобы понять, как подобные преобразования могут согласоваться с функторами рассмотрим следующую категориальную диаграмму:
![[Естеств.png|Красными волнистыми стрелками обозначены естественное преобразование $\alpha$ для функторов $F$ и $G$, а также его компоненты $\alpha_a$ и $\alpha_b.$ — обычные морфизмы в категории $\mathcal{D}.$|800]]
### !! перерисовать стрелку f горизонтально

Здесь стрелки $F$ и $G$ — это два *разных* функтора, действующих между категориями $\mathcal{C}$ и $\mathcal{D}$. Функторы переводят морфизмы $f$ из исходной категории в *разные* морфизмы конечной. В категории $\mathcal{D}$ морфизмы образуют квадратный ориентированный граф, демонстрирующий наличие двух путей между $F\, a$ и $G\, b$, отличающихся тем, когда именно применяется преобразование $\alpha$ — до или после «поднятого» морфизма $f$.

Было бы здорово, если бы эта диаграмма коммутировала, то есть оба эти пути были одинаковыми. Ведь тогда, имея скомпозированный морфизм из $F\, a$ в $G\, b$, не было бы причины уточнять, как он устроен, и его поведение было бы более *предсказуемым*.

Условие коммутативности данной диаграммы накладывается на преобразование $\alpha$, которое в таком случае можно называть *естественным* по отношению к функторам $F$ и $G$.

Касательно программирования, мы чаще всего имеем дело с естественными преобразованиями между эндофункторами категории типов. Так что в коде условие естественности можно формально продемонстрировать так:
```scala
val f: A => B = ???

given   listFunctor: Functor[List  ] = [A, B] => (f: A => B) => (_: List  [A]).map(f) // встроенный метод
given optionFunctor: Functor[Option] = [A, B] => (f: A => B) => (_: Option[A]).map(f) // встроенный метод

val α: List ~> Option = [A] => (lstA: List[A]) => lstA.headOption                     // встроенный метод

val path1: List[A] => Option[B] = f.lift[Option] compose α[A]
val path2: List[A] => Option[B] = α[B] compose f.lift[List]

assert(path1(lstA) == path2(lstA)) // для любых lstA: List[A]
```

Если наше преобразование кристально чистое и универсально полиморфное, не гарантирует ли это его естественность автоматически (как это написано у Милевски)? На самом деле нет. Приведённое выше преобразование вполне себе естественно для пары функторов, представленных встроенными методами `List.map` и `Option.map`. Но если первый функтор заменить на `darkFunctorList: Functor[List]` из **предыдущей части обзора**, то естественность сразу теряется:
```scala
// если в контексте лежат darkFunctorList и обычный optionFunctor из предыдущего примера,
// тогда эти два пути уже не коммутируют!
val path1: List[String] => Option[Int] = f.lift[Option] compose α[String]
val path2: List[String] => Option[Int] = α[Int] compose f.lift[List]

val lstString = List("list", "42")

path1(lstString)  // Some(4)
path2(lstString)  // Some(2)
```

Для `darkFunctor` (в паре с `Option.map`) естественным будет такое  тривиалььное преобразование:
```scala
val β: List ~> Option = [A] => (_: List[A]) => None
```
Оно будет также естественным и для варианта с `List.map`, но пользы от него, очевидно, не много.

Естественные преобразования являются морфизмами между функторами, но с их помощью мы *не преобразуем существующие функторы*, получая новые. Тем не менее, условие естественности говорит нам, что для такого преобразования обязательно должны быть заданы не только пара категорий, но и два сонаправленных функтора между ними.




# Категории функторов

Полиморфные функции `F ~> G` композируются между собой и с их помощью можно построить *ещё одну* категорию подкатегорий типов (используется класс типов `Category`, **определённый в предыдущей части**):
### !!!! здесь и далее использовать для естественных преобразований символы α и β
```scala
val cat: Category[~>] = (
  identity = [F[_]] => () =>
    [A] => (fa: F[A]) => fa,
  compose  = [F[_], G[_], H[_]] => (gh: G ~> H, fg: F ~> G) =>
    [A] => (fa: F[A]) => (gh[A] compose fg[A])(fa)
)

extension [H[_], G[_]] (gh: G ~> H)(using cat: Category[~>])
  @targetName("verticalComposition")
  infix def ⋅[F[_]](fg: F ~> G): F ~> H = cat.compose(gh, fg)
```
Cимвол `⋅` для композиции естественных преобразований позаимствован из **книги МакЛейна** (также **поступил и Милевски**). Вот пример использования:
```scala
val idToList: Id   ~> List   = [A] => (a: A) => List(a)
val lstToOpt: List ~> Option = [A] => (lstA: List[A]) => lstA.headOption    
val idToOpt:  Id   ~> Option = lstToOpt ⋅ idToList

idToOpt(42) // Some(42)
```

Частным случаем `F ~> G` будут и естественные преобразования. Они также являются морфизмами в определённой только что категории, но любопытно то, что их ещё можно рассматривать в качестве морфизмов в *категории функторов*!

Действительно, рассмотрим такую диаграмму:

![[вертикальная композиция.png|Композиция естественных преобразований.|1000]]

### !! перерисовать: α ⋅ β заменить на β ⋅ α; добавить стрелку (β ⋅ α)ₐ (изменить цвета стрелок?)

Здесь подразумевается, что прямоугольник $Fb\;Hb\;Ha\;Fa$ коммутирует — все пути от $Fa$ до $Hb$ эквивалентны. Преобразование $\alpha$, заданное для функторов $F$ и $G$, можно скомпозировать с $\beta$,  определённом для $G$ и $H$, при этом получается преобразование $\alpha \cdot \beta$ между функторами $F$ и $H$. Композиция получается ассоциативная и уважающая тождественное преобразование.

Объектами категории, основанной на такой композиции, являются все возможные функторы, но только между двумя фиксированными категориям. Например, категорию образуют все возможные *значения* эндофукнкторов `Functor[F]` для всех конструкторов типов `F[_]`. Hom-типы в таких категориях будут зависеть от значений-функторов, так что в данном обзоре мы обойдём эту тему.


# 2-категория и эдофункторы

Структура категории категорий оказывается очень богатой. Морфизмами здесь являются функторы, которые в свою очередь образуют свою категорию с помощью естественных преобразований. Получается такая иерархия:
- категории — 0-ячейки;
- функторы — 1-ячейки (1-морфизмы);
- естественные преобразования — 2-ячейки (2-морфизмы).

Это и привело к появлению нового термина — «2-категория». Если возникнет необходимость, то технически возможна и категория естественных преобразований с новым видом морфизмов (3-ячейки) и так далее по индукции. Идея в том, что на каждом (кроме нулевого) уровне иерархии объекты являются одновременно и морфизмами в предыдущей категории. В этом смысле уровни аналогичны друг другу, что упрощает работу с ними. Таким образом в теории категорий и появляются N-категории. В прочем, в программировании обычно достаточно только второго уровня. 

«Богатство» 2-категории обусловлено *взаимодействием морфизмов* из разных уровней между собой. Например, выше мы уже видели, что 2-ячейки (естественные преобразования) могут выступать в качестве морфизмов между 0-ячейками (категориями конструкторов типов). А сейчас мы рассмотрим другие аспекты такого взаимодействия.

Пусть у нас есть две пары функторов $F,\, F': \mathcal{C} \rightarrow \mathcal{D}$ и $G,\, G': \mathcal{D} \rightarrow \mathcal{E}$,  а также пара естественных преобразований $\alpha: F \rightsquigarrow F'$ и $\beta: G \rightsquigarrow G'$. Функторы первой пары приводят в категорию $\mathcal{D}$, из которой исходят функторы второй пары. Следовательно, функторы из разных пар можно композировать между собой. Оказывается, что в таком случае можно построить такую «горизонтальную» композицию естественных преобразований $\beta \circ \alpha: G \circ F \rightsquigarrow G' \circ F'$:
![[горизонтальная композиция эскиз.png]]

Само же устройство горизонтальной композиции проще понять, если эту диаграмму развернуть так:
![[горизонтальная композиция.png|Горизонтальная композиция естественных преобразования.|1000]]

Здесь в середине мы получаем «волнистый квадрат» естественных преобразований c диагональю $\beta \circ \alpha$. Эта диагональ отражает коммутативность квадрата — оба пути от $G \circ F$ к $G' \circ F'$ эквивалентны. Запись $G\, \alpha$ обозначает естественное преобразование, получаемое действием функтора $G$ на *каждую* компоненту-функцию $\alpha_a: F\, a \rightarrow F'\, a$.

Для эндофункторов в категории типов горизонтальную композицию естественных преобразований можно записать так:
```scala
extension[F1[_], F2[_]] (α: F1 ~> F2)
  @targetName("horizontalComposition")
  infix def ∘[G1[_], G2[_]: Functor](β: G1 ~> G2): (G1 ∘ F1) ~> (G2 ∘ F2) =
    [A] => (gfa: (G1 ∘ F1)[A]) => (α[A].lift[G2] compose β[F1[A]])(gfa)
```
При реализации нужен лишь один функтор. Здесь выбран «нижний» путь на квадрате, поэтому потребовался только `Functor[G2]`. Но всегда помним, что при работе с двумя естественными преобразованиями подразумевается наличие всех четырёх функторов.

Две разные композиции естественных преобразований называются «вертикальной» и «горизонтальной» от части потому, что они действуют в как бы «перпендикулярных измерениях», не влияя друг на друга. Композиции, как бинарные операции, удовлетворяют так называемому «обменному» (interchange) закону:

$$
(\alpha \cdot \beta)   \circ (\alpha' \cdot \beta') =
(\alpha \circ \alpha') \cdot (\beta   \circ \beta')
$$

Это взаимоотношение естественных преобразований можно визуализировать так:
![[взаимодействие композиций.png]]

То есть, порядок применения композиций не важен, важно лишь, чтобы сохранилось первоначальное расположение операндов относительно каждого оператора (что было «слева» должно остаться «слева» и наоборот).

# Преобразования для контравариантных функторов

Выше были представлены естественные преобразования для ковариантных функторов. Оказывается, аналогичные преобразования можно построить и для контравариантных. Только условие естественности будет отличаться от введённого ранее:

### !!! рисунок!

```scala
val f: A => B = ???
val α: F ~> G = ???
//                                     было A ↓
val path1: F[A] => G[B] = f.lift[G] compose α[B] // требуется Contravariant[G]
val path2: F[A] => G[B] = α[A] compose f.lift[F] // требуется Contravariant[F]
//                          ↑ было B

assert(path1(fA) == path2(fA)) // для любых fa: F[A]
```

Если же вариантности функторов различаются, а также, если хотя бы один из них инвариантный, то для них уже не получится определить что-то похожее на естественные преобразования. Тем не менее, такие функторы можно трактовать как *профункторы*, для которых вводится понятие *диестественного* преобразования. Но об этом будет удобнее поговорить в продолжении обзора, когда мы будем рассматривать *концы профункторов*.

# !!! The Moment of Zen

You might ask yourself the question: Why should I care whether some diagrams commute or not? In particular, why are natural transformations better than the “unnatural” ones? Why is it important that naturality diagrams commute? There must be something incredibly deep behind this idea of commutativity to make it pop up in so many diverse branches of mathematics unified by category theory.

Indeed, the very definition of category contains the mother of all commuting diagrams: The condition that, if there is a morphism from A to B and another from B to C, then there is a shortcut morphism from A to C, and it doesn’t matter which way you go. This is the essence of composability: you decompose the path from A to C into its components.

Every programmer is familiar with the idea of functional decomposition, but this pattern goes much deeper than just programming. It’s the essence of our knowledge, of our understanding. We don’t understand anything unless we are able to split it into smaller steps and then put these steps back together — compose them. Without composition we can’t deal with complexity.

The other foundation of understanding is the ability to create models. We create simple models of complex phenomena all the time. By understanding how models work, we gain insight into how complex phenomena work. But for that we need to establish the correspondence, the mapping, between the domain of the model and the domain of the phenomenon that we’re studying. And what’s the most important property of that mapping? Well, our understanding of the model is built on our understanding of its parts and of the ways they compose. So the mapping must preserve composability! Mappings that preserve composability are called functors.

We’ve used some very simple categories as our models. The {1, 2} category modeled the selection of two objects. We used a functor to embed this model into a bigger category C. In that particular case, there wasn’t much structure for the functor to preserve. The model for the equilizer, on the other hand, was a bit more involved. Besides the two objects, it also had two parallel arrows. The functor that embedded this model had to map those arrows as well.

If functors are used for modeling, what are natural transformations? They relate different phenomena described by the same model.

A stick figure is a model for a human being. It can be mapped into Alice, or it can be mapped into Bob. A natural transformation would map Alice into Bob in such a way as to preserve the stick-figure structure. So if the circle is mapped into Alice’s head by one functor, and into Bob’s head by another, a natural transformation would map Alice’s head into Bob’s head.

The model tells us that there is a neck between the head and the torso. So we could use Alice’s neck to go from her head to her torso, and then map her torso to Bob’s torso using the natural transformation. But we could also map Alice’s head to Bob’s head using the natural transformation, and then use Bob’s neck to get to his torso. Naturality tells us that it doesn’t matter which way we go, the result is the same.

We also have the constant functor, which maps the model into a single blob. A natural transformation then maps this blob into Bob; again, with the condition that it doesn’t matter whether we reach Bob’s torso from the blob through his right hand and arm or through his left hand and arm.

Now take into account that, although the stick figure is just made of points and lines, it is mapped into real human beings and real blobs. So a morphism from a blob to Bob’s hand is not trivial, and there may be many different ones. Similarly, the arm that connects the hand to the torso contains veins, arteries, nerves, etc. So naturality is a non-trivial condition, especially if the blob itself is complex.

So what is special about the universal blob? It has to have some interesting internal structure because it not only maps into every part of Bob, but it maps better than any other blob. Any other blob that maps naturally into Bob also maps into the universal blob. And it maps in such a way that it doesn’t matter if you go directly from the said blob to Bob, or if you go through the universal blob. The universal blob contains the stick-figure essence of Bob, and no other blob (that is not isomorphic to it) can take its place.

Universality tells us something about the structure of an object not by dissecting it but by describing its relationship to other objects that model a certain relationship.
# Применение (вместо заключения)

Функции, действующие как естественные преобразования, используются в программировании повсеместно, когда приходится иметь дело  с обобщёнными типами. Например, вычисление длины списка тоже можно трактовать как естественное преобразование в константный функтор:
```scala
val getLenght: List ~> Const[Int] = [A] => (lst: List[A]) => lst.lenght
```

Да и само создание экземпляра обобщённого типа тоже можно записать как естественное преобразование:
```scala
val pureOption: Id ~> Option = [A] => (a: A) => Some(a)
```

Для «чистой» работы с побочными эффектами нам приходится средствами функторов комбинировать «эффективные» функции, возвращающие значения «в контейнерах» `F[_]`. При этом нужно уметь «разматрёшивать» результаты таких комбинаций `F[F[A]]`. Здесь нас выручают следующие естественные преобразования:
```scala
val flattenList: List ∘ List ~> List = [A] => (lstA: List[List[A]]) => lstA.flatten
//                                                    встроенный метод ↑↑↑↑↑↑↑↑↑↑↑↑
```
Да, это самая характерная способность монады, но о них самих мы поговорим лишь в следующей части обзора.

Ну и, конечно же, вычисление всех побочных эффектов в финале — «распаковка» контейнера `F[_]` — это тоже естественное  преобразование:
```scala
val runUnsafe: IO ~> Id = ???

val myProgram: IO[Int] = ???

val exitCode: Int = runUnsafe(myProgram)
```

Ещё естественные преобразования являются ключевым инструментом в специальной технике программирования основанной на *свободных контейнерах* (монадах). Я уже [рассказывал о них в одном из предыдущих обзоров](https://habr.com/ru/articles/807495/#free)

### !! Спойлер: Напомню

Следуя примерам кода из того обзора выделю следующие моменты.

- Сперва для описания взаимосвязанных бизнес-действий строятся *обобщённые алегбраические типы данных*, вроде `enum UsersRepository[A]`. Они не предоставляют реализации этих действий — только название и описание типов входных параметров и результата. Каждый такой контейнер и считается носителем своего (пока что абстрактного) бизнес-эффекта.
- Эти контейнеры-алгебры объединяются в общий контейнер вида `type TotalAlgebra = UsersRepository :+: SearchServcie :+: NotificationService`.
- Затем эти контейнеры «поднимаются в свободный мир» посредством библиотечных <u>естественных преобразований</u> вида `UsersRepository ~> Free[TotalAlgebra]`.
- В «свободном мире» уже и строится вся программа с помощью стандартных комбинаторов (`map`, `flatMap` и проч.). По сути, это лишь рекурсивная структура данных типа `Free[TotalAlgebra][Result]` — описание последовательности действий.
- Только когда уже готова «свободная» программа-как-данные, для её вычисления требуется предоставить реализацию всех бизнес-действий.
	- Сперва собираются отдельные интерпретаторы — <u>естественные преобразования</u> бизнес-алгебр в целевой контейнер эффектов вида `UsersRepository ~> IO`.
	- Затем из них, опять же, библиотечными методами собирается тотальный интерпретатор — ещё одно <u>естественное преобразование</u> `TotalAlgebra ~> IO`.
- «Свободная программа», будучи рекурсивной структурой, [сворачивается](https://habr.com/ru/articles/863334/) методом `foldMap` с помощью тотального интерпретатора в итоговый результат `IO[Result].`

Но для целей данного обзора более интересными оказываются другие приложения естественных преобразований, а именно
- пределы и копределы, позволяющие конструировать типы на основе описания их универсальных свойств;
- сопряжение функторов, позволяющее, в частности, проанализировать весь базис возможностей построения новых обобщённых типов, а также вывести для них
- монады, которые, в свою очередь, также часто представляют в виде пары естественных преобразований.

Именно эти приложения мы и рассмотрим в следующей части обзора.





