         
Это третья часть обзора и она всё также вводная)). **В первой** было рассказано о категориях типов, а **во второй** — о категории подкатегорий типов с её морфизмами-функторами. В этот же раз нам предстоит разобраться, как эти самые функторы взаимодействуют между собой.

Эта часть обзора опирается в основном на публикацию Бартоша Милевски [Natural Transformations](https://bartoszmilewski.com/2015/04/07/natural-transformations/).



# Мотивация

Для компьютерных программ необходимо построить путь вычислений как композицию различных *функций* так, чтобы на вход подавалось значение типа начальных условий, и в конце формировалось значение целевого типа. Когда мы работаем в единственной категории типов, то тут всё очевидно — любые морфизмы-функции, связанные друг с другом промежуточными типами-состояниями, композируются в цепочку посредством последовательного применения:
```scala
val f: A => B = ???
val g: B => C = ???
val h: C => D = ???

val program: A => D = (a: A) => h(g(f(a))) // val program = h compose g compose f
```

Стремление повысить (в самом широком смысле) качество программ приводит к необходимости, прокладывать пути функциональных вычислений через разные категории. В этом нам помогают функторы, которые в нашем случае сами являются функциями — они применяются к морфизмам одной категории, чтобы получить морфизмы другой. Но этого не достаточно!

Помимо преобразования между категориями морфизмов-функций, необходимо также преобразовывать и сами объекты. Проще говоря, нам нужны *функции между объектами разных категорий*. Для подкатегорий F-типов в общем случае это будут профункторы вида `type ProfFG[A, B] = F[A] => G[B]` и аналогичные им. Но с такими конструкциям не очень-то удобно работать. К профункторам мы ещё вернёмся в дальнейшем, а сейчас нам будет достаточно рассмотреть более простые функции:
```scala
infix type ~>[F[_], G[_]] = [X] => F[X] => G[X]
```

Это *полиморфные функции*, единообразно работающие для любого типа `X` — объекта категории типов. Например,
```scala
val lstToOpt: List ~> Option =
  [A] => (lstA: List[A]) => lstA.headOption

optToList(List(42)) // Some(42)
```

Оказывается, что не все такие функции одинаково полезны. Ранее мы уже рассматривали возможности функторов, переводящих морфизмы одной категории в другую, и в частности, функции `A => B` в `F[A] => F[B]`. Функторы позволяют существенно упростить программный код, и не хотелось бы упускать это преимущество. Однако, некоторые реализации преобразований вида `F ~> G` ведут себя «неестественно» по отношению к выбранным функторам, внося непредсказуемость в цепочки вычислений. Чтобы избежать таких проблем, необходимо ввести дополнительные законы, согласующие эти преобразования с функторами. Функции `F ~> G`, удовлетворяющие таким законам, имеют устоявшееся название —


# Естественные преобразования

Чтобы понять, как подобные преобразования могут согласоваться с функторами рассмотрим следующую категориальную диаграмму:
![[Естеств.png|Красными волнистыми стрелками обозначены естественное преобразование $\alpha$ для функторов $F$ и $G$, а также его компоненты $\alpha_a$ и $\alpha_b.$ — обычные морфизмы в категории $\mathcal{D}.$|800]]
### !! перерисовать стрелку f горизонтально

Здесь стрелки $F$ и $G$ — это два *разных* функтора, действующих между категориями $\mathcal{C}$ и $\mathcal{D}$. Функторы переводят морфизмы $f$ из исходной категории в *разные* морфизмы конечной. В категории $\mathcal{D}$ морфизмы образуют квадратный ориентированный граф, демонстрирующий наличие двух путей между $F\, a$ и $G\, b$, отличающихся тем, когда именно применяется преобразование $\alpha$ — до или после «поднятого» морфизма $f$.

Было бы здорово, если бы эта диаграмма коммутировала, то есть оба эти пути были одинаковыми. Ведь тогда, имея скомпозированный морфизм из $F\, a$ в $G\, b$, не было бы причины уточнять, как он устроен, и его поведение было бы более *предсказуемым*.

Условие коммутативности данной диаграммы накладывается на преобразование $\alpha$, которое в таком случае можно называть *естественным* по отношению к функторам $F$ и $G$.

Касательно программирования, мы чаще всего имеем дело с естественными преобразованиями между эндофункторами категории типов. Так что в коде условие естественности можно формально продемонстрировать так:
```scala
val f: A => B = ???

given   listFunctor: Functor[List  ] = [A, B] => (f: A => B) => (_: List  [A]).map(f) // встроенный метод
given optionFunctor: Functor[Option] = [A, B] => (f: A => B) => (_: Option[A]).map(f) // встроенный метод

val α: List ~> Option = [A] => (lstA: List[A]) => lstA.headOption                     // встроенный метод

val path1: List[A] => Option[B] = f.lift[Option] compose α[A]
val path2: List[A] => Option[B] = α[B] compose f.lift[List]

assert(path1(lstA) == path2(lstA)) // для любых lstA: List[A]
```

Если наше преобразование кристально чистое и универсально полиморфное, не гарантирует ли это его естественность автоматически (как это написано у Милевски)? На самом деле нет. Приведённое выше преобразование вполне себе естественно для пары функторов, представленных встроенными методами `List.map` и `Option.map`. Но если первый функтор заменить на `darkFunctorList: Functor[List]` из **предыдущей части обзора**, то естественность сразу теряется:
```scala
// если в контексте лежат darkFunctorList и обычный optionFunctor из предыдущего примера,
// тогда эти два пути уже не коммутируют!
val path1: List[String] => Option[Int] = f.lift[Option] compose α[String]
val path2: List[String] => Option[Int] = α[Int] compose f.lift[List]

val lstString = List("list", "42")

path1(lstString)  // Some(4)
path2(lstString)  // Some(2)
```

Для `darkFunctor` (в паре с `Option.map`) естественным будет такое  тривиалььное преобразование:
```scala
val β: List ~> Option = [A] => (_: List[A]) => None
```
Оно будет также естественным и для варианта с `List.map`, но пользы от него, очевидно, не много.

Естественные преобразования являются морфизмами между функторами, но с их помощью мы *не преобразуем существующие функторы*, получая новые. Тем не менее, условие естественности говорит нам, что для такого преобразования обязательно должны быть заданы не только пара категорий, но и два сонаправленных функтора между ними.




# Категории функторов

Полиморфные функции `F ~> G` композируются между собой и с их помощью можно построить *ещё одну* категорию подкатегорий типов (используется класс типов `Category`, **определённый в предыдущей части**):
### !!!! здесь и далее использовать для естественных преобразований символы α и β
```scala
val cat: Category[~>] = (
  identity = [F[_]] => () =>
    [A] => (fa: F[A]) => fa,
  compose  = [F[_], G[_], H[_]] => (gh: G ~> H, fg: F ~> G) =>
    [A] => (fa: F[A]) => (gh[A] compose fg[A])(fa)
)

extension [H[_], G[_]] (gh: G ~> H)(using cat: Category[~>])
  @targetName("verticalComposition")
  infix def ⋅[F[_]](fg: F ~> G): F ~> H = cat.compose(gh, fg)
```
Cимвол `⋅` для композиции естественных преобразований позаимствован из **книги МакЛейна** (также **поступил и Милевски**). Вот пример использования:
```scala
val idToList: Id   ~> List   = [A] => (a: A) => List(a)
val lstToOpt: List ~> Option = [A] => (lstA: List[A]) => lstA.headOption    
val idToOpt:  Id   ~> Option = lstToOpt ⋅ idToList

idToOpt(42) // Some(42)
```

Частным случаем `F ~> G` будут и естественные преобразования. Они также являются морфизмами в определённой только что категории, но любопытно то, что их ещё можно рассматривать в качестве морфизмов в *категории функторов*!

Действительно, рассмотрим такую диаграмму:

![[вертикальная композиция.png|Композиция естественных преобразований.|1000]]

### !! перерисовать: α ⋅ β заменить на β ⋅ α; добавить стрелку (β ⋅ α)ₐ (изменить цвета стрелок?)

Здесь подразумевается, что прямоугольник $Fb\;Hb\;Ha\;Fa$ коммутирует — все пути от $Fa$ до $Hb$ эквивалентны. Преобразование $\alpha$, заданное для функторов $F$ и $G$, можно скомпозировать с $\beta$,  определённом для $G$ и $H$, при этом получается преобразование $\alpha \cdot \beta$ между функторами $F$ и $H$. Композиция получается ассоциативная и уважающая тождественное преобразование.

Объектами категории, основанной на такой композиции, являются все возможные функторы, но только между двумя фиксированными категориям. Например, категорию образуют все возможные *значения* эндофукнкторов `Functor[F]` для всех конструкторов типов `F[_]`. Hom-типы в таких категориях будут зависеть от значений-функторов, так что в данном обзоре мы обойдём эту тему.


# 2-категория и эдофункторы

Структура категории категорий оказывается очень богатой. Морфизмами здесь являются функторы, которые в свою очередь образуют свою категорию с помощью естественных преобразований. Получается такая иерархия:
- категории — 0-ячейки;
- функторы — 1-ячейки (1-морфизмы);
- естественные преобразования — 2-ячейки (2-морфизмы).

Это и привело к появлению нового термина — «2-категория». Если возникнет необходимость, то технически возможна и категория естественных преобразований с новым видом морфизмов (3-ячейки) и так далее по индукции. Идея в том, что на каждом (кроме нулевого) уровне иерархии объекты являются одновременно и морфизмами в предыдущей категории. В этом смысле уровни аналогичны друг другу, что упрощает работу с ними. Таким образом в теории категорий и появляются N-категории. В прочем, в программировании обычно достаточно только второго уровня. 

«Богатство» 2-категории обусловлено *взаимодействием морфизмов* из разных уровней между собой. Например, выше мы уже видели, что 2-ячейки (естественные преобразования) могут выступать в качестве морфизмов между 0-ячейками (категориями конструкторов типов). А сейчас мы рассмотрим другие аспекты такого взаимодействия.

Пусть у нас есть две пары функторов $F,\, F': \mathcal{C} \rightarrow \mathcal{D}$ и $G,\, G': \mathcal{D} \rightarrow \mathcal{E}$,  а также пара естественных преобразований $\alpha: F \rightsquigarrow F'$ и $\beta: G \rightsquigarrow G'$. Функторы первой пары приводят в категорию $\mathcal{D}$, из которой исходят функторы второй пары. Следовательно, функторы из разных пар можно композировать между собой. Оказывается, что в таком случае можно построить такую «горизонтальную» композицию естественных преобразований $\beta \circ \alpha: G \circ F \rightsquigarrow G' \circ F'$:
![[горизонтальная композиция эскиз.png]]

Само же устройство горизонтальной композиции проще понять, если эту диаграмму развернуть так:
![[горизонтальная композиция.png|Горизонтальная композиция естественных преобразования.|1000]]

Здесь в середине мы получаем «волнистый квадрат» естественных преобразований c диагональю $\beta \circ \alpha$. Эта диагональ отражает коммутативность квадрата — оба пути от $G \circ F$ к $G' \circ F'$ эквивалентны. Запись $G\, \alpha$ обозначает естественное преобразование, получаемое действием функтора $G$ на *каждую* компоненту-функцию $\alpha_a: F\, a \rightarrow F'\, a$.

Для эндофункторов в категории типов горизонтальную композицию естественных преобразований можно записать так:
```scala
infix type ∘[G[_], F[_]] = [X] =>> G[F[X]]

extension[F1[_], F2[_]] (α: F1 ~> F2)
  @targetName("horizontalComposition")
  infix def ∘[G1[_], G2[_]: Functor](β: G1 ~> G2): (G1 ∘ F1) ~> (G2 ∘ F2) =
    [A] => (gfa: (G1 ∘ F1)[A]) => (α[A].lift[G2] compose β[F1[A]])(gfa)
```
При реализации нужен лишь один функтор. Здесь выбран «нижний» путь на квадрате, поэтому потребовался только `Functor[G2]`. Но всегда помним, что при работе с двумя естественными преобразованиями подразумевается наличие всех четырёх функторов.

Две разные композиции естественных преобразований называются «вертикальной» и «горизонтальной» от части потому, что они действуют в как бы «перпендикулярных измерениях», не влияя друг на друга. Композиции, как бинарные операции, удовлетворяют так называемому «обменному» (interchange) закону:

$$
(\alpha \cdot \beta)   \circ (\alpha' \cdot \beta') =
(\alpha \circ \alpha') \cdot (\beta   \circ \beta')
$$

Это взаимоотношение естественных преобразований можно визуализировать так:
![[взаимодействие композиций.png]]

То есть, порядок применения композиций не важен, важно лишь, чтобы сохранилось первоначальное расположение операндов относительно каждого оператора (что было «слева» должно остаться «слева» и наоборот).

# Преобразования для контравариантных функторов

Выше были представлены естественные преобразования для ковариантных функторов. Оказывается, аналогичные преобразования можно построить и для контравариантных. Только условие естественности будет отличаться от введённого ранее:

### !!! рисунок!

```scala
val f: A => B = ???
val α: F ~> G = ???
//                                     было A ↓
val path1: F[A] => G[B] = f.lift[G] compose α[B] // требуется Contravariant[G]
val path2: F[A] => G[B] = α[A] compose f.lift[F] // требуется Contravariant[F]
//                          ↑ было B

assert(path1(fA) == path2(fA)) // для любых fa: F[A]
```

Если же вариантности функторов различаются, а также, если хотя бы один из них инвариантный, то для них уже не получится определить что-то похожее на естественные преобразования. Тем не менее, такие функторы можно трактовать как *профункторы*, для которых вводится понятие *диестественного* преобразования. Но об этом будет удобнее поговорить в продолжении обзора, когда мы будем рассматривать *концы профункторов*.



# Ещё раз про важность контейнерных вычислений

Те, кто дочитал до этого места, ~~получат бутылку шампанского!~~ наверняка уже знакомы с монадами и понимают, для чего они нужны программистам. И всё же, на всякий случай, напомню)).

Компьютерные алгоритмы исполняются на целом наборе различных физических устройств, да ещё и разнесённых пространстве. Очевидно, что для линейных алгоритмов в каждый момент времени будет работать лишь одно устройство, а остальные будут бездействовать. Поэтому очень важной задачей является снижение времени простоя вычислительных мощностей.

Одним из способов решения этой задачи является *параллельное выполнение* сразу нескольких алгоритмов. В этом случае выше шанс, что в каждый момент времени будет задействовано больше устройств-вычислителей. Однако, возникают другие сложности. Например, из-за конкуренции за ресурсы, происходят блокировки процессов вычислений, что опять же приводит к неэффективному использованию физических устройств и нежелательным задержкам.

Существуют специальные техники программирования, позволяющие добиться *асинхронного выполнения* алгоритмов, не блокирующего доступ к одним ресурсам при временной недоступности других. Эти техники отличаются в основном тем, как именно они *описываются* в выбранном языке программирования, какие требования предъявляются к их описанию.

Для статически типизированного функционального программирования, характерны такие требования к алгоритмам:
- перенос проверки корректности программы на этап компиляции, что обеспечивается максимальным использованием системы типов языка;
- проста, лаконичность и выразительность кода, обеспечивающаяся использованием фундаментальных абстракций.
- предсказуемость поведения (устойчивость к рефакторингу), которую дают «чистота» функций и другие «законы» используемых абстракций.

Всё это приводит тому, что во многих языках программирования асинхронность так или иначе (через «синтаксический сахар») реализуется посредством [контейнерных типов](https://habr.com/ru/articles/807467/) `F[_]`. В экземплярах `F[A]` инкапсулирован *контекст вычисления* целевого значения типа `A`. Например, есть специальные контейнерные типы, обеспечивающие асинхронность вычислений последовательности функций вида `A => F[B]`.

Но, кроме того, есть ещё и другие полезные контейнеры `F[_]`, например, списки и опциональные значения. Отличаются они лишь тем самым пресловутым контекстом вычисления, «эффектом». Копая глубже, можно обнаружить, что и любые другие обобщённые типы специализированы на обработке каких-то своих полезных эффектов. Оказывается, что методы комбинирования вычислений у всех таких контейнеров очень похожи.

На передний план выходит сама техника работы с *абстрактными* контейнерными типами. И прежде всего — техника *композиции вычислений*, производимых как в одном и том же контейнере, так и в разных. Ранее мы уже рассмотрели один из важных элементов этой техники — преобразования, предоставляемые эндофукнторами в категории типов. И вот теперь пришло время представить главного героя данного обзора))).


# !!! Монады

В первую очередь, нам нужно научится композировать «эффективные функции», например  `f: A => F[B]` и `g: B => F[C]`. Если у нас есть экземпляр `Functor[F]`, то можем попробовать сделать так:
```scala
def compose[F[_]: Funcor, A, B, C](f: A => F[B], g: B => F[C]): A => F[F[C]] =
  f andThen g.lift[F]
```
Сразу видна проблема — искомый результат «заматрёшился» в `(F ∘ F)[C]`, тогда как нам хотелось бы получить просто `F[C]`. Значит для `F[_]` требуется возможность «разматрёшивания», функция вида `(F ∘ F)[C] => F[C]` , единообразно работающая для любого `C`. Очевидно, что речь идёт о естественном преобразовании
```scala
type Flatten[F[_]] = F ∘ F ~> F

def compose[F[_]: Funcor : Flatten as flatten, A, B, C](f: A => F[B], g: B => F[C]): A => F[C] =
  f andThen g.lift[F] andThen flatten
```

Казалось бы, можно было бы поискать такой способ композиции, который не задействует функтор вообще



# Применение (вместо заключения)

Функции, действующие как естественные преобразования, используются в программировании повсеместно, когда приходится иметь дело  с обобщёнными типами. Например, вычисление длины списка тоже можно трактовать как естественное преобразование в константный функтор:
```scala
val getLenght: List ~> Const[Int] = [A] => (lst: List[A]) => lst.lenght
```

Да и само создание экземпляра обобщённого типа тоже можно записать как естественное преобразование:
```scala
val pureOption: Id ~> Option = [A] => (a: A) => Some(a)
```

Для «чистой» работы с побочными эффектами нам приходится средствами функторов комбинировать «эффективные» функции, возвращающие значения «в контейнерах» `F[_]`. При этом нужно уметь «разматрёшивать» результаты таких комбинаций `F[F[A]]`. Здесь нас выручают следующие естественные преобразования:
```scala
val flattenList: List ∘ List ~> List = [A] => (lstA: List[List[A]]) => lstA.flatten
//                                                    встроенный метод ↑↑↑↑↑↑↑↑↑↑↑↑
```
Да, это самая характерная способность монады, но о них самих мы поговорим лишь в следующей части обзора.

Ну и, конечно же, вычисление всех побочных эффектов в финале — «распаковка» контейнера `F[_]` — это тоже естественное  преобразование:
```scala
val runUnsafe: IO ~> Id = ???

val myProgram: IO[Int] = ???

val exitCode: Int = runUnsafe(myProgram)
```

Ещё естественные преобразования являются ключевым инструментом в специальной технике программирования основанной на *свободных контейнерах* (монадах). Я уже [рассказывал о них в одном из предыдущих обзоров](https://habr.com/ru/articles/807495/#free)

### !! Спойлер: Напомню

Следуя примерам кода из того обзора выделю следующие моменты.

- Сперва для описания взаимосвязанных бизнес-действий строятся *обобщённые алегбраические типы данных*, вроде `enum UsersRepository[A]`. Они не предоставляют реализации этих действий — только перечисление названий и описания типов входных параметров и результата. Каждый такой контейнер и считается носителем своего (пока что абстрактного) бизнес-эффекта.
- Эти контейнеры-алгебры объединяются в общий контейнер вида `type TotalAlgebra = UsersRepository :+: SearchServcie :+: NotificationService`.
- Затем эти контейнеры «поднимаются в свободный мир» контейнера `Free: (* => *) => * => *` посредством библиотечных <u>естественных преобразований</u> вида `UsersRepository ~> Free[TotalAlgebra]`.
- В «свободном мире» уже и строится вся программа с помощью стандартных комбинаторов (`map`, `flatMap` и проч.). По сути, это лишь рекурсивная структура данных типа `Free[TotalAlgebra][Result]` — описание последовательности действий.
- Только когда уже готова «свободная» программа-как-данные, для её вычисления требуется предоставить реализацию всех бизнес-действий.
	- Сперва собираются отдельные интерпретаторы — <u>естественные преобразования</u> бизнес-алгебр в целевой контейнер эффектов вида `UsersRepository ~> IO`.
	- Затем из них, опять же, библиотечными методами собирается тотальный интерпретатор — <u>естественное преобразование</u> `TotalAlgebra ~> IO`.
- «Свободная программа», будучи рекурсивной структурой, [сворачивается](https://habr.com/ru/articles/863334/) методом `foldMap` с помощью тотального интерпретатора в итоговый результат `IO[Result].`

Для целей данного обзора более интересными оказываются другие приложения естественных преобразований, а именно
- пределы и копределы, позволяющие конструировать типы на основе описания их универсальных свойств;
- сопряжение функторов, позволяющее, в частности, проанализировать весь базис возможностей построения новых обобщённых типов, а также вывести для них
- монады, которые, в свою очередь, также часто представляют в виде пары естественных преобразований.

Именно эти приложения мы и рассмотрим в следующей части обзора.





