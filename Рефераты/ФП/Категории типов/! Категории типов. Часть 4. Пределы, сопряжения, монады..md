Итак, позади три вводные части  обзора, в которых мы познакомились с категориями, функторами между ними, а также естественными преобразованиями для функторов. В данной же части мы увидим, как все эти понятия помогут нам конструировать новые типы, что не только даст представление, откуда вообще берутся *монады* (наконец то!), но и поможет разобраться в причинах сложности их композирования.
# Универсальное свойство

В [одном из предыдущих обзоров](https://habr.com/ru/articles/758542/#algebra) я уже рассказывал, что все типы данных можно представить в виде некого алгебраического выражения. Алгебра типов покрывает большую часть возможностей, что предоставляют системы типизации большинства языков программирования (а для самых популярных, пожалуй, полностью).

В этих выражениях могут участвовать как уже известные типы, так и типовые «свободные» переменные — они нужны для определения конструкторов типов. А в качестве алгебраических операций разрешены сложение, умножение и экспоненциал. Именно эти операции и являются ключом к определению новых типов.

В том же обзоре говорится, что каждая алгебраическая операция над типами определяется через её *универсальное свойство*. Этот термин взят из теории категорий — с его помощью формулируются новые конструкции в категориях. В качестве примера напомню универсальное свойство произведения объектов категории:
> Произведением двух объектов $A$ и $B$ выбранной категории называется такой объект $A \times B$ с морфизмами $p_A: A \times B \rightarrow A$ и $p_B: A \times B \rightarrow B$, что для любых объекта $C$ и морфизмов $f: C \rightarrow A$ и $g: C \rightarrow B$ будет существовать единственный морфизм $u: C \rightarrow A \times B$, делающий такую диаграмму коммутирующей
> ![[произведение типов.png|600]]

Определяемый объект $A \times B$, также как и все кандидаты $C$, имеют аналогичную пару морфизмов, идущих от них к $A$ и $B$. Но среди всех кандидатов выделяется лишь один универсальный объект $A \times B$ — его *универсальный морфизм* $u$ будет единственным *для любого* другого кандидата. Все остальные кандидаты будут либо сложнее (например, морфизм $A \times B \rightarrow A \times B \times X$ будет не единственным), либо диаграмма не будет коммутировать (по сути, любой кандидат, но выбранные для него морфизмы $f$ и $g$ не полиморфны по $A$, или $B$).

Определение любого универсального свойства в категории имеет такую структуру:
- выбирается способ *формулирования* универсального объекта на основе существующих ($A, B \rightarrow A \times B$);
- выбирается семейство кандидатов с определёнными возможностями (в примере выше — пары морфизмов $f, g$ или $p_A, p_B$);
- для каждого кандидата определяется морфизм $u$, связывающий его с целевым универсальным объектом;
- такой морфизм обязан быть универсальным — единственным и обеспечивающий коммутируемость полученной диаграммы.

Как универсальные свойства будут выглядеть в терминах категории типов? Прежде всего, «семейство кандидатов с определёнными возможностями» — это, очевидно, некая подкатегория конструктора типов `F[_, ...]`. Тогда универсальный морфизм, заданный *для любого* кандидата (`F[A, B]`) и целевого типа `U`является полиморфным преобразованием вида `[A, B] => F[A, B] => U` (или обратно). А требование коммутируеммости диаграммы очень напоминает условие *естественности* этого преобразования!

Конечно же, тут подразумевается некая функториальность для конструктора типов `F[_, ...]`. Его параметры даже могут иметь разную вариантность, поэтому в общем случае придётся иметь дело с *мультипрофункторами*, связанными обобщёнными *диестественными* преобразованиями, о которых мы будем говорить лишь в продолжении обзора. А в этой статье мы рассмотрим, в первую очередь, ковариантные функторы и бифункторы.


# Конусы и ко-конусы

Давайте сперва посмотрим, как универсальные свойства выражаются с помощью естественных преобразований в категориальных терминах. Все возможные объекты-кандидаты в целевой категории $\mathcal{C}$ индексируются объектами некой категории $\mathcal{I}$ посредством функтора $F: \mathcal{I} \rightarrow \mathcal{C}$. Также нам нужно выбрать фиксированный объект $c: \mathcal{C}$ — сделаем это с помощью **константного функтора** $\Delta\,c: \mathcal{I} \rightarrow \mathcal{C}$. Естественное преобразование $\Delta\,c \rightsquigarrow F$ называется **конусом** функтора $F$ с вершиной $c$:
$$
Cone_{F,c}: \Delta c \rightsquigarrow F
$$
Образ функтора $F$ в категории $\mathcal{C}$ образует подкатегорию, являющуюся «основанием» этого конуса:
### !!! Рисунок конуса !!!

Например, если в качестве индексирующей выбрать категорию одного объекта $\mathcal{I}=1$, а целевой будет категория типов $\mathcal{C}=\star$,  то конус можно записать на Scala так:
```scala
type Cone[F[_]] = [C] =>> Const[C] ~> F
```

С другой стороны, если развернуть естественное преобразование, то мы получим **ко-конус**:
$$
Cocone_{F,c}: F \rightsquigarrow \Delta c
$$
На диаграмме получаем как бы «перевёрнутый конус»:
### !!! Рисунок коконуса !!!





# Пределы и ко-пределы в категории типов

# Сопряжения функторов


# Монады

## моноид и моноидальная категория.

Это два разных, хотя и связанных, понятия в теории категорий. Важно понимать разницу между ними, чтобы не путать их.

1. Моноид в теории категорий

•  Где: Моноид определяется внутри некоторой моноидальной категории (обычно, но не всегда, это категория множеств Set с декартовым произведением в качестве тензорного произведения).
•  Что: Это объект M вместе с двумя морфизмами:
  •  μ: M ⊗ M → M (операция "умножения" или "композиции").
  •  η: I → M (морфизм из единичного объекта в M, определяющий "единичный элемент").

  где I — единичный объект моноидальной категории (например, одноэлементное множество {} в категории Set). ⊗ - это тензорное произведение в моноидальной категории.

•  Свойства: Эти морфизмы должны удовлетворять двум аксиомам, выражающим ассоциативность и единичность:
  •  Ассоциативность: μ ∘ (μ ⊗ id_M) = μ ∘ (id_M ⊗ μ) : M ⊗ M ⊗ M → M
  •  Единица: μ ∘ (η ⊗ id_M) = λ : I ⊗ M → M и μ ∘ (id_M ⊗ η) = ρ : M ⊗ I → M (где λ и ρ - левый и правый униторы моноидальной категории).

•  Пример (в категории множеств Set):
  •  M — множество (например, множество строк).
  •  μ — функция M × M → M (например, конкатенация строк).
  •  η — функция {} → M (выбирающая пустую строку).

  Это обычный моноид, как мы его знаем в алгебре.

•  Другие примеры:
  •  Моноид в категории эндофункторов — это монада.
  •  Группа — это моноид с дополнительным условием существования обратного элемента.

2. Моноидальная категория

•  Что: Это сама категория с дополнительной структурой, а именно:
  •  Тензорное произведение: Бифунктор ⊗ : C × C → C, который позволяет "умножать" два объекта категории C и получать новый объект той же категории.
  •  Единичный объект: Объект I в категории C, который является "единицей" для тензорного произведения.
  •  Ассоциатор: Естественный изоморфизм α_{A,B,C} : (A ⊗ B) ⊗ C → A ⊗ (B ⊗ C), который выражает ассоциативность тензорного произведения (с точностью до изоморфизма).
  •  Левый и правый униторы: Естественные изоморфизмы λ_A : I ⊗ A → A и ρ_A : A ⊗ I → A, которые показывают, как единичный объект взаимодействует с тензорным произведением.

•  Свойства: Ассоциатор и униторы должны удовлетворять определённым аксиомам когерентности (например, пентагональная аксиома и треугольная аксиома), чтобы обеспечить согласованность операций.

•  Примеры:
  •  Категория множеств Set с декартовым произведением × в качестве тензорного произведения и одноэлементным множеством {} в качестве единичного объекта.
  •  Категория векторных пространств Vect с тензорным произведением векторных пространств и полем k (рассматриваемым как 1-мерное векторное пространство) в качестве единичного объекта.
  •  Категория категорий Cat с декартовым произведением категорий и тривиальной категорией в качестве единичного объекта.

Главное отличие:

•  Моноидальная категория — это тип категории, вид категории, которая обладает дополнительной структурой (тензорным произведением и единичным объектом). Она является фундаментом для определения моноидов.

•  Моноид (в теории категорий) — это объект внутри уже существующей моноидальной категории, который удовлетворяет определённым условиям (ассоциативность и единичность). Он является конкретным элементом с определёнными свойствами.

Аналогия:

Представь себе:

•  Моноидальная категория — это кухня. На кухне есть стол (тензорное произведение), место для хранения продуктов (объекты) и рецепты (правила когерентности).
•  Моноид (в теории категорий) — это конкретный рецепт пирога (объект), который ты можешь приготовить на этой к

ухне. У пирога есть ингредиенты (элементы объекта) и способ их смешивания (операция умножения).

В итоге:

Моноидальная категория — это структура, в которой можно определять моноиды. Моноид — это конкретный объект, удовлетворяющий определённым условиям, внутри моноидальной категории.
