### !!! Вступление
# Универсальные свойства типов

В одной из предыдущих частей обзора [был продемонстрирован](https://habr.com/ru/articles/933016/#anyfunctor) функтор, связывающий две разные категории одного и того же объекта — категории типов $\star$. Только в начальной категории морфизмами выступали конструкторы типов `F[_]`, а в конечной — эндофункторы `Functor[F]`. Полученный функтор сохранял композицию конструкторов типов, позволяя из любых `Functor[F]` и `Functor[G]` создавать `Functor[G ∘ F]`. А это, в свою очередь, означает, что если имеются реализации эндофункторов для каких-либо *базовых* `F[_]`, у нас автоматически есть эндофункторы для абсолютно любых контейнерных типов!

Открытым остаётся вопрос, какие конструкторы типов можно считать настолько «базовыми», что композируя их, можно получить вообще всё. В других моих статьях о теории типов неоднократно упоминалось об их алгебраической природе, о том, что в их основе лежат элементарные математические операции — сумма, произведение и экспоненциал (а также понятия нуля и единицы). Однако, мне приходилось всячески избегать объяснения, *почему* происходит именно так. Дело в том, что ключ к понимаю этого лежит в теории категорий, так что только сейчас настало время разобраться с этим вопросом.

В первом обзоре цикла [упоминалось](https://habr.com/ru/articles/758542/#types), что любой тип можно определить через его *универсальное свойство*. Это понятие заимствовано из теории категории, с его помощью формулируются новые конструкции в категориях. Поэтому сперва давайте разберёмся, как это работает.

В качестве примера напомню универсальное свойство произведения объектов:
> произведением двух объектов $A$ и $B$ выбранной категории называется такой объект $A \times B$ с морфизмами $p_A: A \times B \rightarrow A$ и $p_B: A \times B \rightarrow B$, что для любых объекта $C$ и морфизмов $f: C \rightarrow A$ и $g: C \rightarrow B$ будет существовать единственный морфизм $u: C \rightarrow A \times B$, делающий такую диаграмму коммутирующей:


 ![[произведение типов.png|600]]

Определяемый объект $A \times B$, также как и все кандидаты $C$, имеют аналогичную пару морфизмов, идущих от них к $A$ и $B$. Но среди всех кандидатов выделяется лишь один универсальный объект $A \times B$ — его *универсальный морфизм* $u$ будет единственным *для любого* другого кандидата. Все остальные кандидаты будут либо сложнее (например, морфизм $A \times B \rightarrow A \times B \times X$ будет не единственным), либо диаграмма не будет коммутировать (по сути, любой кандидат, но выбранные для него морфизмы $f$ и $g$ не полиморфны по $A$, или $B$).

Определение любого универсального свойства в категории имеет такую структуру:
- обозначаются объекты, *через которые формулируется* универсальный (для произведения и суммы — это просто пара объектов $A, B$);
- выбирается семейство кандидатов с определёнными возможностями (в примере выше — пары морфизмов $f, g$ или $p_A, p_B$);
- для каждого кандидата определяется морфизм $u$, связывающий его с целевым универсальным объектом;
- такой морфизм обязан быть единственным и обеспечивающий коммутируемость полученной диаграммы.

Как перечисленные пункты описать в терминах категории типов? «Возможности» кандидата — это некие преобразования, связывающие его с объектами подкатегории, фиксирующими формулировку универсального свойства. А требование коммутируеммости диаграммы очень напоминает условие *естественности* этого преобразования!

Конечно же, тут подразумевается некая функториальность для конструктора типов `F[_, ...]`. Его параметры даже могут иметь разную вариантность, поэтому в общем случае придётся иметь дело с *мультипрофункторами*, но в этой статье мы будем иметь дело, в первую очередь, с ковариантными функторами и бифункторами.


# Конусы и ко-конусы

Давайте сперва посмотрим, как универсальные свойства выражаются с помощью естественных преобразований в некоторой категории $\mathcal{C}$. Объекты, через которые формулируется универсальный объект, образуют подкатегорию в $\mathcal{C}$. Для произведения объектов $a$ и $b$ такая подкатегория будет дискретной, содержащей только эти два объекта и их тождественные морфизмы. Но в случае других универсальных свойств устройство подкатегории может быть и сложнее.

Выбор конкретной подкатегории в $\mathcal{C}$ удобно выразить с помощью функтора, встраивающего в $\mathcal{C}$ некую модельную категорию $\mathcal{I}$. В случае универсального свойства произведения это и будет дискретная категория двух индексов, скажем, $1$ и $2$. Тогда функтор $F_{ab}: \mathcal{I} \rightarrow \mathcal{C}$ и будет отвечать за выбор конкретных $a$ и $b$ в $\mathcal{C}$.

Ещё нам нужно выбрать объект-кандидат . Поручим это **константному функтору** $\Delta\,c: \mathcal{I} \rightarrow \mathcal{C}$. Естественное преобразование $\Delta\,c \rightsquigarrow F$ называется **конусом** функтора :
$$
{\rm Cone}_F(c): \Delta c \leadsto F
$$

![[конусы!.png|Вы же наверняка заметили, что Ёжик строил вовсе не пирамидку!|800]]


Естественность преобразования важна для случаев, когда в модельной категории $\mathcal{I}$ есть другие морфизмы помимо тождественных (например, $1 \rightarrow 2$), и функтор $F_{ab}$ переносит их в также нетождественные морфизмы ($a \rightarrow b$).

Образ функтора $F$ образует подкатегорию $F_{ab}\; \mathcal{I} \subset \mathcal{C}$, являющуюся «основанием» этого конуса, а объект $c: \mathcal{C}$ будет его вершиной:
![[Конус.png|800]]


$$
\begin{tikzcd}
\end{tikzcd}
$$

Для универсального свойства суммы объектов получим дуальную картину. Напомню,
> суммой двух объектов $A$ и $B$ выбранной категории называется такой объект $A + B$ с морфизмами $i_A: A \rightarrow A + B$ и $i_B: B \rightarrow A + B$, что для любых объекта $D$ и морфизмов $f: A \rightarrow D$ и $g: B \rightarrow D$ будет существовать единственный морфизм $u: A + B \rightarrow D$, делающий такую диаграмму коммутирующей:

![[сумма типов.png|600]]

В сравнении с произведением, объекты на диаграмме сохранили своё положение, но все морфизмы оказались обращены. Кандидаты в сумму объектов описываются дуальной конструкцией, называемой **ко-конусом**:
$$
{\rm Cocone}_F(c): F \rightsquigarrow \Delta c
$$
На диаграмме получаем как бы «перевёрнутый конус»:
### !!! Рисунок ко-конуса !!!

Обратите внимание, что и моделирующая категория $\mathcal{I}$ и функтор $F$ остались теми же, что и для произведения типов! Изменилось только направление естественного преобразования.

Кандидаты в универсальные объекты можно выразить либо через конусы, либо ко-конусы. Осталось только выбрать среди них *тот самый универсальный* (если он вообще существует).


# Пределы и копределы

В формулировке универсального свойства упоминаются морфизмы, связывающие кандидатов и универсальные объекты так, что при этом не ломаются (ко)конусы («…делают диаграмму коммутирующей…»). Эти морфизмы образуют отношение частичного порядка среди кандидатов. Тогда может получиться так, что среди всех кандидатов выделяется «особенный», связанный с другими единственным (для каждого) универсальным морфизмом. Если такой объект существует (а это возможно далеко не всегда!), его (ко)конус, и, следовательно, он сам будут считаться «универсальными». Универсальный (ко)конус зависит лишь от функтора $F:\: \mathcal{I} \rightarrow \mathcal{C}$, он носит название **(ко)предел функтора $F$** и обозначается как ${\rm Lim}\,F$ (${\rm Colim}\,F$).
### !!! РИСУНОК ДЛЯ ПРЕДЕЛА/КОПРЕДЕЛА

Предел и копредел можно также трактовать как функторы, действующие из категории функторов: ${\rm Lim,\, Colim}:\: \mathcal{C}^\mathcal{I} \rightarrow \mathcal{C}$. В некотором смысле они противоположны диагональному функтору $\Delta:\: \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$.
### !!! РИСУНОК ДЛЯ функторов ПРЕДЕЛ/КОПРЕДЕЛ/ДИАГОНАЛЬНЫЙ

Чуть позднее мы рассмотрим этот аспект подробнее, а сейчас вернёмся к формализации (ко)пределов.

Итак, предельное универсальное свойство утверждает, что «…для каждого кандидата существует единственный морфизм в предел...». Очевидно, что речь идёт о *взаимно-однозначном соответствии кандидатов и морфизмов* между ними и пределом. Кандидаты представлены своими конусами, которые можно рассматривать как контравариантный функтор
$$
\mathrm{Cone}_F:\; \mathcal{C}^{op} \rightarrow \mathrm{Hom}_{\mathcal{C}^{\mathcal{I}}}(\Delta\, \_,\, F)
$$
Символ подчёркивания обозначает место, куда нужно подставить объект исходной категории.

С другой же стороны у нас обычные морфизмы ${\rm Hom}_{\mathcal{C}}(c,\, {\rm Lim}\, F)$, для которых получаем похожий контравариантный функтор:
$$
U_{Lim\ F}:\; \mathcal{C}^{op} \rightarrow {\rm Hom}_{\mathcal{C}}(\_,\, {\rm Lim}\, F)
$$
Не так важно, будут ли морфизмы между двумя объектами множествами, типами или чем-то ещё. В любом случае, они образуют дискретную категорию, в которую и приводят оба этих функтора.
### !!! РИСУНОК ДЛЯ этих функторов

Требуемая «взаимная однозначность» говорит о том, что эти функторы должны быть *изоморфны* друг другу, то есть, предельное универсальное свойство задаётся парой встречных естественных преобразований, чьи композиции дают тождественные функторы:
$$
{\rm Cone}_F \cong \; U_{Lim\ F}
$$

### !!! В спойлер! Предпучки
> Подобные контравариантные функторы (отображающие объекты категории во множество морфизмов), называются *предпучками*. Тогда естественные изоморфизмы выше — это условия *представимости* предпучка (ко)конусов *в виде морфизмов* в предел функтора. Понятие «представимости» имеет большое значение в теории категорией и мы с ней ещё столкнёмся в данном обзоре.
> 
> Теория [пучков](https://ru.wikipedia.org/wiki/%D0%9F%D1%83%D1%87%D0%BE%D0%BA_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) сейчас активно развивается и «её инструментарий может оказаться очень полезным». Впрочем, этой фразой обычно и завершаются все упоминания предпучков))).
> 
> (Если кому-то интересно, то для того, чтобы называться полноценными «пучками», предпучкам не достаёт дополнительных ограничений… без которых программистам и так не плохо)))

В свою очередь, для копредела имеем естественный изоморфизм уже ковариантных функторов:
$$
\begin{eqnarray}
\mathrm{Cocone}_F&:\;& \mathcal{C} \rightarrow \mathrm{Hom}_{\mathcal{C}^{\mathcal{I}}}
(F,\, \Delta\, \_)\\
U^{Colim\ F}&:\;& \mathcal{C} \rightarrow {\rm Hom}_{\mathcal{C}}({\rm Colim}\, F,\, \_)\\
\\
&& {\rm Cocone}_F \cong \; U^{Colim\ F}
\end{eqnarray}
$$

В этих естественных изоморфизмах слева расположена совокупность (ко)конусов, индексированная только функтором $F$, а справа — только его (ко)предел. По сути, мы получаем уравнения для поиска (ко)предела функтора, но решать их в общем случае не просто.


## (Ко)пределы в категории типов

Как вообще можно построить новые типы? Исходно у нас нет возможности сделать что-то интересное с одним единственным типом, кроме как вернуть его же. Но можно попробовать скомбинировать пару существующих типов в какой-то новый. Получится функциональное отображение, на вход которому подаётся *два* типа, а на выходе получаем один новый. Это просто «двухдырочные» конструкторы типов вида `(*, *) => *`. Их можно трактовать как функторы из произведения категорий типов в неё же: $\star \times \star \rightarrow \star$. Произведение двух категорий типов моделируется дискретной категорией $\mathcal{I} = 2$, состоящей из двух индексов $1$ и $2$, так что наши бифункторы можно записать как $F_{ab}: \star^2 \rightarrow \star$. Конусами этих бифункторов будут естественные преобразования c компонентами, индексированными двумя объектами $\mathcal{I}$:
```scala
type Cone2[A, B] = [-C] =>> ( // C - кандидат
  C => A, // первая компонента естественного преобразования
  C => B  // вторая компонента естественного преобразования
)
```
С другой стороны у нас hom-тип, описывающий морфизмы из кандидата в предел:
```scala
type ULim[A, B] = [-C] =>> C => Lim[A, B]
```

Нам нужно выяснить, каким же может быть `Lim[A, B]`, чтобы эти контравариантные функторы для `Cone2[A, B][-_]` и `ULim[A, B][-_]` образовывали естественный изоморфизм
```scala
infix type ≅[F[_], G[_]] = (
  right: F ~> G,
  left : G ~> F,
)

summon[Cone2[A, B] ≅ ULim[A, B]]
```

К счастью, мы заранее знаем, что пределом будет произведение типов. В этом мы убедимся, реализовав изоморфизм:
```scala
type Lim[A, B] = A × B // (A, B)

given limIso: [A, B] => Cone2[A, B] ≅ ULim[A, B] = (
  right = [C] => (cone: (C => A, C => B)) => (c: C) => cone._1(c) -> cone._2(c),
  left  = [C] => (ulim: C => A × B) => (ulim andThen {_._1}) -> (ulim andThen {_._2})
)
```

Такой предел действительно минимален — морфизмы из других кандидатов в него будет *единственным образом забывать* любую лишнюю информацию. А будучи полиморфными, проекторы предела будут гарантировано факторизовать проекторы всех других кандидатов (сохранять коммутативность диаграммы). Значит, это и есть настоящее универсальное свойство предела для функтора, ответственного за выбор пары типов в категории $\star$.

Вообще, (ко)предел определяется не для категории индексов $\mathcal{I}$, а именно для функтора $\mathcal{I} \rightarrow \mathcal{C}$. Функторы бывают разные, в том числе, и $\Delta_c$ схлопывающий все морфизмы (не только тождественные!) в один. Однако, часто предел ищется только для наиболее «свободного» функтора, моделирующего категорию $\mathcal{I}$ в $\mathcal{C}$ без потерь. В этом случае, *(ко)предел определяется только структурой $\mathcal{I}$*. Например, очевидно, что если в дискретной $\mathcal{I}$ будет $n$ объектов, то пределом функтора из неё в типы будет кортеж из $n$ элементов. 

Формально, можно вывести несколько разных вариантов одного и того же предела функтора. Например, произведение типов можно описать с помощью кодирования Чёрча как `[A, B] =>> [C] => (A => B => C) => C`. Но для всех этих вариантов в левой части естественный изоморфизма будут всё те же конусы, а значит и правые части будут изоморфны для всех вариантов. Таким образом, *предел функтора единственен с точностью до изоморфизма (если он вообще существует)*.

Аналогично, убеждаемся, что копределом бифунктора $F_{ab}$ будет сумма типов:
```scala
type Cocone2[A, B] = [+C] =>> ( // C - кандидат
  A => C, // первая компонента естественного преобразования
  B => C  // вторая компонента естественного преобразования
)
type UColim[A, B] = [+C] =>> Colim[A, B] => C

type Colim[A, B] = A + B // A Either B

given colimIso: [A, B] => Cocone2[A, B] ≅ UColim[A, B] = (
  right = [C] => (cocone: (A => C, B => C)) => (colim: Colim[A, B]) =>
    colim.fold(cocone._1, cocone._2),
  left  = [C] => (ucolim: (A + B) => C) =>
    ((a: A) => ucolim(Left(a)), (b: B) => ucolim(Right(b))
)
```

В случае бо́льших размеров категории $\mathcal{I}$ наиболее близкой реализация копредела в Scala будет, пожалуй, перечисление:
```scala
enum Sum3[A, B, C]: // три конструктора:
  case One(a: A)
  case Two(b: B)
  case Tri(c: C)
```

Для экспоненциала в категории типов (то есть, функций `A => B`) также существует конструкция, которую можно интерпретировать как предел константного функтора $\Delta\, B$. Но теперь категория индексов $\mathcal{I}$ будет *дискретной категории значений* типа `A`. Компоненты конусов кандидатов будут иметь вид:
```scala
// типы A и B фиксированы
// компонетны конуса индексированы значениям A
type ConeDelta = [-C] =>> A => (C => B)
type ULimExp   = [-C] =>> C => LimExp

type LimExp = A => B

given expIso: ConeDelta ≅ ULimExp = (
  right = [C] => (cone: A => C => B) =>
    (c: C) => (a: A) => cone(a)(c)
  left  = [C] => (ulim: C => A => B) =>
    (a: A) => (c: C) => ulim(c)(a)
)
```
Изоморфизм функторов отражает простое алгебраическое соотношение $(B^C)^A = (B^A)^C$, его морфизмы суть просто частичное применение каррированных функций.

### !!! В спойлер или убрать??
```scala
type CосoneDelta = [+C] =>> A => (B => C)
type UColimExp   = [+C] =>> ColimExp => C

type ColimExp = (A, B)

given coExpIso: CосoneDelta ≅ UColimExp = (
  right = [C] => (cocone: A => B => C) =>
    (a: A, b: B) => cocone(a)(b)
  left  = [C] => (ucolim: (A, B) => C) =>
    (a: A) => (b: B) => ucolim(a, b)
)
```

Итак, мы можем строить новые типы складывая, умножая и «возводя в степень» существующие. А как определяются универсальные свойства нулевого и единичного типов, «существующих изначально»? Да совершенно аналогичным способом! Только если раньше мы строили новые типы из двух, моделируемых категорией $\mathcal{I}=2$, теперь нам не требуется ни одного типа, что соответствует абсолютно пустой категории $\mathcal{I}=0$. Единственно возможный функтор честно отображает пустую категорию в пустую диаграмму в $\star$, и от (ко)конусов остаются одни лишь вершины-кандидаты. В случае предела полученного функтора все универсальные морфизмы будут вести *к нему*, в то время как для копредела они будут вести *от него* к кандидатам. Это в точности соответствует универсальным свойствам *терминального и начального объектов* в категории типов — единичного (`Unit`) и нулевого (`Nothing`) типов!

Помимо вышеперечисленных, иногда говорят и о других (ко)пределах функторов, основанных на недискретных индексных категориях, то есть, имеющих морфизмы между объектами. В частности,
- предел и копредел диаграммы $1 \rightrightarrows 2$ (помимо тождественных, есть два дополнительных морфизма между объектами) — [уравнитель](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) и [коуравнитель](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%83%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C) ~~функций~~ морфизмов;
- предел диаграммы $1 \rightarrow 2 \leftarrow 3$  — [декартов квадрат](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82) (расслоённое произведение, pullback);
- копредел диаграммы $1 \leftarrow 2 \rightarrow 3$  — [кодекартов квадрат](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82) (расслоённая сумма, амальгама, pushout).

Однако «честные» реализации соответствующих типов не возможны без привлечения специальных техник Scala, основанных на идее зависимых типов, поэтому мы не будем останавливаться на них в данном обзоре.


## Непрерывность и когерентность функторов

Пределы и копределы очень важны для большинства категорий, поэтому часто возникает вопрос о том, как с ними взаимодействуют функторы. Если функтор $F$ сохраняет пределы любых других функторов $G$, он называется *непрерывным*:

$$
{\rm Lim}\,(F \circ G) = (F \circ {\rm Lim})\, G.
$$
(Напомню, предел — это функтор, определённый на категории функторов. То есть, его можно как композировать с другими функторами, так и применять к ним.)

Самый «базовый» предел для категории типов — это произведение типов. Практически все остальные пределы строятся на его основе, поэтому непрерывность функтора обычно проверяют выясняя, сохраняет ли он произведение. Но в более общем случае для гарантии непрерывности требуется проверка сохранения и других пределов.

Сохранение же копределов говорит о *когерентности* функтора. Для функторов в категории типов обычно проверяют, сохраняют ли они сумму типов, как базовый копредел. И, опять же, более полная проверка требует рассмотрения коуравнителей и других копределов.

Среди эндофункторов в категории типов непрерывно-когерентным будет только тождественный функтор.

> Наиболее важное свойство сопряжённых функторов — их непрерывность: каждый функтор, имеющий левый сопряжённый (то есть являющийся правым сопряжённым), коммутирует с [пределами](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\) "Предел (теория категорий)") в категорном смысле. Соответственно, функтор, имеющий правый сопряжённый, _конепрерывен_, то есть коммутирует с [копределами](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\)&action=edit&redlink=1 "Копредел (теория категорий) (страница отсутствует)").


# Сопряжения функторов

Пределы и копределы формулируются для конкретных функторов, вроде рассмотренного выше $F_{a, b}:\: 2 \rightarrow \mathcal{C}$. Каждый такой функтор *выбирает в конечной категории, в каком именно месте* будет смоделирована исходная. Между тем, натуральные изоморфизмы, определяющие предел и копредел намекают, что существуют глобальные взаимоотношения, не завязанные на выбор конкретного функтора $F_{a, b}$. Эти взаимоотношения и станут ключом к пониманию основных операций над типами — суммой, произведением и экспоненциалом.

Рассмотрим внимательнее представленный ранее натуральный изоморфизм, определяющий предел. Он индексирован объектом $c:\: \mathcal{C}$ и функтором $F:\: \mathcal{C}^\mathcal{I}$, и представлен парой естественных преобразований, действующих навстречу друг другу:
$$
\begin{split}
left(c,F)&:&\: (\Delta c \rightsquigarrow F) &\rightarrow (c \rightarrow \mathrm{Lim}\,F),\\
right(c,F)&:&\: (c \rightarrow \mathrm{Lim}\,F) &\rightarrow (\Delta c \rightsquigarrow F).
\end{split}
$$
В целях обобщения, попробуем реорганизовать эти конструкции, избавившись от упоминания $c$ и $F$. Сперва для наглядности перепишем их через hom-объекты:
$$
\begin{split}
left(c,F)&:\: \mathrm{Hom}_{\mathcal{C}^\mathcal{I}}&&(\Delta& c,\,& &F) &\rightarrow \mathrm{Hom}_{\mathcal{C}}&&(&c,\;& \mathrm{Lim}\,&F),\\
right(c,F)&:\: \mathrm{Hom}_{\mathcal{C}}&&(&c,\;& \mathrm{Lim}\, &F) &\rightarrow \mathrm{Hom}_{\mathcal{C}^\mathcal{I}}&&(\Delta &c,\,& &F).
\end{split}
$$
Тут лучше виден паттерн в расположении $c$ и $F$ относительно функторов $\Delta:\: \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$ и $\mathrm{Lim}:\: \mathcal{C}^\mathcal{I} \rightarrow \mathcal{C}$ . В первом выражении давайте избавимся от $F$, подставив вместо него $\Delta c$, тогда слева от стрелки получится $\mathrm{Hom}_{\mathcal{C}^\mathcal{I}}(\Delta c,\, \Delta c)$. Можем передать сюда тождественный функтор $id_{\mathcal{C}^\mathcal{I}}$, при этом останется лишь то, что правее стрелки — $\mathrm{Hom}_{\mathcal{C}}(c,\; \mathrm{Lim}\,\Delta c)$. Перепишем это так:
$$
left(c, \Delta c)(id_{\mathcal{C}^\mathcal{I}}):\: c \rightarrow (\mathrm{Lim} \circ \Delta)c.
$$
Аналогично, если в правую ветку вместо $c$ подставить $\mathrm{Lim}\,F$, и передать туда $id_{\mathcal{C}}$, получим
$$
right(\mathrm{Lim}\,F, F)(id_{\mathcal{C}}):\: (\Delta \circ \mathrm{Lim})F \rightarrow F.
$$
Оба выражения оказались индексированы только одним параметром и, очевидно, что они представляют собой компоненты естественных преобразований:
$$
\begin{split}
\eta_{\mathrm{Lim},\Delta}&:\:& id_{\mathcal{C}} \rightsquigarrow \mathrm{Lim} \circ \Delta &=
\forall c: \mathcal{C}&& .\; left(c, &&\Delta c&&)(id_{\mathcal{C}^\mathcal{I}})\\

\varepsilon_{\mathrm{Lim},\,\Delta}&:\:& \Delta \circ \mathrm{Lim} \rightsquigarrow id_{\mathcal{C}^\mathcal{I}} &=
\forall F: \mathcal{C}^\mathcal{I}&& .\; right(\mathrm{Lim}\,F, && \,\,\,F &&)(id_{\mathcal{C}})
\end{split}
$$
Подобные преобразования могут существовать не только для $\mathrm{Lim}$ и $\Delta$ но и для других встречных функторов. Они определяют такое понятие, как **сопряжение функторов**:
$$
\begin{split}
F \dashv G&:&\\
\eta&:&\: id \rightsquigarrow G \circ F,\\
\varepsilon&:&\: F \circ G \rightsquigarrow id.\\
\end{split}
$$
### !!! Рисунок для сопряжения !!!

Преобразования $\eta$ и $\varepsilon$ называются «единицей» и «коединицей» сопряжения. Между ними существуют очевидные условия консистентности — приведённые ниже треугольники будут коммутировать:
### !!! Рисунок для треугольников !!!

Признаком наличия сопряжения между какими-то функторами как раз и является наличие естественного изоморфизма между hom-объектами в разных категориях.
![[Pasted image 20250905101810.png]]

Очень важный момент — *сопряжение функторов не является отношением порядка*. Оно не транзитивно, то есть, если $F \dashv G$ и $G \dashv H$, то вовсе не обязательно, что $F \dashv H$. Зато его можно интерпретировать как «ослабленную эквивалентность категорий» для случаев, когда строгая эквивалентность не нужна. Действительно, категории $\mathcal{C}$ и $\mathcal{D}$ считались бы эквивалентными, если бы для встречных функторов $F$ и $G$ между ними существовали бы натуральные изоморфизмы: $F \circ G \cong id_{\mathcal{D}}$ и $G \circ F \cong id_{\mathcal{C}}$. А в случае сопряжений не нужны полные изоморфизмы, состоящие из четырёх естественных преобразований — достаточно лишь двух из них: $id_{\mathcal{D}} \rightsquigarrow G \circ F$ и $F \circ G \rightsquigarrow id_{\mathcal{C}}$.

Сопряжение, не является свойством одного функтора по отношению к другим. Ведь левое и правое сопряжения любого функтора *единственны* с точностью до изоморфизма (если они вообще существуют). И поиск сопряжений функтора является одной из наиболее частых задач. В этом смысле, представление спряжения в виде бинарной операции с инфиксным оператором $\dashv$ кажется не самым удобным.


## Монады и комонады
 
В примере с диагональным функтором и пределом приходилось работать не только с привычной категорией типов $\mathcal{C}$, но и с «неудобной» категорией функторов $\mathcal{C}^\mathcal{I}$. И также получается со многими сопряжениями — даже если какая-та категория нам и интересна, то с другой может и не повезти. Тогда какая может быть практическая польза от этих сопряжений?

Дело в том, что наибольший интерес представляют не сами функторы, участвующие в сопряжении $F \dashv G$, но их *композиций* $F \circ G$ и $G \circ F$. Во-первых, обе этих композиции являются *эндофункторами* в своих категориях. А во-вторых, естественные преобразования сопряжения автоматически формируют для этих эндофункторов *монаду* и *комонаду* соответственно!

Действительно, «запаковка» $G \circ F$ и «распаковка» $F \circ G$ совпадают с единицей $\eta$ и коединицей $\varepsilon$ сопряжения, а «разматрёшивание» $G \circ F$ и «заматрёшивание» $F \circ G$ выражаются так:
$$
\begin{eqnarray}
\mu&:\;&&& (G \circ F) \circ (G \circ F) &\rightsquigarrow&& G \circ F &= id_G \circ \varepsilon \circ id_F,\\
\delta&:\;&&& F \circ G &\rightsquigarrow&& (F \circ G) \circ (F \circ G) &= id_F \circ \eta \circ id_G.
\end{eqnarray}
$$

Таким образом, сопряжение функторов порождает монаду и комонаду. Но верно и обратное — любую (ко)монаду можно разложить на пару сопряжённых функторов. Только такое разложение будет неоднозначным, ведь заранее даже не известно, через какую дополнительную категорию будет факторизоваться эндофунктор.

Тут очень хорошо просматривается дуализм монады и комонады. Если первая строится для композиции $F \circ G$ сопряжения $F \dashv G$, то вторая получается автоматически, но уже для перестановки $G \circ F$. В [предыдущей части обзора](https://habr.com/ru/articles/957848/#comonad) мы уже видели похожую картину. Тогда для эндофункторов, соответствующих `Writer[L] = [X] =>> L × X` и `Reader[R] = [X] =>> R => X`, одна их композция давала монаду `State[S] = Reader[S] ∘ Writer[S]`, а другая — комонаду `Store[S] = Writer[S] ∘ Reader[S]`. Можно ожидать, что `Writer`и `Reader` образуют сопряжение, и так оно и есть — мы убедимся в этом далее.

Задачу вычисления монадных возможностей эндофунктора можно свести к поиску какой-либо его декомпозиции на сопряжённые функторы. Причём, эти функторы могут соединять с категорией, отличной от первоначальной. Пожалуй, пока не особо заметно, чем это нам поможет, эта идея будет раскрыта в продолжении обзора.


## Сопряжённая тройка

Ранее мы видели, что для каждого функтора существует лишь единственный предел (для простоты не будем больше добавлять «с точностью до изоморфизма»). Это правило завязано на изоморфизме hom-типов, поэтому оно также распространяется и на сопряжения — *для любого функтора может быть лишь один сопряженный слева и лишь один сопряжённый справа*. Многие функторы, связанные с категорией типов имеют оба сопряжения.

Характерным примером является диагональный функтор $\Delta:\; \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$. Для декартово-замкнутых категорий $\mathcal{C}$ (в т.ч. для категории типов) правым и левым сопряжением диагонального функтора будут предел и копредел соответственно. Это удобно представить в виде **сопряжённой тройки**:
![[Три белых коня копия.png]]

Выберем некий $G: \mathcal{C} \rightarrow \mathcal{D}$. Построим вокруг него сопряжённую тройку $F \dashv G \dashv H$ с функторами $F, H: \mathcal{D} \rightarrow \mathcal{C}$. Это даст нам две пары эндофункторов для каждой категории:
$$
\begin{eqnarray}
H \circ G,\, F \circ G&:\;& \mathcal{C} &\rightarrow& \mathcal{C},\\
G \circ F,\, G \circ H&:\;& \mathcal{D} &\rightarrow& \mathcal{D}.\\
\end{eqnarray}
$$
Причём, в каждой паре для первого эндофунктора сопряжения дадут монаду, а для второго — комонаду.

Более того, каждая пара образует новое сопряжение:
$$\begin{eqnarray}
F \circ G \dashv H \circ G,\\
G \circ F \dashv G \circ H.\\
\end{eqnarray}
$$

Разберём, к примеру, первое из этих сопряжений. Саму возможность его получения проще увидеть, рассматривая сопряжения как *изоморфизмы* hom-типов:
$$
\begin{eqnarray}
\mathrm{Hom}(&&&F \circ G\, a&,\;&& b&)                  \hspace{1cm}  &&\mathrm{Hom}(&&&G \circ F\, a&,\;&& b&)   \\
\Updownarrow {\tiny F \dashv G}\hspace{-2mm} &&&&&&&&&     \hspace{1cm}  \Updownarrow {\tiny G \dashv H} \hspace{-2mm} \\
\mathrm{Hom}(&&&G\, a&,\;&& G\, b&)                      \hspace{1cm}  &&\mathrm{Hom}(&&&F\, a&,\;&& H\, b&)       \\
\Updownarrow {\tiny G \dashv H}\hspace{-2mm} &&&&&&&&&     \hspace{1cm}  \Updownarrow {\tiny F \dashv G} \hspace{-2mm} \\
\mathrm{Hom}(&&&a&,\;&& H \circ G\, b&)                  \hspace{1cm}  &&\mathrm{Hom}(&&&a&,\;&& G \circ H\, b&)   \\
\end{eqnarray}
$$

Из этой схемы можно вывести интересное следствие — алгебра монады $F \circ G\ a \rightarrow a$ изоморфна коалгебре комонады $a \rightarrow H \circ G\, a$. То есть, буквально, если у вас есть «законопослушная распаковка» для $F \circ G$, то вам автоматически доступна столь же хорошая «запаковка» $H \circ G$, и наоборот. Аналогичное правило получается также для монады $G \circ F$ с комонадой $G \circ H$.

Но нам важнее *конструктивный вывод* новых преобразований из первоначальных. Например, для сопряжения $F \circ G \dashv H \circ G$ получаем:
$$
\left\{
\begin{eqnarray}
\eta_{\tiny F \circ G \dashv H \circ G}: Id_{\mathcal{C}} \rightsquigarrow H \circ G \circ F \circ G =
(Id_H \circ \eta_{\tiny F \dashv G} \circ Id_G) \cdot \eta_{\tiny G \dashv H}
\\
\varepsilon_{\tiny F \circ G \dashv H \circ G}: F \circ G \circ H \circ G \rightsquigarrow Id_{\mathcal{C}} =
\varepsilon_{\tiny F \dashv G} \cdot (Id_F \circ \varepsilon_{\tiny G \dashv H} \circ Id_G)
\end{eqnarray}
\right.
$$
Аналогично, для $G \circ F \dashv G \circ H$:
$$
\left\{
\begin{eqnarray}
\eta_{\tiny G \circ F \dashv G \circ H}: Id_{\mathcal{D}} \rightsquigarrow G \circ H \circ G \circ F =
(Id_G \circ \eta_{\tiny G \dashv H} \circ Id_F) \cdot \eta_{\tiny F \dashv G}
\\
\varepsilon_{\tiny G \circ F \dashv G \circ H}: G \circ F \circ G \circ H \rightsquigarrow Id_{\mathcal{D}} =
\varepsilon_{\tiny G \dashv H} \cdot (Id_G \circ \varepsilon_{\tiny F \dashv G} \circ Id_H)
\end{eqnarray}
\right.
$$
Здесь $Id_{\mathcal{C}},\, Id_{\mathcal{D}}$ — тождественные функторы в соответствующих категориях, а $Id_F,\, Id_G,\, Id_H$ — тождественные естественные преобразования функторов. Напомню, [горизонтальная композиция](https://habr.com/ru/articles/951574/#2category) $\beta = Id_F \circ \alpha$ представляет собой естественной преобразование, в котором компоненты $\beta$ получаются «подъёмом» исходных: $\beta_a = F\, \alpha_a$.

И из этих сопряжений мы сразу получаем ещё две пары монад/комонад в соответствующих категориях!

В результате выстраивается такая цепочка:
- сперва мы имеем *единственный функтор* $G: \mathcal{C} \rightarrow \mathcal{D}$;
- мы можем найти левый и правый сопряженный ему $F, H: \mathcal{D} \rightarrow \mathcal{C}$;
- таким образом, получим сопряжённую тройку $F \dashv G \dashv H$;
- а из сопряжённой тройки автоматически получаются:
	- монады для эндофункторов
		- $H \circ G,\;\; H \circ G \circ F \circ G:\;\; \mathcal{C} \rightarrow \mathcal{C}$;
		- $G \circ F,\;\; G \circ F \circ G \circ H:\;\; \mathcal{D} \rightarrow \mathcal{D}$;
	- комонады для эндофункторов
		- $F \circ G,\;\; F \circ G \circ H \circ G:\;\; \mathcal{C} \rightarrow \mathcal{C}$;
		- $G \circ H,\;\; G \circ H \circ G \circ F:\;\; \mathcal{D} \rightarrow \mathcal{D}$;
- в дополнение имеем изоморфизмы алгебр и коалгебр, которые тоже могу оказаться полезными.

	Итак, из самого наличия функтора получается целая куча связанных с ним монад и комонад. В общем случае они группируются в пары по категориям, но если мы сразу выбираем *эндофунктор* $G:\; \mathcal{C} \rightarrow \mathcal{C}$, то одних только монад в той же категории $\mathcal{C}$ мы получим аж четыре штуки. Но и это ещё не всё! Теоретически, можно поискать как более правые, так и более левые сопряжения, расширяя сопряжённую тройку в обе стороны, получая всё новые эндофункторы и (ко)монады.

На текущий момент, самым неочевидным пунктом является возможность конструктивного вывода левого и правого сопряжений функтора. Этому будет посвящена следующая часть обзора. А сейчас рассмотрим некоторые следствия, важные для программистов.


## Сопряжения в программировании

### !!! сумма и произведение

[Product from Adjunction](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=Product%20from%20Adjunction)

диаграмма

### !!! класс типов Adjunction

### !!! Reader - правое сопряжение к Writer

[Exponential from Adjunction](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=Exponential%20from%20Adjunction)

проверить левое сопряжение

### !!! монада State





# Дополнительная литература

- [Теория категорий на JavaScript. Часть 1. Категория множеств](https://habr.com/ru/companies/cit/articles/313254/) — безо всяких формул, но с помощью пёстрых диаграмм раскрываются на ~~пальцах~~ множествах различные универсальные свойства.
- [Understanding limits in Set](https://ncatlab.org/nlab/show/Understanding+limits+in+Set) — одна из самых «демократичных» среди прочих «математичных» статей на nLab.
- Серия публикаций Бартоша Милевски из его блога:
	- [Limits and Colimits](https://bartoszmilewski.com/2015/04/15/limits-and-colimits/)
	- [Understanding Products and Universal Constructions](https://bartoszmilewski.com/2014/05/05/understanding-products-and-universal-constructions/)
	- [Understanding Limits](https://bartoszmilewski.com/2014/05/08/understanding-limits-2/)
	- [Programming with Universal Constructions](https://bartoszmilewski.com/2019/07/03/programming-with-universal-constructions/)
- Серия публикаций Тай-Данаэ Брэдли с ресурса Института Math3ma:
	- [Limits and Colimits, Part 1 (Introduction)](https://www.math3ma.com/blog/limits-and-colimits-part-1)
	- [Limits and Colimits, Part 2 (Definitions)](https://www.math3ma.com/blog/limits-and-colimits-part-2)
	- [Limits and Colimits, Part 3 (Examples)](https://www.math3ma.com/blog/limits-and-colimits-part-3)
	- [A Diagram is a Functor](https://www.math3ma.com/blog/a-diagram-is-a-functor)
- Сопряжения:
	- [The power of adjunctions](https://bartoszmilewski.com/2019/09/20/the-power-of-adjunctions/)
	- [Adjoint triples](http://comonad.com/reader/2016/adjoint-triples/)



Блог Дана Дойля
http://comonad.com/reader/2016/adjoint-triples/

# Промежуточный итог


> The concept of _adjoint functors_ [[Kan (1958)](https://ncatlab.org/nlab/show/adjoint+functor#Kan58)] is a key concept in [category theory](https://ncatlab.org/nlab/show/category+theory) — if not _the_ key concept — and it is in large part through the manifold identification of examples of adjoint functors appearing ubiquituously in the practice of [mathematics](https://ncatlab.org/nlab/show/mathematics) that category theoretic tools are brought to use in general mathematics.