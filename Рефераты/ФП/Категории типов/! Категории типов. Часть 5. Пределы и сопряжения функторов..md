### !!! Вступление
# Универсальные свойства типов

В одной из предыдущих частей обзора [был продемонстрирован](https://habr.com/ru/articles/933016/#anyfunctor) функтор, связывающий две разные категории одного и того же объекта — категории типов $\star$. Только в начальной категории морфизмами выступали конструкторы типов `F[_]`, а в конечной — эндофункторы `Functor[F]`. Полученный функтор сохранял композицию конструкторов типов, позволяя из любых `Functor[F]` и `Functor[G]` создавать `Functor[G ∘ F]`. А это, в свою очередь, означает, что если имеются реализации эндофункторов для каких-либо *базовых* `F[_]`, у нас автоматически есть эндофункторы для абсолютно любых контейнерных типов!

Открытым остаётся вопрос, какие конструкторы типов можно считать настолько «базовыми», что композируя их, можно получить вообще всё. В других моих статьях о теории типов неоднократно упоминалось об их алгебраической природе, о том, что в их основе лежат элементарные математические операции — сумма, произведение и экспоненциал (а также понятия нуля и единицы). Однако, мне приходилось всячески избегать объяснения, *почему* происходит именно так. Дело в том, что ключ к понимаю этого лежит в теории категорий, так что только сейчас настало время разобраться с этим вопросом.

В первом обзоре цикла [упоминалось](https://habr.com/ru/articles/758542/#types), что любой тип можно определить через его *универсальное свойство*. Это понятие заимствовано из теории категории, с его помощью формулируются новые конструкции в категориях. Поэтому сперва давайте разберёмся, как это работает.

В качестве примера напомню универсальное свойство произведения объектов:
> произведением двух объектов $A$ и $B$ выбранной категории называется такой объект $A \times B$ с морфизмами $p_A: A \times B \rightarrow A$ и $p_B: A \times B \rightarrow B$, что для любых объекта $C$ и морфизмов $f: C \rightarrow A$ и $g: C \rightarrow B$ будет существовать единственный морфизм $u: C \rightarrow A \times B$, делающий такую диаграмму коммутирующей:


 ![[произведение типов.png|600]]

Определяемый объект $A \times B$, также как и все кандидаты $C$, имеют аналогичную пару морфизмов, идущих от них к $A$ и $B$. Но среди всех кандидатов выделяется лишь один универсальный объект $A \times B$ — его *универсальный морфизм* $u$ будет единственным *для любого* другого кандидата. Все остальные кандидаты будут либо сложнее (например, морфизм $A \times B \rightarrow A \times B \times X$ будет не единственным), либо диаграмма не будет коммутировать (по сути, любой кандидат, но выбранные для него морфизмы $f$ и $g$ не полиморфны по $A$, или $B$).

Определение любого универсального свойства в категории имеет такую структуру:
- обозначаются объекты, *через которые формулируется* универсальный (для произведения и суммы — это просто пара объектов $A, B$);
- выбирается семейство кандидатов с определёнными возможностями (в примере выше — пары морфизмов $f, g$ или $p_A, p_B$);
- для каждого кандидата определяется морфизм $u$, связывающий его с целевым универсальным объектом;
- такой морфизм обязан быть единственным и обеспечивающий коммутируемость полученной диаграммы.

Как перечисленные пункты описать в терминах категории типов? «Возможности» кандидата — это некие преобразования, связывающие его с объектами подкатегории, фиксирующими формулировку универсального свойства. А требование коммутируеммости диаграммы очень напоминает условие *естественности* этого преобразования!

Конечно же, тут подразумевается некая функториальность для конструктора типов `F[_, ...]`. Его параметры даже могут иметь разную вариантность, поэтому в общем случае придётся иметь дело с *мультипрофункторами*, но в этой статье мы будем иметь дело, в первую очередь, с ковариантными функторами и бифункторами.


# Конусы и ко-конусы

Давайте сперва посмотрим, как универсальные свойства выражаются с помощью естественных преобразований в некоторой категории $\mathcal{C}$. Объекты, через которые формулируется универсальный объект, образуют подкатегорию в $\mathcal{C}$. Для произведения объектов $a$ и $b$ такая подкатегория будет дискретной, содержащей только эти два объекта и их тождественные морфизмы. Но в случае других универсальных свойств устройство подкатегории может быть и сложнее.

Выбор конкретной подкатегории в $\mathcal{C}$ удобно выразить с помощью функтора, встраивающего в $\mathcal{C}$ некую модельную категорию $\mathcal{I}$. В случае универсального свойства произведения это и будет дискретная категория двух индексов, скажем, $1$ и $2$. Тогда функтор $F_{ab}: \mathcal{I} \rightarrow \mathcal{C}$ и будет отвечать за выбор конкретных $a$ и $b$ в $\mathcal{C}$.

Ещё нам нужно выбрать объект-кандидат . Поручим это **константному функтору** $\Delta\,c: \mathcal{I} \rightarrow \mathcal{C}$. Естественное преобразование $\Delta\,c \rightsquigarrow F$ называется **конусом** функтора :
$$
{\rm Cone}_F(c): \Delta c \leadsto F
$$

![[конусы!.png|Вы же наверняка заметили, что Ёжик конструировал именно конус, а вовсе не пирамидку!|800]]


Естественность преобразования важна для случаев, когда в модельной категории $\mathcal{I}$ есть другие морфизмы помимо тождественных (например, $1 \rightarrow 2$), и функтор $F$ переносит их в также нетождественные морфизмы ($a \rightarrow b$).

Образ функтора $F$ образует подкатегорию $F\, \mathcal{I} \subset \mathcal{C}$, являющуюся «основанием» этого конуса, а объект $c: \mathcal{C}$ будет его вершиной:
### !!! Рисунок конуса !!!


Для универсального свойства суммы объектов получим дуальную картину. Напомню,
> суммой двух объектов $A$ и $B$ выбранной категории называется такой объект $A + B$ с морфизмами $i_A: A \rightarrow A + B$ и $i_B: B \rightarrow A + B$, что для любых объекта $D$ и морфизмов $f: A \rightarrow D$ и $g: B \rightarrow D$ будет существовать единственный морфизм $u: A + B \rightarrow D$, делающий такую диаграмму коммутирующей:

![[сумма типов.png|600]]

В сравнении с произведением, объекты на диаграмме сохранили своё положение, но все морфизмы оказались обращены. Кандидаты в сумму объектов описываются дуальной конструкцией, называемой **ко-конусом**:
$$
{\rm Cocone}_F(c): F \rightsquigarrow \Delta c
$$
На диаграмме получаем как бы «перевёрнутый конус»:
### !!! Рисунок ко-конуса !!!

Обратите внимание, что и моделирующая категория $\mathcal{I}$ и функтор $F$ остались теми же, что и для произведения типов! Изменилось только направление естественного преобразования.

### !! намёк на фундаментальность суммы и произведения 

Кандидаты в универсальные объекты можно выразить либо через конусы, либо ко-конусы. Осталось только выбрать среди них *тот самый универсальный* (если он вообще существует).


# Пределы и копределы

В формулировке универсального свойства упоминаются морфизмы, связывающие кандидатов и универсальные объекты так, что при этом не ломаются (ко)конусы («…делают диаграмму коммутирующей…»). Эти морфизмы образуют отношение частичного порядка среди кандидатов. Тогда может получиться так, что среди всех кандидатов выделяется «особенный», связанный с другими единственным (для каждого) универсальным морфизмом. Если такой объект существует (а это возможно далеко не всегда!), его (ко)конус, и, следовательно, он сам будут считаться «универсальными». Универсальный (ко)конус зависит лишь от функтора $F:\: \mathcal{I} \rightarrow \mathcal{C}$, он носит название **(ко)предел функтора $F$** и обозначается как ${\rm Lim}\,F$ (${\rm Colim}\,F$).
### !!! РИСУНОК ДЛЯ ПРЕДЕЛА/КОПРЕДЕЛА

Предел и копредел можно также трактовать как функторы, действующие из категории функторов: ${\rm Lim,\, Colim}:\: \mathcal{C}^\mathcal{I} \rightarrow \mathcal{C}$. В некотором смысле они противоположны диагональному функтору $\Delta:\: \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$.
### !!! РИСУНОК ДЛЯ функторов ПРЕДЕЛ/КОПРЕДЕЛ/ДИАГОНАЛЬНЫЙ

Чуть позднее мы рассмотрим этот аспект подробнее, а сейчас вернёмся к формализации (ко)пределов.

Итак, предельное универсальное свойство утверждает, что «…для каждого кандидата существует единственный морфизм в предел...». Очевидно, что речь идёт о *взаимно-однозначном соответствии кандидатов и морфизмов* между ними и пределом. Кандидаты представлены своими конусами, которые можно рассматривать как контравариантный функтор
$$
\mathrm{Cone}_F:\; \mathcal{C}^{op} \rightarrow \mathrm{Hom}_{\mathcal{C}^{\mathcal{I}}}(\Delta\, \_,\, F)
$$
Символ подчёркивания обозначает место, куда нужно подставить объект исходной категории.

С другой же стороны у нас обычные морфизмы ${\rm Hom}_{\mathcal{C}}(c,\, {\rm Lim}\, F)$, для которых получаем похожий контравариантный функтор:
$$
U_{Lim\ F}:\; \mathcal{C}^{op} \rightarrow {\rm Hom}_{\mathcal{C}}(\_,\, {\rm Lim}\, F)
$$
Не так важно, будут ли морфизмы между двумя объектами множествами, типами или чем-то ещё. В любом случае, они образуют дискретную категорию, в которую и приводят оба этих функтора.
### !!! РИСУНОК ДЛЯ этих функторов

Требуемая «взаимная однозначность» говорит о том, что эти функторы должны быть изоморфны друг другу, то есть предельное универсальное свойство задаётся парой встречных естественных преобразований, чьи композиции дают тождественные функторы:
$$
{\rm Cone}_F \cong \; U_{Lim\ F}
$$

### !!! В спойлер! Предпучки
> Подобные контравариантные функторы (отображающие объекты категории во множество морфизмов), называются *предпучками*. Тогда естественные изоморфизмы выше — это условия *представимости* предпучка (ко)конусов *в виде морфизмов* в предел функтора. Понятие «представимости» имеет большое значение в теории категорией и мы с ней ещё столкнёмся в данном обзоре.
> 
> Теория [пучков](https://ru.wikipedia.org/wiki/%D0%9F%D1%83%D1%87%D0%BE%D0%BA_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) сейчас активно развивается и «её инструментарий может оказаться очень полезным». Впрочем, этой фразой обычно и завершаются все упоминания предпучков))).
> 
> (Если кому-то интересно, то для того, чтобы называться полноценными «пучками», предпучкам не достаёт дополнительных ограничений… без которых программистам и так не плохо)))

В свою очередь, для копредела имеем естественный изоморфизм уже ковариантных функторов:
$$
\begin{eqnarray}
\mathrm{Cocone}_F&:\;& \mathcal{C} \rightarrow \mathrm{Hom}_{\mathcal{C}^{\mathcal{I}}}
(F,\, \Delta\, \_)\\
U^{Colim\ F}&:\;& \mathcal{C} \rightarrow {\rm Hom}_{\mathcal{C}}({\rm Colim}\, F,\, \_)\\
\\
&& {\rm Cocone}_F \cong \; U^{Colim\ F}
\end{eqnarray}
$$

В этих естественных изоморфизмах слева расположена совокупность (ко)конусов, индексированная только функтором $F$, а справа — только его (ко)предел. По сути, мы получаем уравнения для поиска (ко)предела функтора, но решать их в общем случае не просто.


## (Ко)пределы в категории типов

Как вообще можно построить новые типы? Исходно у нас нет возможности сделать что-то интересное с одним единственным типом, кроме как вернуть его же. Но можно попробовать скомбинировать пару существующих типов в какой-то новый. Получится функциональное отображение, на вход которому подаётся *два* типа, а на выходе получаем один новый. Это просто «двухдырочные» конструкторы типов вида `(*, *) => *`. Их можно трактовать как функторы из произведения категорий типов в неё же: $\star \times \star \rightarrow \star$. Произведение двух категорий типов моделируется дискретной категорией $\mathcal{I} = 2$, состоящей из двух индексов $1$ и $2$, так что наши бифункторы можно записать как $F_{ab}: \star^2 \rightarrow \star$. Его конусами будут естественные преобразования c компонентами, индексированными двумя объектами $\mathcal{I}$:
```scala
type Cone2[A, B] = [-C] =>> ( // C - кандидат
  C => A, // первая компонента естественного преобразования
  C => B  // вторая компонента естественного преобразования
)
```
С другой стороны у нас hom-тип, описывающий морфизмы из кандидата в предел:
```scala
type ULim[A, B] = [-C] =>> C => Lim[A, B]
```

Нам нужно выяснить, каким же может быть `Lim[A, B]`, чтобы эти контравариантные функторы для `Cone2[A, B][-_]` и `ULim[A, B][-_]` образовывали естественный изоморфизм
```scala
infix type ≅[F[_], G[_]] = (
  right: F ~> G,
  left : G ~> F,
)

summon[Cone2[A, B] ≅ ULim[A, B]]
```

К счастью, мы заранее знаем, что пределом будет произведение типов. В этом мы убедимся, реализовав изоморфизм:
```scala
type Lim[A, B] = A × B // (A, B)

given limIso: [A, B] => Cone2[A, B] ≅ ULim[A, B] = (
  right = [C] => (cone: (C => A, C => B)) => (c: C) => cone._1(c) -> cone._2(c),
  left  = [C] => (ulim: C => A × B) => (ulim andThen {_._1}) -> (ulim andThen {_._2})
)
```

Такой предел действительно минимален — морфизмы из других кандидатов в него будет *единственным образом забывать* любую лишнюю информацию. А будучи полиморфными, проекторы предела будут гарантировано факторизовать проекторы всех других кандидатов (сохранять коммутативность диаграммы). Значит, это и есть настоящее универсальное свойство предела для функтора, ответственного за выбор пары типов в категории $\star$.

Вообще, (ко)предел определяется не для категории индексов $\mathcal{I}$, а именно для функтора $\mathcal{I} \rightarrow \mathcal{C}$. Функторы бывают разные, в том числе, и $\Delta_c$ схлопывающий все морфизмы (не только тождественные!) в один. Однако, часто предел ищется только для наиболее «свободного» функтора, моделирующего категорию $\mathcal{I}$ в $\mathcal{C}$ без потерь. В этом случае, *(ко)предел определяется только структурой $\mathcal{I}$*. Например, очевидно, что если в дискретной $\mathcal{I}$ будет $n$ объектов, то пределом функтора из неё в типы будет кортеж из $n$ элементов. 

Формально, можно вывести несколько разных вариантов одного и того же предела функтора. Например, произведение типов можно описать с помощью кодирования Чёрча как `[A, B] =>> [C] => (A => B => C) => C`. Но для всех этих вариантов в левой части естественный изоморфизма будут всё те же конусы, а значит и правые части будут изоморфны для всех вариантов. Таким образом, *предел функтора единственен с точностью до изоморфизма (если он вообще существует)*.

Аналогично, убеждаемся, что копределом бифунктора $F_{ab}$ будет сумма типов:
```scala
type Cocone2[A, B] = [+C] =>> ( // C - кандидат
  A => C, // первая компонента естественного преобразования
  B => C  // вторая компонента естественного преобразования
)
type UColim[A, B] = [+C] =>> Colim[A, B] => C

type Colim[A, B] = A + B // A Either B

given colimIso: [A, B] => Cocone2[A, B] ≅ UColim[A, B] = (
  right = [C] => (cocone: (A => C, B => C)) => (colim: Colim[A, B]) =>
    colim.fold(cocone._1, cocone._2),
  left  = [C] => (ucolim: (A + B) => C) =>
    ((a: A) => ucolim(Left(a)), (b: B) => ucolim(Right(b))
)
```

В случае бо́льших размеров категории $\mathcal{I}$ наиболее близкой реализация копредела в Scala будет, пожалуй, перечисление:
```scala
enum Sum3[A, B, C]: // три конструктора:
  case One(a: A)
  case Two(b: B)
  case Tri(c: C)
```

Для экспоненциала в категории типов (то есть, функций `A => B`) также существует конструкция, которую можно интерпретировать как предел константного функтора $\Delta\, B$. Но теперь категория индексов $\mathcal{I}$ будет *дискретной категории значений* типа `A`. Компоненты конусов кандидатов будут иметь вид:
```scala
type ConeExp[A] = [-C] =>> ( // C - кандидат
  C => A, // первая компонента естественного преобразования
  C => B  // вторая компонента естественного преобразования
)
type ULim[A, B] = [-C] =>> C => Lim[A, B]
```
$$
\mathrm{Cone}_{\Delta B}(C)_A = A \rightarrow (C \rightarrow B)
$$
 Будучи функциями, эти компоненты эквивалентны `(A, C) => B`, так что когда кандидат является пределом $C = \mathrm{Lim}\, (\Delta B) = B^A$, получится известная функция «оценки» `eval: (A, A => B) => B`.

Итак, мы можем строить новые типы складывая, умножая и «возводя в степень» существующие. А как определяются универсальные свойства нулевого и единичного типов, «существующих изначально»? Да совершенно аналогичным способом! Только если раньше мы строили новые типы из двух, моделируемых категорией $\mathcal{I}=2$, теперь нам не требуется ни одного типа, что соответствует абсолютно пустой категории $\mathcal{I}=0$. Единственно возможный функтор честно отображает пустую категорию в пустую диаграмму в $\star$, и от (ко)конусов остаются одни лишь вершины-кандидаты. В случае предела полученного функтора все универсальные морфизмы будут вести *к нему*, в то время как для копредела они будут вести *от него* к кандидатам. Это в точности соответствует универсальным свойствам *терминального и начального объектов* в категории типов — единичного (`Unit`) и нулевого (`Nothing`) типов!

Помимо вышеперечисленных, иногда говорят и о других (ко)пределах функторов, основанных на недискретных индексных категориях, то есть, имеющих морфизмы между объектами. В частности,
- предел и копредел диаграммы $1 \rightrightarrows 2$ (помимо тождественных, есть два дополнительных морфизма между объектами) — [уравнитель](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) и [коуравнитель](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%83%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C) ~~функций~~ морфизмов;
- предел диаграммы $1 \rightarrow 2 \leftarrow 3$  — [декартов квадрат](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82) (расслоённое произведение, pullback);
- копредел диаграммы $1 \leftarrow 2 \rightarrow 3$  — [кодекартов квадрат](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82) (расслоённая сумма, амальгама, pushout).

Однако «честные» реализации соответствующих типов не возможны без привлечения специальных техник Scala, основанных на идее зависимых типов, поэтому мы не будем останавливаться на них в данном обзоре.


## Непрерывность и когерентность функторов

Пределы и копределы очень важны для большинства категорий, поэтому часто возникает вопрос о том, как с ними взаимодействуют функторы. Если функтор $F$ сохраняет пределы любых других функторов $G$, он называется *непрерывным*:

$$
{\rm Lim}\,(F \circ G) = (F \circ {\rm Lim})\, G.
$$
(Напомню, предел — это функтор, определённый на категории функторов. То есть, его можно как композировать с другими функторами, так и применять к ним.)

Самый «базовый» предел для категории типов — это произведение типов. Практически все остальные пределы строятся на его основе, поэтому непрерывность функтора обычно проверяют выясняя, сохраняет ли он произведение. Но в более общем случае для гарантии непрерывности требуется проверка сохранения и других пределов.

Сохранение же копределов говорит о *когерентности* функтора. Для функторов в категории типов обычно проверяют, сохраняют ли они сумму типов, как базовый копредел. И, опять же, более полная проверка требует рассмотрения коуравнителей и других копределов.

Среди эндофункторов в категории типов непрерывно-когерентным будет только тождественный функтор.

> Наиболее важное свойство сопряжённых функторов — их непрерывность: каждый функтор, имеющий левый сопряжённый (то есть являющийся правым сопряжённым), коммутирует с [пределами](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\) "Предел (теория категорий)") в категорном смысле. Соответственно, функтор, имеющий правый сопряжённый, _конепрерывен_, то есть коммутирует с [копределами](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\)&action=edit&redlink=1 "Копредел (теория категорий) (страница отсутствует)").


# Сопряжения функторов

Пределы и копределы формулируются для конкретных функторов, вроде рассмотренного выше $F_{a, b}:\: 2 \rightarrow \mathcal{C}$. Каждый такой функтор *выбирает в конечной категории, в каком именно месте* будет смоделирована исходная. Между тем, натуральные изоморфизмы, определяющие предел и копредел намекают, что существуют глобальные взаимоотношения, не завязанные на выбор конкретного функтора $F_{a, b}$. Эти взаимоотношения и станут ключом к пониманию основных операций над типами — суммой, произведением и экспоненциалом.

Рассмотрим внимательнее представленный ранее натуральный изоморфизм, определяющий предел. Он индексирован объектом $c:\: \mathcal{C}$ и функтором $F:\: \mathcal{C}^\mathcal{I}$, и представлен парой естественных преобразований, действующих навстречу друг другу:
$$
\begin{split}
left(c,F)&:&\: (\Delta c \rightsquigarrow F) &\rightarrow (c \rightarrow \mathrm{Lim}\,F),\\
right(c,F)&:&\: (c \rightarrow \mathrm{Lim}\,F) &\rightarrow (\Delta c \rightsquigarrow F).
\end{split}
$$
В целях обобщения, попробуем реорганизовать эти конструкции, избавившись от упоминания $c$ и $F$. Сперва для наглядности перепишем их через hom-объекты:
$$
\begin{split}
left(c,F)&:\: \mathrm{Hom}_{\mathcal{C}^\mathcal{I}}&&(\Delta& c,\,& &F) &\rightarrow \mathrm{Hom}_{\mathcal{C}}&&(&c,\;& \mathrm{Lim}\,&F),\\
right(c,F)&:\: \mathrm{Hom}_{\mathcal{C}}&&(&c,\;& \mathrm{Lim}\, &F) &\rightarrow \mathrm{Hom}_{\mathcal{C}^\mathcal{I}}&&(\Delta &c,\,& &F).
\end{split}
$$
Тут лучше виден паттерн в расположении $c$ и $F$ относительно функторов $\Delta:\: \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$ и $\mathrm{Lim}:\: \mathcal{C}^\mathcal{I} \rightarrow \mathcal{C}$ . В первом выражении давайте избавимся от $F$, подставив вместо него $\Delta c$, тогда слева от стрелки получится $\mathrm{Hom}_{\mathcal{C}^\mathcal{I}}(\Delta c,\, \Delta c)$. Можем передать сюда тождественный функтор $id_{\mathcal{C}^\mathcal{I}}$, при этом останется лишь то, что правее стрелки — $\mathrm{Hom}_{\mathcal{C}}(c,\; \mathrm{Lim}\,\Delta c)$. Перепишем это так:
$$
left(c, \Delta c)(id_{\mathcal{C}^\mathcal{I}}):\: c \rightarrow (\mathrm{Lim} \circ \Delta)c.
$$
Аналогично, если в правую ветку вместо $c$ подставить $\mathrm{Lim}\,F$, и передать туда $id_{\mathcal{C}}$, получим
$$
right(\mathrm{Lim}\,F, F)(id_{\mathcal{C}}):\: (\Delta \circ \mathrm{Lim})F \rightarrow F.
$$
Оба выражения оказались индексированы только одним параметром и, очевидно, что они представляют собой компоненты естественных преобразований:
$$
\begin{split}
\eta_{\mathrm{Lim},\Delta}&:\:& id_{\mathcal{C}} \rightsquigarrow \mathrm{Lim} \circ \Delta &=
\forall c: \mathcal{C}&& .\; left(c, &&\Delta c&&)(id_{\mathcal{C}^\mathcal{I}})\\

\varepsilon_{\mathrm{Lim},\,\Delta}&:\:& \Delta \circ \mathrm{Lim} \rightsquigarrow id_{\mathcal{C}^\mathcal{I}} &=
\forall F: \mathcal{C}^\mathcal{I}&& .\; right(\mathrm{Lim}\,F, && \,\,\,F &&)(id_{\mathcal{C}})
\end{split}
$$
Подобные преобразования могут существовать не только для $\mathrm{Lim}$ и $\Delta$ но и для других встречных функторов. Они определяют такое понятие, как **сопряжение функторов**:
$$
\begin{split}
F \dashv G&:&\\
\eta&:&\: id \rightsquigarrow G \circ F,\\
\varepsilon&:&\: F \circ G \rightsquigarrow id.\\
\end{split}
$$


### !!! Рисунок для сопряжения !!!

Преобразования $\eta$ и $\varepsilon$ называются «единицей» и «коединицей» сопряжения. Между ними существуют очевидные условия консистентности — приведённые ниже треугольники будут коммутировать:
### !!! Рисунок для треугольников !!!

Признаком наличия сопряжения между какими-то функторами как раз и является наличие естественного изоморфизма между hom-объектами в разных категориях.
![[Pasted image 20250905101810.png]]

Очень важный момент — *сопряжение функторов не является отношением порядка*. Оно не транзитивно, то есть, если $F \dashv G$ и $G \dashv H$, то вовсе не обязательно, что $F \dashv H$. Сопряжение, не является свойством одного функтора по отношению к другим. Зато его можно интерпретировать как «ослабленную эквивалентность категорий» для случаев, когда строгая эквивалентность не нужна. Действительно, категории $\mathcal{C}$ и $\mathcal{D}$ считались бы эквивалентными, если бы для встречных функторов $F$ и $G$ между ними существовали бы натуральные изоморфизмы: $F \circ G \cong id_{\mathcal{D}}$ и $G \circ F \cong id_{\mathcal{C}}$. А в случае сопряжений не нужны полные изоморфизмы, состоящие из четырёх естественных преобразований — достаточно лишь двух из них: $id_{\mathcal{D}} \rightsquigarrow G \circ F$ и $F \circ G \rightsquigarrow id_{\mathcal{C}}$.


## Монады и комонады
 
В примере с диагональным функтором и пределом приходилось работать не только с привычной категорией типов $\mathcal{C}$, но и с «неудобной» категорией функторов $\mathcal{C}^\mathcal{I}$. И также получается со многими сопряжениями — даже если какая-та категория нам и интересна, то с другой может и не повезти. Тогда какая может быть практическая польза от этих сопряжений?

Дело в том, что наибольший интерес представляют не сами функторы, участвующие в сопряжении $F \dashv G$, но их *композиций* $F \circ G$ и $G \circ F$. Во-первых, обе этих композиции являются *эндофункторами* в своих категориях. А во-вторых, естественные преобразования сопряжения автоматически формируют для этих эндофункторов *монаду* и *комонаду* соответственно!

Действительно, «запаковка» $G \circ F$ и «распаковка» $F \circ G$ совпадают с единицей $\eta$ и коединицей $\varepsilon$ сопряжения, а «разматрёшивание» $G \circ F$ и «заматрёшивание» $F \circ G$ выражаются так:
$$
\begin{eqnarray}
\mu&:\;&&& (G \circ F) \circ (G \circ F) &\rightsquigarrow&& G \circ F &= id_G \circ \varepsilon \circ id_G,\\
\delta&:\;&&& F \circ G &\rightsquigarrow&& (F \circ G) \circ (F \circ G) &= id_F \circ \eta \circ id_G.
\end{eqnarray}
$$

Таким образом, сопряжение функторов порождает монаду и комонаду. Но верно и обратное — любую (ко)монаду можно разложить на пару сопряжённых функторов. Только такое разложение будет неоднозначным, ведь заранее даже не известно, через какую дополнительную категорию будет факторизоваться эндофунктор.

Получается, что задачу вычисления монадных возможностей эндофунктора можно свести к поиску любого его разложения на сопряжённые функторы. Причём, эти функторы могут соединять с категорией, отличной от первоначальной. Приблизит ли нас это к решению задачи?

В продолжении обзора будет показано, что существуют конструктивные методы поиска сопряжений, так что, как минимум, в частных случаях это должно помогать находить монаду для эндофунктора. А пока разберём ещё несколько любопытных особенностей сопряжений.



## !!! Тройки сопряжений.

Проведя все те же рассуждения для копредела, получим, что $\Delta \dashv \mathrm{Lim}$.

[The power of adjunctions](https://bartoszmilewski.com/2019/09/20/the-power-of-adjunctions/)
[Adjoint triples](http://comonad.com/reader/2016/adjoint-triples/)


Композиция сопряжений: из пары сопряжений получаем новые
>So there are two ways to compose the adjunctions, giving two induced adjunctions: $FG ⊣ HG$,  $GF ⊣ GH$

>So each adjoint triple gives rise to two adjunctions between monads and comonads.

>$alg: GFA \rightarrow A$ $coalg: A \rightarrow GHA$ but these types are isomorphic according to the `GF ⊣ GH` adjunction. Thus, one might guess that `GF` monad algebras are also `GH` comonad coalgebras, and that in such a situation, we actually have some structure that can be characterized both ways. In fact this is true for any monad left adjoint to a comonad; but all adjoint triples give rise to these.



## !!! Произведение, сумма и экпоненциал из сопряжения

[Product from Adjunction](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=Product%20from%20Adjunction)

[Exponential from Adjunction](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=Exponential%20from%20Adjunction)


## !!! Забывающе-свободные сопряжения



# Дополнительная литература

- [Теория категорий на JavaScript. Часть 1. Категория множеств](https://habr.com/ru/companies/cit/articles/313254/) — безо всяких формул, но с помощью пёстрых диаграмм раскрываются на ~~пальцах~~ множествах различные универсальные свойства.
- [Understanding limits in Set](https://ncatlab.org/nlab/show/Understanding+limits+in+Set) — одна из самых «демократичных» среди прочих «математичных» статей на nLab.
- Серия публикаций Бартоша Милевски из его блога:
	- [Limits and Colimits](https://bartoszmilewski.com/2015/04/15/limits-and-colimits/)
	- [Understanding Products and Universal Constructions](https://bartoszmilewski.com/2014/05/05/understanding-products-and-universal-constructions/)
	- [Understanding Limits](https://bartoszmilewski.com/2014/05/08/understanding-limits-2/)
	- [Programming with Universal Constructions](https://bartoszmilewski.com/2019/07/03/programming-with-universal-constructions/)
- Серия публикаций Тай-Данаэ Брэдли с ресурса Института Math3ma:
	- [Limits and Colimits, Part 1 (Introduction)](https://www.math3ma.com/blog/limits-and-colimits-part-1)
	- [Limits and Colimits, Part 2 (Definitions)](https://www.math3ma.com/blog/limits-and-colimits-part-2)
	- [Limits and Colimits, Part 3 (Examples)](https://www.math3ma.com/blog/limits-and-colimits-part-3)
	- [A Diagram is a Functor](https://www.math3ma.com/blog/a-diagram-is-a-functor)

Блог Дана Дойля
http://comonad.com/reader/2016/adjoint-triples/

# Промежуточный итог


>Every time you hear the statement that there is some unique morphism, which factorizes some construction, you should think of it as a mapping of some set to a hom-set. That’s the meaning of “picking a unique morphism.”


>Factorization involves commuting diagrams — some morphism being equal to a composition of two morphisms (factors). A natural transformation maps morphisms to commuting diagrams.

> The concept of _adjoint functors_ [[Kan (1958)](https://ncatlab.org/nlab/show/adjoint+functor#Kan58)] is a key concept in [category theory](https://ncatlab.org/nlab/show/category+theory) — if not _the_ key concept — and it is in large part through the manifold identification of examples of adjoint functors appearing ubiquituously in the practice of [mathematics](https://ncatlab.org/nlab/show/mathematics) that category theoretic tools are brought to use in general mathematics.