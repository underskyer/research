### !!! Вступление
# Универсальные свойства типов

В одной из предыдущих частей обзора [был продемонстрирован](https://habr.com/ru/articles/933016/#anyfunctor) функтор, связывающий две разные категории одного и того же объекта — категории типов $\star$. Только в начальной категории морфизмами выступали конструкторы типов `F[_]`, а в конечной — эндофункторы `Functor[F]`. Полученный функтор сохранял композицию конструкторов типов, позволяя из любых `Functor[F]` и `Functor[G]` создавать `Functor[G ∘ F]`. А это, в свою очередь, означает, что если имеются реализации эндофункторов для каких-либо *базовых* `F[_]`, у нас автоматически есть эндофункторы для абсолютно любых контейнерных типов!

Открытым остаётся вопрос, какие конструкторы типов можно считать настолько «базовыми», что композируя их, можно получить вообще всё. В других моих статьях о теории типов неоднократно упоминалось об их алгебраической природе, о том, что в их основе лежат элементарные математические операции — сумма, произведение и экспоненциал (а также понятия нуля и единицы). Однако, мне приходилось всячески избегать объяснения, *почему* происходит именно так. Дело в том, что ключ к понимаю этого лежит в теории категорий, так что только сейчас настало время разобраться с этим вопросом.

В первом обзоре цикла [упоминалось](https://habr.com/ru/articles/758542/#types), что любой тип можно определить через его *универсальное свойство*. Это понятие заимствовано из теории категории, с его помощью формулируются новые конструкции в категориях. Поэтому сперва давайте разберёмся, как это работает.

В качестве примера напомню универсальное свойство произведения объектов:
> произведением двух объектов $A$ и $B$ выбранной категории называется такой объект $A \times B$ с морфизмами $p_A: A \times B \rightarrow A$ и $p_B: A \times B \rightarrow B$, что для любых объекта $C$ и морфизмов $f: C \rightarrow A$ и $g: C \rightarrow B$ будет существовать единственный морфизм $u: C \rightarrow A \times B$, делающий такую диаграмму коммутирующей:


 ![[произведение типов.png|600]]

Определяемый объект $A \times B$, также как и все кандидаты $C$, имеют аналогичную пару морфизмов, идущих от них к $A$ и $B$. Но среди всех кандидатов выделяется лишь один универсальный объект $A \times B$ — его *универсальный морфизм* $u$ будет единственным *для любого* другого кандидата. Все остальные кандидаты будут либо сложнее (например, морфизм $A \times B \rightarrow A \times B \times X$ будет не единственным), либо диаграмма не будет коммутировать (по сути, любой кандидат, но выбранные для него морфизмы $f$ и $g$ не полиморфны по $A$, или $B$).

Определение любого универсального свойства в категории имеет такую структуру:
- обозначаются объекты, *через которые формулируется* универсальный (для произведения и суммы — это просто пара объектов $A, B$);
- выбирается семейство кандидатов с определёнными возможностями (в примере выше — пары морфизмов $f, g$ или $p_A, p_B$);
- для каждого кандидата определяется морфизм $u$, связывающий его с целевым универсальным объектом;
- такой морфизм обязан быть единственным и обеспечивающий коммутируемость полученной диаграммы.

Как перечисленные пункты описать в терминах категории типов? «Возможности» кандидата — это некие преобразования, связывающие его с объектами подкатегории, фиксирующими формулировку универсального свойства. А требование коммутируеммости диаграммы очень напоминает условие *естественности* этого преобразования!

Конечно же, тут подразумевается некая функториальность для конструктора типов `F[_, ...]`. Его параметры даже могут иметь разную вариантность, поэтому в общем случае придётся иметь дело с *мультипрофункторами*, но в этой статье мы будем иметь дело, в первую очередь, с ковариантными функторами и бифункторами.


# Конусы и ко-конусы

Давайте сперва посмотрим, как универсальные свойства выражаются с помощью естественных преобразований в некоторой категории $\mathcal{C}$. Объекты, через которые формулируется универсальный объект, образуют подкатегорию в $\mathcal{C}$. Для произведения объектов $a$ и $b$ такая подкатегория будет дискретной, содержащей только эти два объекта и их тождественные морфизмы. Но в случае других универсальных свойств устройство подкатегории может быть и сложнее.

Выбор конкретной подкатегории в $\mathcal{C}$ удобно выразить с помощью функтора, встраивающего в $\mathcal{C}$ некую модельную категорию $\mathcal{I}$. В случае универсального свойства произведения это и будет дискретная категория двух индексов, скажем, $1$ и $2$. Тогда функтор $F_{ab}: \mathcal{I} \rightarrow \mathcal{C}$ и будет отвечать за выбор конкретных $a$ и $b$ в $\mathcal{C}$.

Ещё нам нужно выбрать объект-кандидат . Поручим это **константному функтору** $\Delta\,c: \mathcal{I} \rightarrow \mathcal{C}$. Естественное преобразование $\Delta\,c \rightsquigarrow F$ называется **конусом** функтора :
$$
{\rm Cone}_F(c): \Delta c \leadsto F
$$

![[конусы!.png|Вы же наверняка заметили, что Ёжик конструировал именно конус, а вовсе не пирамидку!|800]]


Естественность преобразования важна для случаев, когда в модельной категории $\mathcal{I}$ есть другие морфизмы помимо тождественных (например, $1 \rightarrow 2$), и функтор $F$ переносит их в также нетождественные морфизмы ($a \rightarrow b$).

Образ функтора $F$ образует подкатегорию $F\, \mathcal{I} \subset \mathcal{C}$, являющуюся «основанием» этого конуса, а объект $c: \mathcal{C}$ будет его вершиной:
### !!! Рисунок конуса !!!


Для универсального свойства суммы объектов получим дуальную картину. Напомню,
> суммой двух объектов $A$ и $B$ выбранной категории называется такой объект $A + B$ с морфизмами $i_A: A \rightarrow A + B$ и $i_B: B \rightarrow A + B$, что для любых объекта $D$ и морфизмов $f: A \rightarrow D$ и $g: B \rightarrow D$ будет существовать единственный морфизм $u: A + B \rightarrow D$, делающий такую диаграмму коммутирующей:

![[сумма типов.png|600]]

В сравнении с произведением, объекты на диаграмме сохранили своё положение, но все морфизмы оказались обращены. Кандидаты в сумму объектов описываются дуальной конструкцией, называемой **ко-конусом**:
$$
{\rm Cocone}_F(c): F \rightsquigarrow \Delta c
$$
На диаграмме получаем как бы «перевёрнутый конус»:
### !!! Рисунок ко-конуса !!!

Обратите внимание, что и моделирующая категория $\mathcal{I}$ и функтор $F$ остались теми же, что и для произведения типов! Изменилось только направление естественного преобразования.

### !! намёк на фундаментальность суммы и произведения 

Кандидаты в любые универсальные объекты можно выразить либо через конусы, либо ко-конусы. Осталось только найти среди них *тот самый универсальный* (если он вообще есть).


# Пределы и копределы

В формулировке универсального свойства упоминаются морфизмы, связывающие кандидатов и универсальные объекты так, что при этом не ломаются (ко)конусы («…делают диаграмму коммутирующей…»). Эти морфизмы образуют отношение частичного порядка среди кандидатов. Тогда может получиться так, что среди всех кандидатов выделяется «особенный», связанный с другими единственным (для каждого) универсальным морфизмом. Если такой объект существует (а это возможно далеко не всегда!), его (ко)конус, и, следовательно, он сам будут считаться «универсальными». Универсальный (ко)конус зависит лишь от функтора $F:\: \mathcal{I} \rightarrow \mathcal{C}$, он носит название **(ко)предел функтора $F$** и обозначается как ${\rm Lim}\,F$ (${\rm Colim}\,F$).
### !!! РИСУНОК ДЛЯ ПРЕДЕЛА/КОПРЕДЕЛА

Предел и копредел можно также трактовать как функторы, действующие из категории функторов: ${\rm Lim,\, Colim}:\: \mathcal{C}^\mathcal{I} \rightarrow \mathcal{C}$. В некотором смысле они противоположны диагональному функтору $\Delta:\: \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$.
### !!! РИСУНОК ДЛЯ функторов ПРЕДЕЛ/КОПРЕДЕЛ/ДИАГОНАЛЬНЫЙ

Чуть позднее мы рассмотрим этот аспект подробнее, а сейчас вернёмся к формализации (ко)пределов.

Итак, «…*для каждого* кандидата существует единственный универсальный морфизм...» Очевидно, что речь идёт о *взаимно-однозначном соответствии* кандидатов и универсальных морфизмов между ними и (ко)пределом. Причём, кандидаты определяются не столько объектами в категории $\mathcal{C}$, сколько связанными с ними конусами. Ведь формально универсальное свойство объекта представляет именно конус, который, будучи естественным преобразованием $\Delta c \rightsquigarrow F$, может иметь несколько различных реализаций. Все конусы, индексированные объектами категории $\mathcal{C}$ представляют собой функтор в категорию конусов $F$:
$$
\mathcal{F}_{cone}: \mathcal{C} \rightarrow {\rm Cone}_F
$$

С другой стороны у нас обычные морфизмы ${\rm Hom}_{\mathcal{C}}(c,\, {\rm Lim}\, F)$. Они также индексированы объектами из $\mathcal{C}$ так, что получается функтор в категорию морфизмов из некого $c:\mathcal{C}$ в предел:
$$
\mathcal{F}_{hom}: \mathcal{C} \rightarrow {\rm Hom}_{\mathcal{C}}(\_,\, {\rm Lim}\, F)
$$
Несложно заметить, что оба функтора будут *контравариантными*. Область определения у них одна и та же — категория $\mathcal{C}$. А с областью значений всё немного интереснее. Дело в том, что конусы являются морфизмами в категории функторов, и дабы избежать парадоксов, принято считать, что все категории, с которыми мы работаем, являются *локально-малыми* — все морфизмы между двумя объектами *обязаны образовывать множество*. То есть, получается, что области значений обоих контравариантных функторов являются подкатегориями для дискретной категории ${\rm Set}$, следовательно функторы будут одного и того же типа:
$$
\mathcal{F}_{cone},\, \mathcal{F}_{hom}:\: \mathcal{C} \rightarrow {\rm Set}
$$

Для нас, программистов, картина не сильно поменяется, если в этом выражении заменить категорию множеств на дискретную же категорию значений (например, типа `Any`). Получим что-то вроде 
$$
\mathcal{F}_{cone},\, \mathcal{F}_{hom}:\: \star \rightarrow Any
$$

В любом случае, получается, что универсальное свойство задаётся *естественным изоморфизмом* этих функторов, то есть парой встречных естественных преобразований между ними, чьи композиции дают тождественные функторы:
$$
{\rm Cone}_F \cong \;{\rm Hom}_{\mathcal{C}}(\_,\, {\rm Lim}\,F)
$$
И для копредела будет дуальное выражение:
$$
{\rm Cocone}_F \cong \;{\rm Hom}_{\mathcal{C}}({\rm Colim}\,F,\, \_)
$$

В этих естественных изоморфизмах слева расположена совокупность (ко)конусов, индексированная только функтором $F$, а справа — только его (ко)предел. Мы получаем уравнения для поиска (ко)предела функтора! Впрочем, решать их совсем не просто.

### !!! В спойлер! Предпучки
> Подобные контравариантные функторы (отображающие объекты категории во множество морфизмов), называются *предпучками*. Тогда естественные изоморфизмы выше — это условия *представимости* предпучка (ко)конусов *в виде морфизмов* в предел функтора. Понятие «представимости» имеет большое значение в теории категорией и мы с ней ещё столкнёмся в данном обзоре.
> 
> Теория [пучков](https://ru.wikipedia.org/wiki/%D0%9F%D1%83%D1%87%D0%BE%D0%BA_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) сейчас активно развивается и «её инструментарий может оказаться очень полезным». Впрочем, этой фразой обычно и завершаются все упоминания предпучков))).
> 
> (Если кому-то интересно, то для того, чтобы называться полноценными «пучками», предпучкам не достаёт дополнительных ограничений… без которых программистам и так не плохо)))




## (Ко)пределы в категории типов


Как вообще можно построить новые типы? Исходно у нас нет возможности сделать что-то интересное с одним единственным типом, кроме как вернуть его же. Но можно попробовать скомбинировать пару существующих типов в какой-то новый. Получится функциональное отображение, на вход которому подаётся *два* типа, а на выходе получаем один новый. Это просто «двухдырочные» конструкторы типов вида `(*, *) => *`. Их можно трактовать как функторы из произведения категорий типов в неё же: $\star \times \star \rightarrow \star$. Произведение двух категорий типов моделируется дискретной категорией $\mathcal{I} = 2$, состоящей из двух индексов $1$ и $2$, так что наши бифункторы можно записать как $F_{ab}: \star^2 \rightarrow \star$. Его конусами будут естественные преобразования c компонентами, индексированными объектами $\mathcal{I}$:
$$
\begin{split}
{\rm Cone}_{F_{ab}}(c)_1&: c \rightarrow a,\\
{\rm Cone}_{F_{ab}}(c)_2&: c \rightarrow b.
\end{split}
$$
Да, это просто пара проекторов типа-кандидата!

Для дискретной $\mathcal{I}$ самый минимальный полиморфный универсальный объект обладает только теми возможностями, которые описываются компонентами конуса. Получается, что
$$
{\rm Lim}\, F_{ab} = \forall i:\mathcal{I}.\, F_{ab}(i).
$$
Это что-то вроде индексированного списка, у каждого элемента которого будет свой тип (~~зависимое произведение~~). Cамое близкое в Scala — это кортеж, соответствующий произведению типов:
```scala
infix type ×[A, B] = (A, B)
```
Он действительно минимален — морфизмы из других кандидатов в него будет *единственным образом забывать* любую лишнюю информацию. А будучи полиморфными, проекторы предела будут гарантировано факторизовать проекторы всех других кандидатов (сохранять коммутативность диаграммы).

Вообще, (ко)предел определяется не для категории индексов $\mathcal{I}$, а именно для функтора $\mathcal{I} \rightarrow \mathcal{C}$. Функторы бывают разные, в том числе, и $\Delta_c$ схлопывающий все морфизмы (не только тождественные!) в один. Однако, часто предел ищется только для наиболее «свободного» функтора, моделирующего категорию $\mathcal{I}$ в $\mathcal{C}$ без потерь. В этом случае, *(ко)предел определяется только структурой $\mathcal{I}$*. Например, очевидно, что если в дискретной $\mathcal{I}$ будет $n$ объектов, то пределом функтора из неё в типы будет кортеж из $n$ элементов. 

Формально, можно вывести несколько разных вариантов одного и того же предела функтора. Например, произведение типов можно описать с помощью кодирования Чёрча как `[A, B] =>> [C] => (A => B => C) => C`. Но все эти варианты будут изоморфны друг другу — предел функтора (если он существует) *единственен с точностью до изоморфизма*.

Аналогично, для бифунктора $F_{ab}$ можно также определить и ко-конусы с компонентами
$$
\begin{split}
{\rm Cocone}_{F_{ab}}(c)_1&: a \rightarrow c,\\
{\rm Cocone}_{F_{ab}}(c)_2&: b \rightarrow c.
\end{split}
$$
Очевидно, что это естественное преобразование задаёт для копредела «левый» и «правый» *конструкторы* суммы типов:
```scala
infix type +[A, B] = A Either B
// конструкторы Left и Right
```

В Scala наиболее близкой реализация копредела в случае бо́льших размеров категории $\mathcal{I}$ будет, пожалуй, перечисление:
```scala
enum Sum3[A, B, C]: // три конструктора:
  case One(a: A)
  case Two(b: B)
  case Tri(c: C)
```

В категории типов для экспоненциала `A => B` также существует конструкция, которую можно интерпретировать как предел константного функтора $\Delta\, B$ из *дискретной категории значений* типа `A` в категорию типов. Компоненты конусов кандидатов будут иметь вид:
$$
\mathrm{Cone}_{\Delta B}(C)_A = A \rightarrow (C \rightarrow B)
$$
 Будучи функциями, эти компоненты эквивалентны `(A, C) => B`, так что когда кандидат является пределом $C = \mathrm{Lim}\, (\Delta B) = B^A$, получится известная функция «оценки» `eval: (A, A => B) => B`.

Итак, мы можем строить новые типы складывая, умножая и «возводя в степень» существующие. А как определяются универсальные свойства нулевого и единичного типов, «существующих изначально»? Да совершенно аналогичным способом! Только если раньше мы строили новые типы из двух, моделируемых категорией $\mathcal{I}=2$, теперь нам не требуется ни одного типа, что соответствует абсолютно пустой категории $\mathcal{I}=0$. Единственно возможный функтор честно отображает пустую категорию в пустую диаграмму в $\star$, и от (ко)конусов остаются одни лишь вершины-кандидаты. В случае предела полученного функтора все универсальные морфизмы будут вести *к нему*, в то время как для копредела они будут вести *от него* к кандидатам. Это в точности соответствует универсальным свойствам *терминального и начального объектов* в категории типов — единичного (`Unit`) и нулевого (`Nothing`) типов!

Помимо вышеперечисленных, иногда говорят и о других (ко)пределах функторов, основанных на недискретных индексных категориях, то есть, имеющих морфизмы между объектами. В частности,
- предел и копредел диаграммы $1 \rightrightarrows 2$ (помимо тождественных, есть два дополнительных морфизма между объектами) — [уравнитель](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) и [коуравнитель](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%83%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C) ~~функций~~ морфизмов;
- предел диаграммы $1 \rightarrow 2 \leftarrow 3$  — [декартов квадрат](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82) (расслоённое произведение, pullback);
- копредел диаграммы $1 \leftarrow 2 \rightarrow 3$  — [кодекартов квадрат](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82) (расслоённая сумма, амальгама, pushout).

Однако «честные» реализации соответствующих типов не возможны без привлечения специальных техник Scala, основанных на идее зависимых типов, поэтому мы не будем останавливаться на них в данном обзоре.


## Непрерывность и когерентность функторов

Пределы и копределы очень важны для большинства категорий, поэтому часто возникает вопрос о том, как с ними взаимодействуют функторы. Если функтор $F$ сохраняет пределы любых других функторов $G$, он называется *непрерывным*:

$$
{\rm Lim}\,(F \circ G) = (F\ \circ {\rm Lim})\, G.
$$

Самый «базовый» предел для категории типов — это произведение типов. Практически все остальные пределы строятся на его основе, поэтому непрерывность функтора обычно проверяют выясняя, сохраняет ли он произведение. Но в более общем случае для гарантии непрерывности требуется проверка сохранения и других пределов.

Сохранение же копределов говорит о *когерентности* функтора. Для функторов в категории типов обычно проверяют, сохраняют ли они сумму типов, как базовый копредел. И, опять же, более полная проверка требует рассмотрения коуравнителей и других копределов.

Среди эндофункторов в категории типов непрерывно-когерентным будет только тождественный функтор.

> Наиболее важное свойство сопряжённых функторов — их непрерывность: каждый функтор, имеющий левый сопряжённый (то есть являющийся правым сопряжённым), коммутирует с [пределами](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\) "Предел (теория категорий)") в категорном смысле. Соответственно, функтор, имеющий правый сопряжённый, _конепрерывен_, то есть коммутирует с [копределами](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\)&action=edit&redlink=1 "Копредел (теория категорий) (страница отсутствует)").


# Сопряжения функторов

Пределы и копределы формулируются для конкретных функторов, вроде рассмотренного выше $F_{a, b}:\: 2 \rightarrow \mathcal{C}$. Каждый такой функтор *выбирает в конечной категории, в каком именно месте* будет смоделирована исходная. Между тем, натуральные изоморфизмы, определяющие предел и копредел намекают, что существуют глобальные взаимоотношения, не завязанные на выбор конкретного функтора $F_{a, b}$. Эти взаимоотношения и станут ключом к пониманию основных операций над типами — суммой, произведением и экспоненциалом.

Рассмотрим внимательнее представленный ранее натуральный изоморфизм, определяющий предел. Он индексирован объектом $c:\: \mathcal{C}$ и функтором $F:\: \mathcal{C}^\mathcal{I}$, и представлен парой естественных преобразований, действующих навстречу друг другу:
$$
\begin{split}
left(c,F)&:&\: (\Delta c \rightsquigarrow F) &\rightarrow (c \rightarrow \mathrm{Lim}\,F),\\
right(c,F)&:&\: (c \rightarrow \mathrm{Lim}\,F) &\rightarrow (\Delta c \rightsquigarrow F).
\end{split}
$$
В целях обобщения, попробуем реорганизовать эти конструкции, избавившись от упоминания $c$ и $F$. Сперва для наглядности перепишем их через hom-объекты:
$$
\begin{split}
left(c,F)&:\: \mathrm{Hom}_{\mathcal{C}^\mathcal{I}}&&(\Delta& c,\,& &F) &\rightarrow \mathrm{Hom}_{\mathcal{C}}&&(&c,\;& \mathrm{Lim}\,&F),\\
right(c,F)&:\: \mathrm{Hom}_{\mathcal{C}}&&(&c,\;& \mathrm{Lim}\, &F) &\rightarrow \mathrm{Hom}_{\mathcal{C}^\mathcal{I}}&&(\Delta &c,\,& &F).
\end{split}
$$
Тут лучше виден паттерн в расположении $c$ и $F$ относительно функторов $\Delta:\: \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$ и $\mathrm{Lim}:\: \mathcal{C}^\mathcal{I} \rightarrow \mathcal{C}$ . В первом выражении давайте избавимся от $F$, подставив вместо него $\Delta c$, тогда слева от стрелки получится $\mathrm{Hom}_{\mathcal{C}^\mathcal{I}}(\Delta c,\, \Delta c)$. Можем передать сюда тождественный функтор $id_{\mathcal{C}^\mathcal{I}}$, при этом останется лишь то, что правее стрелки — $\mathrm{Hom}_{\mathcal{C}}(c,\; \mathrm{Lim}\,\Delta c)$. Перепишем это так:
$$
left(c, \Delta c)(id_{\mathcal{C}^\mathcal{I}}):\: c \rightarrow (\mathrm{Lim} \circ \Delta)c.
$$
Аналогично, если в правую ветку вместо $c$ подставить $\mathrm{Lim}\,F$, и передать туда $id_{\mathcal{C}}$, получим
$$
right(\mathrm{Lim}\,F, F)(id_{\mathcal{C}}):\: (\Delta \circ \mathrm{Lim})F \rightarrow F.
$$
Оба выражения оказались индексированы только одним параметром и, очевидно, что они представляют собой компоненты естественных преобразований:
$$
\begin{split}
\eta_{\mathrm{Lim},\Delta}&:\:& id_{\mathcal{C}} \rightsquigarrow \mathrm{Lim} \circ \Delta &=
\forall c: \mathcal{C}&& .\; left(c, &&\Delta c&&)(id_{\mathcal{C}^\mathcal{I}})\\

\varepsilon_{\mathrm{Lim},\,\Delta}&:\:& \Delta \circ \mathrm{Lim} \rightsquigarrow id_{\mathcal{C}^\mathcal{I}} &=
\forall F: \mathcal{C}^\mathcal{I}&& .\; right(\mathrm{Lim}\,F, && \,\,\,F &&)(id_{\mathcal{C}})
\end{split}
$$
Подобные преобразования могут существовать не только для $\mathrm{Lim}$ и $\Delta$ но и для других встречных функторов. Они определяют такое понятие, как **сопряжение функторов**:
$$
\begin{split}
F \dashv G&:&\\
\eta&:&\: id \rightsquigarrow G \circ F,\\
\varepsilon&:&\: F \circ G \rightsquigarrow id.\\
\end{split}
$$


### !!! Рисунок для сопряжения !!!

Преобразования $\eta$ и $\varepsilon$ называются «единицей» и «коединицей» сопряжения. Между ними существуют очевидные условия консистентности — приведённые ниже треугольники будут коммутировать:
### !!! Рисунок для треугольников !!!

Признаком наличия сопряжения между какими-то функторами как раз и является наличие естественного изоморфизма между hom-объектами в разных категориях.
![[Pasted image 20250905101810.png]]

Очень важный момент — *сопряжение функторов не является отношением порядка*. Оно не транзитивно, то есть, если $F \dashv G$ и $G \dashv H$, то вовсе не обязательно, что $F \dashv H$. Сопряжение, не является свойством одного функтора по отношению к другим. Зато его можно интерпретировать как «ослабленную эквивалентность категорий» для случаев, когда строгая эквивалентность не нужна. Действительно, категории $\mathcal{C}$ и $\mathcal{D}$ считались бы эквивалентными, если бы для встречных функторов $F$ и $G$ между ними существовали бы натуральные изоморфизмы: $F \circ G \cong id_{\mathcal{D}}$ и $G \circ F \cong id_{\mathcal{C}}$. А в случае сопряжений не нужны полные изоморфизмы, состоящие из четырёх естественных преобразований — достаточно лишь двух из них: $id_{\mathcal{D}} \rightsquigarrow G \circ F$ и $F \circ G \rightsquigarrow id_{\mathcal{C}}$.


## Монады и комонады
 
В примере с диагональным функтором и пределом приходилось работать не только с привычной категорией типов $\mathcal{C}$, но и с «неудобной» категорией функторов $\mathcal{C}^\mathcal{I}$. И также получается со многими сопряжениями — даже если какая-та категория нам и интересна, то с другой может и не повезти. Тогда какая может быть практическая польза от этих сопряжений?

Дело в том, что наибольший интерес представляют не сами функторы, участвующие в сопряжении $F \dashv G$, но их *композиций* $F \circ G$ и $G \circ F$. Во-первых, обе этих композиции являются *эндофункторами* в своих категориях. А во-вторых, естественные преобразования сопряжения автоматически формируют для этих эндофункторов *монаду* и *комонаду* соответственно!

Действительно, «запаковка» $G \circ F$ и «распаковка» $F \circ G$ совпадают с единицей $\eta$ и коединицей $\varepsilon$ сопряжения, а «разматрёшивание» $G \circ F$ и «заматрёшивание» $F \circ G$ выражаются так:
$$
\begin{eqnarray}
\mu&:\;&&& (G \circ F) \circ (G \circ F) &\rightsquigarrow&& G \circ F &= id_G \circ \varepsilon \circ id_G,\\
\delta&:\;&&& F \circ G &\rightsquigarrow&& (F \circ G) \circ (F \circ G) &= id_F \circ \eta \circ id_G.
\end{eqnarray}
$$

Таким образом, сопряжение функторов порождает монаду и комонаду. Но верно и обратное — любую (ко)монаду можно разложить на пару сопряжённых функторов. Только такое разложение будет неоднозначным, ведь заранее даже не известно, через какую дополнительную категорию будет факторизоваться эндофунктор.

Получается, что задачу вычисления монадных возможностей эндофунктора можно свести к поиску любого его разложения на сопряжённые функторы. Причём, эти функторы могут соединять с категорией, отличной от первоначальной. Приблизит ли нас это к решению задачи?

В продолжении обзора будет показано, что существуют конструктивные методы поиска сопряжений, так что, как минимум, в частных случаях это должно помогать находить монаду для эндофунктора. А пока разберём ещё несколько любопытных особенностей сопряжений.



## !!! Тройки сопряжений.

Проведя все те же рассуждения для копредела, получим, что $\Delta \dashv \mathrm{Lim}$.

[The power of adjunctions](https://bartoszmilewski.com/2019/09/20/the-power-of-adjunctions/)
[Adjoint triples](http://comonad.com/reader/2016/adjoint-triples/)


Композиция сопряжений: из пары сопряжений получаем новые
>So there are two ways to compose the adjunctions, giving two induced adjunctions: $FG ⊣ HG$,  $GF ⊣ GH$

>So each adjoint triple gives rise to two adjunctions between monads and comonads.

>$alg: GFA \rightarrow A$ $coalg: A \rightarrow GHA$ but these types are isomorphic according to the `GF ⊣ GH` adjunction. Thus, one might guess that `GF` monad algebras are also `GH` comonad coalgebras, and that in such a situation, we actually have some structure that can be characterized both ways. In fact this is true for any monad left adjoint to a comonad; but all adjoint triples give rise to these.



## !!! Произведение, сумма и экпоненциал из сопряжения

[Product from Adjunction](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=Product%20from%20Adjunction)

[Exponential from Adjunction](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=Exponential%20from%20Adjunction)


## !!! Забывающе-свободные сопряжения



# Дополнительная литература

- [Теория категорий на JavaScript. Часть 1. Категория множеств](https://habr.com/ru/companies/cit/articles/313254/) — безо всяких формул, но с помощью пёстрых диаграмм раскрываются на ~~пальцах~~ множествах различные универсальные свойства.
- [Understanding limits in Set](https://ncatlab.org/nlab/show/Understanding+limits+in+Set) — одна из самых «демократичных» среди прочих «математичных» статей на nLab.
- Серия публикаций Бартоша Милевски из его блога:
	- [Limits and Colimits](https://bartoszmilewski.com/2015/04/15/limits-and-colimits/)
	- [Understanding Products and Universal Constructions](https://bartoszmilewski.com/2014/05/05/understanding-products-and-universal-constructions/)
	- [Understanding Limits](https://bartoszmilewski.com/2014/05/08/understanding-limits-2/)
	- [Programming with Universal Constructions](https://bartoszmilewski.com/2019/07/03/programming-with-universal-constructions/)
- Серия публикаций Тай-Данаэ Брэдли с ресурса Института Math3ma:
	- [Limits and Colimits, Part 1 (Introduction)](https://www.math3ma.com/blog/limits-and-colimits-part-1)
	- [Limits and Colimits, Part 2 (Definitions)](https://www.math3ma.com/blog/limits-and-colimits-part-2)
	- [Limits and Colimits, Part 3 (Examples)](https://www.math3ma.com/blog/limits-and-colimits-part-3)
	- [A Diagram is a Functor](https://www.math3ma.com/blog/a-diagram-is-a-functor)

Блог Дана Дойля
http://comonad.com/reader/2016/adjoint-triples/

# Промежуточный итог


>Every time you hear the statement that there is some unique morphism, which factorizes some construction, you should think of it as a mapping of some set to a hom-set. That’s the meaning of “picking a unique morphism.”


>Factorization involves commuting diagrams — some morphism being equal to a composition of two morphisms (factors). A natural transformation maps morphisms to commuting diagrams.

> The concept of _adjoint functors_ [[Kan (1958)](https://ncatlab.org/nlab/show/adjoint+functor#Kan58)] is a key concept in [category theory](https://ncatlab.org/nlab/show/category+theory) — if not _the_ key concept — and it is in large part through the manifold identification of examples of adjoint functors appearing ubiquituously in the practice of [mathematics](https://ncatlab.org/nlab/show/mathematics) that category theoretic tools are brought to use in general mathematics.