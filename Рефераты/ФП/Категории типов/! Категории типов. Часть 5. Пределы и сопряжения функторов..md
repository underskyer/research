Итак, позади три вводные части  обзора, в которых мы познакомились с категориями, функторами между ними, а также естественными преобразованиями для функторов. В данной же части мы увидим, как все эти понятия помогут нам разобраться, какие вообще есть инструменты для конструирования новых типов. Мы получим представление, откуда берутся *монады* (наконец то!) и выясним, почему их так сложно композировать.
# Мотивация

В одной из предыдущих частей обзора [был продемонстрирован](https://habr.com/ru/articles/933016/#anyfunctor) функтор, связывающий две разные категории одного и того же объекта — категории типов $\star$. Только в начальной категории морфизмами выступали конструкторы типов `F[_]`, а в конечной — эндофункторы `Functor[F]`. Полученный функтор сохранял композицию конструкторов типов, позволяя из любых `Functor[F]` и `Functor[G]` создавать `Functor[G ∘ F]`. А это, в свою очередь, означает, что если имеются реализации эндофункторов для каких-либо *базовых* `F[_]`, у нас автоматически есть эндофункоры для абсолютно любых `F[_]`!

Открытым остаётся вопрос, какие конструкторы типов можно считать настолько «базовыми», что композируя их, можно получить вообще всё. Во многих публикациях данного цикла обзоров неоднократно упоминалось об алгебраической природе типов, о том, что в основе всего лежат элементарные математические операции — сумма, произведение и экпоненциал (а также понятия нуля и единицы). Однако, мне приходилось всячески избегать объяснения, *почему* происходит именно так. Дело в том, что ключ к понимаю этого лежит в теории категорий, так что только сейчас настало время разобраться с этим вопросом.

В первом обзоре цикла [упоминалось](https://habr.com/ru/articles/758542/#types), что любой тип можно определить через его *универсальное свойство*. Это понятие заимствовано из теории категории, с его помощью формулируются новые конструкции в категориях. Поэтому сперва давайте разберёмся, как это работает.

# Универсальные свойства

В качестве примера напомню универсальное свойство произведения объектов:
> произведением двух объектов $A$ и $B$ выбранной категории называется такой объект $A \times B$ с морфизмами $p_A: A \times B \rightarrow A$ и $p_B: A \times B \rightarrow B$, что для любых объекта $C$ и морфизмов $f: C \rightarrow A$ и $g: C \rightarrow B$ будет существовать единственный морфизм $u: C \rightarrow A \times B$, делающий такую диаграмму коммутирующей:


 ![[произведение типов.png|600]]

Определяемый объект $A \times B$, также как и все кандидаты $C$, имеют аналогичную пару морфизмов, идущих от них к $A$ и $B$. Но среди всех кандидатов выделяется лишь один универсальный объект $A \times B$ — его *универсальный морфизм* $u$ будет единственным *для любого* другого кандидата. Все остальные кандидаты будут либо сложнее (например, морфизм $A \times B \rightarrow A \times B \times X$ будет не единственным), либо диаграмма не будет коммутировать (по сути, любой кандидат, но выбранные для него морфизмы $f$ и $g$ не полиморфны по $A$, или $B$).

Определение любого универсального свойства в категории имеет такую структуру:
- обозначаются объекты, *через которые формулируется* универсальный (для произведения и суммы — это просто пара объектов $A, B$);
- выбирается семейство кандидатов с определёнными возможностями (в примере выше — пары морфизмов $f, g$ или $p_A, p_B$);
- для каждого кандидата определяется морфизм $u$, связывающий его с целевым универсальным объектом;
- такой морфизм обязан быть единственным и обеспечивающий коммутируемость полученной диаграммы.

Как перечисленные пункты описать в терминах категории типов? «Возможности» кандидата — это некие преобразования, связывающие его с объектами подкатегории, фиксирующими формулировку универсального свойства. А требование коммутируеммости диаграммы очень напоминает условие *естественности* этого преобразования!

Конечно же, тут подразумевается некая функториальность для конструктора типов `F[_, ...]`. Его параметры даже могут иметь разную вариантность, поэтому в общем случае придётся иметь дело с *мультипрофункторами*, но в этой статье мы будем иметь дело, в первую очередь, с ковариантными функторами и бифункторами.


# Конусы и ко-конусы

Давайте сперва посмотрим, как универсальные свойства выражаются с помощью естественных преобразований в некоторой категории $\mathcal{C}$. Объекты, через которые формулируется универсальный объект, образуют подкатегорию в $\mathcal{C}$. Для произведения объектов $a$ и $b$ такая подкатегория будет дискретной, содержащей только эти два объекта и их тождественные морфизмы. Но в случае других универсальных свойств устройство подкатегории может быть и сложнее.

Выбор конкретной подкатегории в $\mathcal{C}$ удобно выразить с помощью функтора, встраивающего в $\mathcal{C}$ некую модельную категорию $\mathcal{I}$. В случае универсального свойства произведения это и будет дискретная категория двух индексов, скажем, $1$ и $2$. Тогда функтор $F_{ab}: \mathcal{I} \rightarrow \mathcal{C}$ и будет отвечать за выбор конкретных $a$ и $b$ в $\mathcal{C}$.

Технически, сейчас можно было бы и обойтись без введения модельной категории и функтора из неё. Но кажется, что не значительно усложняя, мы только приобретём в наглядности рассуждений. Кроме того, такая точка зрения ещё пригодится нам в дальнейшем, поэтому полезно привыкнуть к ней заранее.

Ещё нам нужно выбрать объект-кандидат . Поручим это **константному функтору** $\Delta\,c: \mathcal{I} \rightarrow \mathcal{C}$. Естественное преобразование $\Delta\,c \rightsquigarrow F$ называется **конусом** функтора :
$$
{\rm Cone}_F(c): \Delta c \leadsto F
$$

![[конусы!.png|Вы же наверняка заметили, что Ёжик конструировал именно конус, а вовсе не пирамидку!|800]]


Естественность преобразования нужна для случаев, когда в модельной категории $\mathcal{I}$ есть другие морфизмы помимо тождественных (например, $1 \rightarrow 2$), и функтор $F$ переносит их в также нетождественные морфизмы ($a \rightarrow b$). Тогда конус *обязан* быть естественным по отношению к этому функтору (в связке с константным, который погоды не делает).

Образ функтора $F$ образует подкатегорию $F\, \mathcal{I} \subset \mathcal{C}$, являющуюся «основанием» этого конуса, а объект $c: \mathcal{C}$ будет его вершиной:
### !!! Рисунок конуса !!!


Для универсального свойства суммы объектов получим дуальную картину. Напомню,
> суммой двух объектов $A$ и $B$ выбранной категории называется такой объект $A + B$ с морфизмами $i_A: A \rightarrow A + B$ и $i_B: B \rightarrow A + B$, что для любых объекта $D$ и морфизмов $f: A \rightarrow D$ и $g: B \rightarrow D$ будет существовать единственный морфизм $u: A + B \rightarrow D$, делающий такую диаграмму коммутирующей:

![[сумма типов.png|600]]

В сравнении с произведением, объекты на диаграмме сохранили своё положение, но все морфизмы оказались обращены. Кандидаты в сумму объектов описываются дуальной конструкцией, называемой **ко-конусом**:
$$
{\rm Cocone}_F(c): F \rightsquigarrow \Delta c
$$
На диаграмме получаем как бы «перевёрнутый конус»:
### !!! Рисунок ко-конуса !!!

Обратите внимание, что и моделирующая категория $\mathcal{I}$ и функтор $F$ остались теми же, что и для произведения типов! Изменилось только направление естественного преобразования.

### !! намёк на фундаментальность суммы и произведения 

Кандидаты в любые универсальные объекты можно выразить либо через конусы, либо ко-конусы. Осталось только найти среди них *тот самый универсальный* (если он вообще есть).


# Пределы и копределы

В формулировке универсального свойства упоминаются морфизмы, связывающие кандидатов и универсальные объекты так, что при этом не ломаются (ко)конусы («…делают диаграмму коммутирующей…»). Эти морфизмы образуют отношение частичного порядка среди кандидатов. Тогда может получиться так, что среди всех кандидатов выделяется «особенный», связанный с другими единственным (для каждого) универсальным морфизмом. Если такой объект существует (а это возможно далеко не всегда!), его (ко)конус, и, следовательно, он сам будут считаться «универсальными». Универсальный (ко)конус зависит лишь от функтора $F:\: \mathcal{I} \rightarrow \mathcal{C}$, он носит название **(ко)предел функтора $F$** и обозначается как ${\rm Lim}\,F$ (${\rm Colim}\,F$).
### !!! РИСУНОК ДЛЯ ПРЕДЕЛА/КОПРЕДЕЛА

Предел и копредел можно также трактовать как функторы, действующие из категории функторов: ${\rm Lim,\, Colim}:\: \mathcal{C}^\mathcal{I} \rightarrow \mathcal{C}$. В некотором смысле они противоположны диагональному функтору $\Delta:\: \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$.
### !!! РИСУНОК ДЛЯ функторов ПРЕДЕЛ/КОПРЕДЕЛ/ДИАГОНАЛЬНЫЙ

Чуть позднее мы рассмотрим этот аспект подробнее, а сейчас вернёмся к формализации (ко)пределов.

Итак, «…*для каждого* кандидата существует единственный универсальный морфизм...» Очевидно, что речь идёт о *взаимно-однозначном соответствии* кандидатов и универсальных морфизмов между ними и (ко)пределом. Причём, кандидаты определяются не столько объектами в категории $\mathcal{C}$, сколько связанными с ними конусами. Ведь формально универсальное свойство объекта представляет именно конус, который, будучи естественным преобразованием $\Delta c \rightsquigarrow F$, может иметь несколько различных реализаций. Все конусы, индексированные объектами категории $\mathcal{C}$ представляют собой функтор вида
$$
\mathcal{F}_{cone}: \mathcal{C} \rightarrow {\rm Cone}_F(\_)
$$

С другой стороны у нас обычные (типа, универсальные!) морфизмы ${\rm Hom}_{\mathcal{C}}(c,\, {\rm Lim}\, F)$. Они также индексированы объектами из $\mathcal{C}$ так, получается аналогичный функтор:
$$
\mathcal{F}_{hom}: \mathcal{C} \rightarrow {\rm Hom}_{\mathcal{C}}(\_,\, {\rm Lim}\, F)
$$
Несложно заметить, что оба функтора будут *контравариантными*. Область определения у них одна и та же — категория $\mathcal{C}$. А с областью значений всё немного интереснее. Дело в том, что конусы являются морфизмами в категории функторов, и дабы избежать парадоксов, принято считать, что все категории, с которыми мы работаем, являются *локально-малыми* — все морфизмы между двумя объектами *обязаны образовывать множество*. То есть, получается, что области значений обоих контравариантных функторов являются подкатегориями для дискретной категории ${\rm Set}$, следовательно функторы будут одного и того же типа:
$$
\mathcal{F}_{cone},\, \mathcal{F}_{hom}:\: \mathcal{C} \rightarrow {\rm Set}
$$

Для нас программистов картина не сильно поменяется, если в этом выражении заменить категорию множеств на дискретную же категорию значений (например, типа `Any`). Получим что-то вроде 
$$
\mathcal{F}_{cone},\, \mathcal{F}_{hom}:\: \star \rightarrow Any
$$

В любом случае, получается, что универсальное свойство задаётся *естественным изоморфизмом* этих функторов, то есть парой встречных естественных преобразований между ними, чьи композиции дают тождественные функторы:
$$
{\rm Cone}_F \cong \;{\rm Hom}_{\mathcal{C}}(\_,\, {\rm Lim}\,F)
$$
И для копредела будет дуальное выражение:
$$
{\rm Cocone}_F \cong \;{\rm Hom}_{\mathcal{C}}({\rm Colim}\,F,\, \_)
$$

В этих естественных изоморфизмах слева расположена совокупность (ко)конусов, индексированная только функтором $F$, а справа — только его (ко)предел. Мы получаем уравнения для поиска (ко)предела функтора! Впрочем, решать их совсем не просто.

### !!! В спойлер! Предпучки
> Подобные контравариантные функторы (как правило, отображающие объекты категории во множество морфизмов), называются *предпучками*. Тогда естественные изоморфизмы выше — это *условия представимости* предпучка (ко)консуов *в виде морфизмов* в предел функтора. Такая «представимость» имеет большое значение и мы с ней ещё столкнёмся в данном обзоре.
> 
> Теория [пучков](https://ru.wikipedia.org/wiki/%D0%9F%D1%83%D1%87%D0%BE%D0%BA_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) сейчас активно развивается и «её инструментарий может оказаться очень полезным». Впрочем, этой фразой обычно и завершаются все упоминания предпучков))).
> 
> Кстати, для того, чтобы называться полноценными «пучками», предпучкам не достаёт дополнительных ограничений… без которых программистам и так не плохо))).




# (Ко)пределы в категории типов


Как вообще можно построить новые типы? Исходно у нас нет возможности сделать что-то интересное с одним единственным типом, кроме как вернуть его же. Но можно попробовать скомбинировать пару существующих типов в какой-то новый. Получится функциональное отображение, на вход которому подаётся *два* типа, а на выходе получаем один новый. Это просто «двухдырочные» конструкторы типов вида `(*, *) => *`. Их можно трактовать как функторы из произведения категорий типов в неё же: $\star \times \star \rightarrow \star$. Произведение двух категорий типов моделируется дискретной категорией $\mathcal{I} = 2$, состоящей из двух индексов $1$ и $2$, так что наши бифункторы можно записать как $F_{ab}: \star^2 \rightarrow \star$. Его конусами будут естественные преобразования c компонентами, индексированными объектами $\mathcal{I}$:
$$
\begin{split}
{\rm Cone}_{F_{ab}}(c)_1&: c \rightarrow a,\\
{\rm Cone}_{F_{ab}}(c)_2&: c \rightarrow b.
\end{split}
$$
Да, это просто пара проекторов типа-кандидата.

Вычислить универсальный конус честным способом не так уж и просто. Дело в том, что функторы из конечной категории $\mathcal{I}$ в категорию типов описываются зависимыми типами. Здесь мы не будем углубляться в эту тему и ограничимся простыми рассуждениями. Для дискретной $\mathcal{I}$ самый минимальный полиморфный универсальный объект обладает только теми возможностями, которые описываются компонентами конуса. Получается, что
$$
{\rm Lim}\, F_{ab} = \forall i:\mathcal{I}.\, F_{ab}(i).
$$
Это что-то вроде индексированного списка, у каждого элемента которого будет свой тип (~~зависимое произведение~~). В Scala самое близкое к такому типу — это кортеж, соответствующий произведению типов:
```scala
infix type ×[A, B] = (A, B)
```
Он действительно минимален — морфизмы из других кандидатов в него будет *единственным образом* «забывать» любую лишнюю информацию. А будучи полиморфными, проекторы предела будут гарантировано факторизовать проекторы всех других кандидатов (сохранять коммутативность диаграммы).

Вообще, (ко)предел определяется не для категории индексов $\mathcal{I}$, а именно для функтора $\mathcal{I} \rightarrow \mathcal{C}$. Функторы бывают разные, в том числе, и $\Delta_c$ схлопывающий все морфизмы (не только тождественные!) в один. Однако, часто предел ищется только для наиболее «свободного» функтора, моделирующего категорию $\mathcal{I}$ в $\mathcal{C}$ без потерь. В этом случае, *(ко)предел определяется только структурой $\mathcal{I}$*. Например, очевидно, что если в дискретной $\mathcal{I}$ будет $n$ объектов, то пределом функтора из неё в типы будет кортеж из $n$ элементов. 

Формально, можно вывести несколько разных вариантов предела функтора. Например, произведение типов можно описать с помощью кодирования Чёрча как `[A, B] =>> [C] => (A => B => C) => C`. Но все эти варианты будут изоморфны друг другу — предел функтора (если он существует) *единственен с точностью до изоморфизма*.



Для того же бифунктора $F_{ab}$ можно также определить и ко-конусы с такими компонентами:
$$
\begin{split}
{\rm Cocone}_{F_{ab}}(c)_1&: a \rightarrow c,\\
{\rm Cocone}_{F_{ab}}(c)_2&: b \rightarrow c.
\end{split}
$$
Очевидно, что это естественное преобразование задаёт для копредела «левый» и «правый» *конструкторы* суммы типов:
```scala
infix type +[A, B] = A Either B
```

В Scala наиболее близкой реализация копредела в случае бо́льших размеров категории $\mathcal{I}$ будет, пожалуй, перечисление:
```scala
enum Sum3[A, B, C]:
  case One(a: A)
  case Two(b: B)
  case Tri(c: C)
```

Что же до универсального свойства экспоненциала объектов, то в общем случае он *не является пределом* какого-то функтора. Однако, для эксопненциала типов `A => B` существует конструкция, которую можно интерпретировать как предел константного функтора $\Delta\, B$ из дискретной категории значений типа `A` в категорию типов. Компоненты конусов кандидатов будут иметь вид:
$$
\mathrm{Cone}_{\Delta B}(C)_A = A \rightarrow (C \rightarrow B)
$$
 Будучи функциями, эти компоненты эквивалентны `(A, C) => B`, так что когда кандидат является пределом $\mathrm{Lim}\, \Delta B = B^A$, получится известная функция «оценки» `eval: (A, A => B) => B`.

Итак, мы можем строить новые типы складывая и умножая существующие. А какие типы существуют *изначально* и как для них определяются универсальные свойства? Да совершенно аналогичным способом! Тогда как раньше мы строили новые типы из двух, моделируемых категорией $\mathcal{I}=2$, теперь нам не требуется ни одного типа, что соответствует абсолютно пустой категории $\mathcal{I}=0$. Единственно возможный функтор честно отображает пустую категорию в пустую диаграмму в $\star$, и от (ко)конусов остаются одни лишь вершины-кандидаты. Только для предела этого функтора все универсальные морфизмы будут вести *к нему*, в то время как для копредела они будут вести *от него* к кандидатам. Это в точности соответствует универсальным свойствам *терминального и начального объектов* в категории типов — единичного (`Unit`) и нулевого (`Nothing`) типов!

Помимо вышеперечисленных, часто говорят и о других (ко)пределах функторов, основанных на недискретных категориях, в частности,
- предел и копредел диаграммы $1 \rightrightarrows 2$ (помимо тождественных, есть два дополнительных морфизма между объектами) — [уравнитель](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) и [коуравнитель](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%83%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C);
- предел диаграммы $1 \rightarrow 2 \leftarrow 3$  — [декартов квадрат](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82) (расслоённое произведение, pullback);
- копредел диаграммы $1 \leftarrow 2 \rightarrow 3$  — [кодекартов квадрат](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82) (расслоённая сумма, амальгама, pushout).

Однако «честные» реализации соответствующих типов не возможны без привлечения специальных техник Scala, основанных на идее зависимых типов, поэтому мы не будем останавливаться на них в данном обзоре.

# Сопряжения функторов

Пределы и копределы формулируются для конкретных функторов, вроде рассмотренного выше $F_{a, b}:\: 2 \rightarrow \mathcal{C}$. Каждый такой функтор *выбирает в конечной категории, в каком именно месте* будет смоделирована исходная. Между тем, натуральные изоморфизмы, определяющие предел и копредел намекают, что существуют глобальные взаимоотношения, не завязанные на выбор конкретного функтора $F_{a, b}$. Эти взаимоотношения и станут ключом к пониманию основных операций над типами — суммой, произведением и экспоненциалом. В свою очередь, станет яснее проблема композиции монад.

Рассмотрим внимательнее представленный ранее натуральный изоморфизм, определяющий предел. Он индексирован объектом $c:\: \mathcal{C}$ и функтором $F:\: \mathcal{C}^\mathcal{I}$, и представлен парой естественных преобразований, действующих навстречу друг другу:
$$
\begin{split}
left(c,F)&:&\: (\Delta c \rightsquigarrow F) &\rightarrow (c \rightarrow \mathrm{Lim}\,F),\\
right(c,F)&:&\: (c \rightarrow \mathrm{Lim}\,F) &\rightarrow (\Delta c \rightsquigarrow F).
\end{split}
$$
В целях обобщения, нам нужно реорганизовать эти конструкции, избавившись от упоминания $c$ и $F$. Сперва для удобства перепишем их через hom-объекты:
$$
\begin{split}
left(c,F)&:\: \mathrm{Hom}_{\mathcal{C}^\mathcal{I}}&&(\Delta& c,\,& &F) &\rightarrow \mathrm{Hom}_{\mathcal{C}}&&(&c,\;& \mathrm{Lim}\,&F),\\
right(c,F)&:\: \mathrm{Hom}_{\mathcal{C}}&&(&c,\;& \mathrm{Lim}\, &F) &\rightarrow \mathrm{Hom}_{\mathcal{C}^\mathcal{I}}&&(\Delta &c,\,& &F).
\end{split}
$$
Тут уже заметен паттерн в расположении $c$ и $F$ относительно функторов $\Delta:\: \mathcal{C} \rightarrow \mathcal{C}^\mathcal{I}$ и $\mathrm{Lim}:\: \mathcal{C}^\mathcal{I} \rightarrow \mathcal{C}$ . В первом выражении давайте избавимся от $F$, подставив вместо него $\Delta c$. Тогда слева от стрелки получится $\mathrm{Hom}_{\mathcal{C}^\mathcal{I}}(\Delta c,\, \Delta c)$ и можем передать сюда тождественный функтор $id_{\mathcal{C}^\mathcal{I}}$:
$$
left(c, \Delta c)(id_{\mathcal{C}^\mathcal{I}}):\: c \rightarrow (\mathrm{Lim} \circ \Delta)c.
$$
Аналогично, если в правую ветку вместо $c$ подставить $\mathrm{Lim}\,F$, и передать туда $id_{\mathcal{C}}$, получим
$$
right(\mathrm{Lim}\,F, F)(id_{\mathcal{C}}):\: (\Delta \circ \mathrm{Lim})F \rightarrow F.
$$
Оба выражения оказались индексированы только одним параметром и, очевидно, что они представляют собой компоненты естественных преобразований (в «естественности» можете убедиться самостоятельно):
$$
\begin{split}
\eta_{\mathrm{Lim},\Delta}&:\:& id_{\mathcal{C}} \rightsquigarrow \mathrm{Lim} \circ \Delta &=
\forall c: \mathcal{C}.\; &left(&c, \Delta c)(id_{\mathcal{C}^\mathcal{I}})\\
\varepsilon_{\mathrm{Lim},\Delta}&:\:& \Delta \circ \mathrm{Lim} \rightsquigarrow id_{\mathcal{C}^\mathcal{I}} &=
\forall F: \mathcal{C}^\mathcal{I}.\; &right(&\mathrm{Lim}\,F, F)(id_{\mathcal{C}})
\end{split}
$$
Подобные преобразования можно построить не только для $\mathrm{Lim}$ и $\Delta$ но и для других встречных функторов. Они определяют такое понятие, как **сопряжение функторов**:
$$
\begin{split}
F \vdash G&:&\\
\eta&:&\: id \rightsquigarrow F \circ G,\\
\varepsilon&:&\: G \circ F \rightsquigarrow id.\\
\end{split}
$$


### !!! Рисунок для сопряжения !!!

Преобразования $\eta$ и $\varepsilon$ называются «единицей» и «коединицей» сопряжения. Между ними существуют очевидные условия консистентности — приведённые ниже треугольники будут коммутировать:
### !!! Рисунок для треугольников !!!

Признаком наличия сопряжения между какими-то функторами как раз и является наличие естественного изоморфизма между hom-объектами в разных категориях.
![[Pasted image 20250905101810.png]]

Проведя все те же рассуждения для копредела, получим, что $\Delta \vdash \mathrm{Colim}$.


> Сопряжение функторов является отношением _между двумя функторами_, а не свойством одного функтора по отношению к другим.
> То есть, это не отношение порядка! Легко запутаться!
> «Ослабленная эквивалентность» для случаев, когда строгая эквивалентность не нужна.

> every pair of adjoint functors defines a monad and a comonad. Conversely, every monad or comonad may be factorized into a pair of adjoint functors — this factorization is not unique, though.

>[We are now ready to explain](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=We%20are%20now%20ready%20to%20explain%20why%2C%20in%20Haskell%2C%20the%20right%20adjoint%20is%20automatically%20a%20representable%20functor.) why, in Haskell, the right adjoint is automatically a [representable functor](https://bartoszmilewski.com/2015/07/29/representable-functors/).


### !!! Тройки сопряжений.


### !!! Произведение, сумма и экпоненциал из сопряжения



### !!! [Algebras for Monads](https://bartoszmilewski.com/2017/03/14/algebras-for-monads/)



### !!! Монады и комонады из сопряжений




# Непрерывность и когерентность функторов

Пределы и копределы очень важны для большинства категорий, поэтому часто возникает вопрос о том, как с ними взаимодействуют функторы. Если функтор $F$ сохраняет пределы любых других функторов $G$, он называется *непрерывным*:

$$
{\rm Lim}\,(F \circ G) = F\, ({\rm Lim}\, G).
$$

Самый «базовый» предел для категории типов — это произведение типов. Практически все остальные пределы строятся на его основе, поэтому непрерывность функтора обычно проверяют выясняя, сохраняет ли он произведение. Но в более общем случае для гарантии непрерывности требуется проверка сохранения и других пределов.

Сохранение же копределов говорит о *когерентности* функтора. Для функторов в категории типов обычно проверяют, сохраняют ли они сумму типов, как базовый копредел. И, опять же, более полная проверка требует рассмотрения коуравнителей и других копределов.

Среди эндофункторов в категории типов непрерывно-когерентным будет только тождественный функтор.

> Наиболее важное свойство сопряжённых функторов — их непрерывность: каждый функтор, имеющий левый сопряжённый (то есть являющийся правым сопряжённым), коммутирует с [пределами](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\) "Предел (теория категорий)") в категорном смысле. Соответственно, функтор, имеющий правый сопряжённый, _конепрерывен_, то есть коммутирует с [копределами](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\)&action=edit&redlink=1 "Копредел (теория категорий) (страница отсутствует)").


# Дополнительная литература

- [Теория категорий на JavaScript. Часть 1. Категория множеств](https://habr.com/ru/companies/cit/articles/313254/) — безо всяких формул, но с помощью пёстрых диаграмм раскрываются на ~~пальцах~~ множествах различные универсальные свойства.
- [Understanding limits in Set](https://ncatlab.org/nlab/show/Understanding+limits+in+Set) — одна из самых «демократичных» среди прочих «математичных» статей на nLab.
- Серия публикаций Бартоша Милевски из его блога:
	- [Limits and Colimits](https://bartoszmilewski.com/2015/04/15/limits-and-colimits/)
	- [Understanding Products and Universal Constructions](https://bartoszmilewski.com/2014/05/05/understanding-products-and-universal-constructions/)
	- [Understanding Limits](https://bartoszmilewski.com/2014/05/08/understanding-limits-2/)
	- [Programming with Universal Constructions](https://bartoszmilewski.com/2019/07/03/programming-with-universal-constructions/)
- Серия публикаций Тай-Данаэ Брэдли с ресурса Института Math3ma:
	- [Limits and Colimits, Part 1 (Introduction)](https://www.math3ma.com/blog/limits-and-colimits-part-1)
	- [Limits and Colimits, Part 2 (Definitions)](https://www.math3ma.com/blog/limits-and-colimits-part-2)
	- [Limits and Colimits, Part 3 (Examples)](https://www.math3ma.com/blog/limits-and-colimits-part-3)
	- [A Diagram is a Functor](https://www.math3ma.com/blog/a-diagram-is-a-functor)


# Промежуточный итог


>Every time you hear the statement that there is some unique morphism, which factorizes some construction, you should think of it as a mapping of some set to a hom-set. That’s the meaning of “picking a unique morphism.”


>Factorization involves commuting diagrams — some morphism being equal to a composition of two morphisms (factors). A natural transformation maps morphisms to commuting diagrams.
