
В этот раз мы проанализируем различные способы факторизации монады на сопряжённые функторы, а именно, рассмотрим два противоположных варианта, раскрывающих наиболее важные аспекты факторизации. Это даст нам более глубокое понимание самого понятия монады и послужит мотивацией для построения операции факторизации произвольного функтора.

Изначально планировал начать с этой темы шестую часть обзора, посвящённую расширениям Кана, но формально она имеет большее отношение к теме предыдущей публикации, сопряжённым функторам. В итоге материала набралось достаточно на самостоятельную публикацию с промежуточным номером)).

![[Pasted image 20260201113101.png|Нумерация в стиле Френка Дребина.]]

# Забывающе-свободные сопряжения

Функциональные отношения могут быть инъективными — *разным* объектам из области определения инъективной функции ставятся в соответствие *разные* объекты в её образе. В этом случае информация не теряется, и по любому объекту из образа всегда можно восстановить исходный объект. Однако, очень часто функция оказывается не инъективной и её образ оказывается меньше области определения, когда некоторые разные исходные объекты приводят в один и тот же. Такая функция *забывает* часть исходной информации, она оказывается *необратимой*.

Функторы — это по сути те же функции, *преобразующие* морфизмы одной категории в морфизмы другой. И также как и функции, в общем случае, функторы имеют «забывающую природу».

Сопряжённые же функторы, действуют навстречу другу другу, и когда один из них теряет особенности исходной категории, другой, наоборот, старается восстановить как можно больше потерянной информации.

![[! Диаграммы для 6 части#Сопряжение LR]]
Рассмотрим сопряжение $L \dashv R$ функторов $R: \mathcal{C} \rightarrow \mathcal{D}$ и $L: \mathcal{D} \rightarrow \mathcal{C}$. Такие обозначения выбраны не случайно — функтор $L$ (*left*) сопряжён *слева* и на диаграмме действует «влево», тогда как $R$ (*right*) сопряжён справа и действует «вправо». Каждый из них пытается «восстановить» информацию, теряемую другим функтором, но делают они это по-разному.

Пусть функтор $R$ сопоставляет два объекта $a,\, b: \mathcal{C}$ с единственным $R\,a = R\,b:\; \mathcal{D}$. Очевидно, что функтор $L$ не сможет из этого объекта восстановить одновременно $a$ и $b$. Но вместо этого он может дать «более общий» объект $LR\,a=LR\,b:\;\mathcal{C}$, из которого исходные объекты можно восстановить посредством коединицы сопряжения $\varepsilon:\; L \circ R \rightsquigarrow Id$, компоненты которой индексированы $a$ и $b$.

![[! Диаграммы для 6 части#Восстановление забытого LR]]

Правый функтор $R$ **забывает** различие объектов $a, b: \mathcal{C}$, сводя их в один $Ra=Rb: \mathcal{D}$, тогда как левый функтор $F$ восстанавливает **свободный** (**F**ree) объект $LRa=LRb: \mathcal{C}$, максимально соответствующий обоим исходным объектам.

Часто выделяют особый класс *забывающих функторов*, объединённых одной идеей. Пусть левая категория $\mathcal{C}$ состоит из тех же объектов, что и $\mathcal{D}$, но морфизмов в ней меньше — hom-объекты в $\mathcal{C}$ ограничены дополнительными условиями. Типичный пример: справа у нас категория множеств $\mathrm{Set}$ со всеми возможными функциями, а слева — категория моноидов над множествами $\mathrm{Mon}(\mathrm{Set})$. Объекты $m$ в ней являются такой конструкцией $(a \in \mathrm{Set},\,mon:\; a \otimes a + 1 \rightarrow a,\, \text{законы моноида})$. Допустимы лишь те морфизмы, что переводят одни моноиды в другие, то есть коммутируют с операцией $mon$, сохраняя законы ассоциативности композиции и нейтрального элементы. Нас тут интересует функтор $U:\; \mathrm{Mon(Set)} \rightarrow \mathrm{Set}$, сопоставляющий каждому моноиду его множество.

![[! Диаграммы для 6 части#Забывание моноида]]
В категории $\mathrm{Set}$ между любыми объектами полно морфизмов, которых нет в $\mathrm{Mon(Set)}$. Функтор $U$ **забывает ограничения** $\mathrm{Mon(Set)}$ — «особенные» морфизмы сохраняющие моноиды буквально теряются в $\mathrm{Set}$ среди прочих морфизмов. Функторы, отображающие hom-множества *не сюръективно*, называют «забывающим».

> Буква $U$, повсеместно используемая для обозначения забывающих функторов — это сокращение от английского слова **Underlying** (лежащий в основе).  Забывающий функтор обычно «стирает» дополнительную структуру (например, операцию умножения в группе или топологию в пространстве), оставляя только **underlying set** — «лежащее в основе множество».

За восстановление потерянных данных отвечает функтор $F$, сопряжённый к $U$ слева: $F \vdash U$.
![[! Диаграммы для 6 части#Изоморфизм hom-объектов для сопряжения $F \vdash U$]]
Для любого множества $a$ функтор $F$ подбирает такой моноид $Fa$, чтобы каждому морфизму моноидов $Fa \rightarrow m$ взаимно однозначно соответствовал морфизм множеств $a \rightarrow Um$. Очевидно, что $UFa \neq a$, то есть функтор $F$ приводит к моноиду, у которого *основное множество* будет отличаться от исходного. Объект $Fa$ представляет собой *наиболее общий моноид* для множества $a$, такой, что для него существует столько же способов получить произвольный моноид $m$, сколько и обычных функций от $a$ к множеству $m$. Бинарная операция для $Fa$ должна быть максимально обобщённой, *свободной* от привязки к другим бинарным операциям и позволяющей получить любую из них. Такой объект называется *свободным моноидом* для множества $a$. Функторы, сопряженные к забывающим слева, называют **свободными функторами**.

![[Вспомнить всё.png|Примерно так свободный функтор пытается восстановить всё то, что растерял забывающий.|600]]

Понятия «забывающего» и «свободного» функторов не являются строго математическими. Это скорее роли функторов в конкретном сопряжении:
- правый сопряжённый — забывающий,
- левый сопряжённый — свободный.
В отсутствии же сопряжения невозможно однозначно фиксировать роль функтора, ведь могут найтись функторы, которые будут сопряжены к данному как слева, так и справа.

Такие роли функторов важны для лучшего понимания анатомии монады, которая может быть построена из целой совокупности различных сопряжений сопряжений. Анализу этих сопряжений и посвящена данная часть обора.


# Категория сопряжений монады

Монада эндофунктора $T:\mathcal{C}\to\mathcal{C}$ может быть построена как композиция $T = F \circ U$ сопряжённых функторов $F \dashv U$, ведущих через промежуточную категорию: $\mathcal{C} \overset{F}{\to} \mathcal{D} \overset{U}{\to} \mathcal{C}$. Категория $\mathcal{D}$ несёт в себе отпечаток исходной, но она также «обогащена ограничениями», отражающими действие монады $T$. Функтор $F$ «свободно» сопоставляет объекты из $\mathcal{C}$ в «наиболее общие» в $\mathcal{D}$, тогда как забывающий функтор $U$, как правило, отбрасывает всё лишнее, снова возвращая в $\mathcal{С}$. Но даже при фиксированной промежуточной категории могут существовать различные пары $F, U$ порождающее ту же самую монаду.

Ввиду свободно-забывчивой природой сопряжённых функторов, промежуточная категория содержит всю информацию не только об исходной, а также об «эффекте» монады $T$. Причём, эта информация содержится не столько в объектах категории, но, прежде всего, *в её морфизмах*. Свободный функтор $F$ даже может «слепить» все объекты исходной категории в *единственный* $d:\mathcal{D}$, если только забывающий $U$ обладает достаточной «различающей мощностью» на морфизмах, чтобы из $\mathrm{Hom}(d,d)$ восстановить всё богатство исходной категории (точнее образ функтора $T$).

Различные промежуточные категории $\mathcal{D}$ вместе с парами функторов $F$ и $U$ позволяют изучить монаду во всей её многогранности.

Из совокупности всех возможных сопряжений, порождающих монаду $T$ можно построить категорию $\mathcal{Adj}_T$. Её объектами будут тройки $(\mathcal{D},\, L:\mathcal{C} \to \mathcal{D},\, R: \mathcal{D} \to \mathcal{C})$, функторы которой образуют сопряжение, дающее $T = R \circ L$. Морфизмами между $(\mathcal{D}, L, R)$ и $(\mathcal{D}', L', R')$ будут такие функторы $K:\mathcal{D}\to\mathcal{D'}$, что $K \circ L = L'$ и $R' \circ K = R$.

Чем же может помочь столь сложно устроенная категория $\mathcal{Adj}_T$? Дело в том, что в её морфизмах зашифрованы взаимоотношения всех возможных *реализаций* монады $T$. И самым замечательным фактом является то, что в ней существуют два полярных сопряжения — начальный и терминальный объекты. Эти сопряжения характеризуют всю категорию и демонстрируют две противоположные стороны монады.

Начальный объект этой категории называется *сопряжением Клейсли*, а терминальный — *сопряжением Эйленберга-Мура*. Давайте рассмотрим их подробнее.

![[! Диаграммы для 6 части#Начальное и терминальное сопряжения]]



# Сопряжение Клейсли

Пусть $(\mathcal{Kl}_T,F_{kl},U_{kl})$ — начальный объект категории $\mathcal{Adj}_T$. Универсальное свойство начального объекта гласит, что для любого другого сопряжения $(\mathcal{D},F,U)$ существует *единственный* функтор $K:\mathcal{Kl}_T\rightarrow \mathcal{D}$ такой, что:
$$
K\circ F_{kl}=F,
\hspace{2cm}
U\circ K=U_{kl}.
$$

Функтор $K$, как и любое другое отображение, способен лишь терять информацию (в лучшем случае, сохранять). И так как он ведёт из начального объекта в любой другой, то категория $\mathcal{Kl}_T$ обязана быть *самой минимальной* среди всех прочих объектов $\mathcal{Adj}_T$ — в ней не может быть объектов, которых бы функтор $K$ не смог бы сопоставить с категорией $\mathcal{D}$. 

С другой стороны оказывается, что в $\mathcal{Adj}_T$ всегда найдётся такое сопряжение, где функтор $F$, нетривиально действуя на морфизмы, будет сопоставлять объекты $\mathcal{C}$ и $\mathcal{D}$, *биективно*, не «схлопывая» разные объекты в один, «различать» объекты исходной категории. На данный момент, это совсем не очевидный факт, но одним из его примеров будет *терминальный* объект в $\mathcal{Adj}_T$, который мы рассмотрим чуть далее.

Очевидно, что такие различающие сопряжения всегда окажутся полнее, «начальнее» любого забывающего. Значит, свободный функтор $F_{kl}$ начального сопряжения также обязан быть различающим, сопоставляющим каждому объекту из $C$ ровно один объект в $\mathcal{Kl}_T$.

Учитывая необходимость минимальности $\mathcal{Kl}_T$ и «различимость» $F_{kl}$ получаем, что объекты начальной промежуточной категории *взаимо-однозначно соответсmвутют* объектам исходной: $\mathrm{Obj}(\mathcal{Kl}_T) \cong \mathrm{Obj}(\mathcal{C})$!

Теперь разберёмся с морфизмами в $\mathcal{Kl}_T$. Ввиду биективности $F_{kl}$ на объектах, любые $X, Y: \mathcal{C}$ безо всяких обиняков будем считать одновременно объектами в $\mathcal{Kl}_T$, тогда $\mathrm{Hom}_{\mathcal{Kl}_T}(F_{kl}X, F_{kl}Y) \equiv \mathrm{Hom}_{\mathcal{Kl}_T}(X, Y)$. Кроме того, из сопряжения имеем $\mathrm{Hom}_{\mathcal{Kl}_T}(F_{kl}X, F_{kl}Y) \cong \mathrm{Hom}_{\mathcal{C}}(X, U_{kl}F_{kl}Y)$. Но ведь по определению $U_{kl} \circ F_{kl}=T$, что в итоге нам даёт
$$
\mathrm{Hom}_{\mathcal{Kl}_T}(X, Y) \cong \mathrm{Hom}_{\mathcal{C}}(X, TY).
$$
То есть, каждый морфизм категории $\mathcal{Kl}_T$ — это по сути морфизм $X \to TY$ в исходной категории $\mathcal{C}$! Законы категории опираются на возможности монады $(T, \mu, \eta)$:
- для морфизмов $f: \mathrm{Hom}_{\mathcal{Kl}_T}(X,Y)$ и $g: \mathrm{Hom}_{\mathcal{Kl}_T}(Y,Z)$ имеем композицию $\mu_Z \circ Tg \circ f: \mathrm{Hom}_{\mathcal{Kl}_T}(X,Z)$,
- а единица монады задаёт тождественный морфизм $\eta_X: \mathrm{Hom}_{\mathcal{Kl}_T}(X,X)$.

Полученная категория называется [категорией Клейсли](http://en.wikipedia.org/wiki/Kleisli_category).

Свободный функтор $F_{kl}$ преобразует морфизмы $f: \mathrm{Hom}_{\mathcal{C}}(X, Y)$ в $F_{kl}\,f=\eta_Y \circ f: \mathrm{Hom}_{\mathcal{Kl}_T}(X, Y)$. В свою очередь, забывающий функтор $U_{kl}$ действует на $f: \mathrm{Hom}_{\mathcal{Kl}_T}(X, Y)$ следующим образом: $U_{kl}\,f = \mu_Y \circ Tf$, а объекты он просто «запаковывает» в монаду: $X \overset{U_{kl}}{\to} TX$. Эти функторы образуют так называемое **сопряжение Клейсли**.

Категория Клейсли трактует монаду как *минимальный интерфейс* — это просто возможность выстраивать целые пути из шагов-морфизмов вида $A \to TB$. То есть, мы не знаем, как «распаковывается» функтор $T$, какой «эффект» несёт в себе, но зато мы точно умеем комбинировать «T-эффективные» морфизмы. Все другие сопряжения, дающее ту же самую монаду, будут устроены сложнее чем начальное сопряжение Клейсли.

В Scala в библиотеке Cats категория Клейсли представлена морфизмами примерно такого вида:
```scala
case class Kleisli[T[_], A, B](run: A => T[B]):  
  def andThen[C](f: Kleisli[T, B, C])(using T: Monad[T]): Kleisli[T, A, C] =  
    Kleisli(run `andThen` T.lift(f.run) `andThen` T.flatten[C])
```

### !!! про следствия для программирования




# Сопряжение Эйленберга-Мура


Пусть $(\mathcal{C}_{Term},F_{T},G_{T})$ — терминальный объект. По определению, для любого сопряжения $(\mathcal{D},F,G)$, порождающего $\mathbb{T}$, существует единственный функтор $K:\mathcal{D}\rightarrow \mathcal{C}_{Term}$ такой, что:
- $G_{T}\circ K=G$
- $K\circ F=F_{T}$

## Шаг 1: Определение носителя
Для любого объекта $d\in \mathcal{D}$ объект $K(d)$ должен быть определен так, чтобы удовлетворять $G_{T}(K(d))=G(d)$. Это означает, что объект в терминальной категории — это объект $G(d)$ из $\mathcal{C}$, наделенный некоторой дополнительной структурой, которую $G_{T}$ отбрасывает.
## Шаг 2: Вывод структуры объекта
В любом сопряжении $F \dashv G$ существует коединица $\varepsilon :FG\rightarrow \text{Id}_{\mathcal{D}}$. Применим к ней функтор $G$:
$$
G(\varepsilon _{d}):GFG(d)\rightarrow G(d)
$$
Так как $GF=T$, мы получаем морфизм $h_{d}:T(Gd)\rightarrow Gd$ в категории $\mathcal{C}$.Согласно треугольным тождествам сопряжения, пара $(G(d),h_{d})$ удовлетворяет двум уравнениям:
- $h_{d}\circ \eta _{Gd}=\text{Id}_{Gd}$
- $h_{d}\circ \mu _{Gd}=h_{d}\circ T(h_{d})$
Следовательно, отображение $K$ сопоставляет объекту $d$ структуру алгебры Эйленберга-Мура. Чтобы $K$ был единственным для любого $\mathcal{D}$, объекты $\mathcal{C}_{Term}$ должны быть всеми такими парами $(A,h)$, а морфизмы — морфизмами алгебр.
## Шаг 3: Определение функторов терминального объекта
- Из условия $G_{T}(K(d))=G(d)$ следует, что $G_{T}(A,h)=A$.
- Из условия $K(F(X))=F_{T}(X)$ и того, что $K(d)=(Gd,G\varepsilon _{d})$, следует:$F_{T}(X)=(GFX,G\varepsilon _{FX})=(TX,\mu _{X})$.
Это в точности конструкция категории алгебр $\mathcal{C}^{T}$. 

## Итог
Терминальный объект выводится через **анализ структуры носителя** произвольного сопряжения (приводит к алгебрам).


# Модифицирование монад



# Промежуточный итог