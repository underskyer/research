
В этот раз мы проанализируем различные способы факторизации монады на сопряжённые функторы, а именно, рассмотрим два противоположных варианта, раскрывающих наиболее важные аспекты факторизации. Это даст нам более глубокое понимание самого понятия монады и послужит мотивацией для построения операции факторизации произвольного функтора.

Изначально планировал начать с этой темы шестую часть обзора, посвящённую расширениям Кана, но формально она имеет большее отношение к теме предыдущей публикации, сопряжённым функторам. В итоге материала набралось достаточно на самостоятельную публикацию с промежуточным номером)).

![[Pasted image 20260201113101.png|Нумерация в стиле Френка Дребина.]]

![[Pasted image 20260210112558.png]]

# Забывающе-свободные сопряжения

Функциональные отношения могут быть инъективными — *разным* объектам из области определения инъективной функции ставятся в соответствие *разные* объекты в её образе. В этом случае информация не теряется, и по любому объекту из образа всегда можно восстановить исходный объект. Однако, очень часто функция оказывается не инъективной и её образ оказывается меньше области определения, когда некоторые разные исходные объекты приводят в один и тот же. Такая функция *забывает* часть исходной информации, она оказывается *необратимой*.

Функторы — это по сути те же функции, *преобразующие* морфизмы одной категории в морфизмы другой. И также как и функции, в общем случае, функторы имеют «забывающую природу».

Сопряжённые же функторы, действуют навстречу другу другу, и когда один из них теряет особенности исходной категории, другой, наоборот, старается восстановить как можно больше потерянной информации.

![[! Диаграммы для 6 части#Сопряжение LR]]
Рассмотрим сопряжение $L \dashv R$ функторов $R: \mathcal{C} \rightarrow \mathcal{D}$ и $L: \mathcal{D} \rightarrow \mathcal{C}$. Такие обозначения выбраны не случайно — функтор $L$ (*left*) сопряжён *слева* и на диаграмме действует «влево», тогда как $R$ (*right*) сопряжён справа и действует «вправо». Каждый из них пытается «восстановить» информацию, теряемую другим функтором, но делают они это по-разному.

Пусть функтор $R$ сопоставляет два объекта $a,\, b: \mathcal{C}$ с единственным $R\,a = R\,b:\; \mathcal{D}$. Очевидно, что функтор $L$ не сможет из этого объекта восстановить одновременно $a$ и $b$. Но вместо этого он может дать «более общий» объект $LR\,a=LR\,b:\;\mathcal{C}$, из которого исходные объекты можно восстановить посредством коединицы сопряжения $\varepsilon:\; L \circ R \rightsquigarrow Id$, компоненты которой индексированы $a$ и $b$.

![[! Диаграммы для 6 части#Восстановление забытого LR]]

Правый функтор $R$ **забывает** различие объектов $a, b: \mathcal{C}$, сводя их в один $Ra=Rb: \mathcal{D}$, тогда как левый функтор $F$ восстанавливает **свободный** (**F**ree) объект $LRa=LRb: \mathcal{C}$, максимально соответствующий обоим исходным объектам.

Часто выделяют особый класс *забывающих функторов*, объединённых одной идеей. Пусть левая категория $\mathcal{C}$ состоит из тех же объектов, что и $\mathcal{D}$, но морфизмов в ней меньше — hom-объекты в $\mathcal{C}$ ограничены дополнительными условиями. Типичный пример: справа у нас категория множеств $\mathrm{Set}$ со всеми возможными функциями, а слева — категория моноидов над множествами $\mathrm{Mon}(\mathrm{Set})$. Объекты $m$ в ней являются такой конструкцией $(a \in \mathrm{Set},\,mon:\; a \otimes a + 1 \rightarrow a,\, \text{законы моноида})$. Допустимы лишь те морфизмы, что переводят одни моноиды в другие, то есть коммутируют с операцией $mon$, сохраняя законы ассоциативности композиции и нейтрального элементы. Нас тут интересует функтор $U:\; \mathrm{Mon(Set)} \rightarrow \mathrm{Set}$, сопоставляющий каждому моноиду его множество.

![[! Диаграммы для 6 части#Забывание моноида]]
В категории $\mathrm{Set}$ между любыми объектами полно морфизмов, которых нет в $\mathrm{Mon(Set)}$. Функтор $U$ **забывает ограничения** $\mathrm{Mon(Set)}$ — «особенные» морфизмы сохраняющие моноиды буквально теряются в $\mathrm{Set}$ среди прочих морфизмов. Функторы, отображающие hom-множества *не сюръективно*, называют «забывающим».

> Буква $U$, повсеместно используемая для обозначения забывающих функторов — это сокращение от английского слова **Underlying** (лежащий в основе).  Забывающий функтор обычно «стирает» дополнительную структуру (например, операцию умножения в группе или топологию в пространстве), оставляя только **underlying set** — «лежащее в основе множество».

За восстановление потерянных данных отвечает функтор $F$, сопряжённый к $U$ слева: $F \vdash U$.
![[! Диаграммы для 6 части#Изоморфизм hom-объектов для сопряжения $F \vdash U$]]
Для любого множества $a$ функтор $F$ подбирает такой моноид $Fa$, чтобы каждому морфизму моноидов $Fa \rightarrow m$ взаимно однозначно соответствовал морфизм множеств $a \rightarrow Um$. Очевидно, что $UFa \neq a$, то есть функтор $F$ приводит к моноиду, у которого *основное множество* будет отличаться от исходного. Объект $Fa$ представляет собой *наиболее общий моноид* для множества $a$, такой, что для него существует столько же способов получить произвольный моноид $m$, сколько и обычных функций от $a$ к множеству $m$. Бинарная операция для $Fa$ должна быть максимально обобщённой, *свободной* от привязки к другим бинарным операциям и позволяющей получить любую из них. Такой объект называется *свободным моноидом* для множества $a$. Функторы, сопряженные к забывающим слева, называют **свободными функторами**.

Понятия «забывающего» и «свободного» функторов не являются строго математическими. Это скорее роли функторов в конкретном сопряжении:
- правый сопряжённый — забывающий,
- левый сопряжённый — свободный.
В отсутствии же сопряжения невозможно однозначно фиксировать роль функтора, ведь могут найтись функторы, которые будут сопряжены к данному как слева, так и справа.

Такие роли функторов важны для лучшего понимания анатомии монады, которая может быть построена из целой совокупности различных сопряжений сопряжений. Анализу этих сопряжений и посвящена данная часть обора.


# Категория сопряжений монады

Монада эндофунктора $T:\mathcal{C}\to\mathcal{C}$ может быть построена как композиция $T = F \circ U$ сопряжённых функторов $F \dashv U$, ведущих через промежуточную категорию: $\mathcal{C} \overset{F}{\to} \mathcal{D} \overset{U}{\to} \mathcal{C}$. Категория $\mathcal{D}$ несёт в себе отпечаток исходной, но она также «обогащена ограничениями», отражающими действие монады $T$. Функтор $F$ «свободно» сопоставляет объекты из $\mathcal{C}$ в «наиболее общие» в $\mathcal{D}$, тогда как забывающий функтор $U$, как правило, отбрасывает всё лишнее, снова возвращая в $\mathcal{С}$. Но даже при фиксированной промежуточной категории могут существовать различные пары $F, U$ порождающее ту же самую монаду.

Ввиду свободно-забывчивой природой сопряжённых функторов, промежуточная категория содержит всю информацию не только об исходной, а также об «эффекте» монады $T$. Причём, эта информация содержится не столько в объектах категории, но, прежде всего, *в её морфизмах*. Свободный функтор $F$ даже может «слепить» все объекты исходной категории в *единственный* $d:\mathcal{D}$, если только забывающий $U$ обладает достаточной «различающей мощностью» на морфизмах, чтобы из $\mathrm{Hom}(d,d)$ восстановить всё богатство исходной категории (точнее образ функтора $T$).

Различные промежуточные категории $\mathcal{D}$ вместе с парами функторов $F$ и $U$ позволяют изучить монаду во всей её многогранности.

Из совокупности всех возможных сопряжений, порождающих монаду $T$ можно построить категорию $\mathcal{Adj}_T$. Её объектами будут тройки $(\mathcal{D},\, L:\mathcal{C} \to \mathcal{D},\, R: \mathcal{D} \to \mathcal{C})$, функторы которой образуют сопряжение, дающее $T = R \circ L$. Морфизмами между $(\mathcal{D}, L, R)$ и $(\mathcal{D}', L', R')$ будут такие функторы $K:\mathcal{D}\to\mathcal{D'}$, что $K \circ L = L'$ и $R' \circ K = R$.

Чем же может помочь столь сложно устроенная категория $\mathcal{Adj}_T$? Дело в том, что в её морфизмах зашифрованы взаимоотношения всех возможных *реализаций* монады $T$. И самым замечательным фактом является то, что в ней существуют два полярных сопряжения — начальный и терминальный объекты. Эти сопряжения характеризуют всю категорию и демонстрируют две противоположные стороны монады.

Начальный объект этой категории называется *сопряжением Клейсли*, а терминальный — *сопряжением Эйленберга-Мура*. Давайте рассмотрим их подробнее.

![[! Диаграммы для 6 части#Начальное и терминальное сопряжения]]



# Сопряжение Клейсли

Пусть $(\mathcal{Kl}_T,F_{kl},U_{kl})$ — начальный объект категории $\mathcal{Adj}_T$. Универсальное свойство начального объекта гласит, что для любого другого сопряжения $(\mathcal{D},F,U)$ существует *единственный* функтор $K:\mathcal{Kl}_T\rightarrow \mathcal{D}$ такой, что:
$$
K\circ F_{kl}=F,
\hspace{2cm}
U\circ K=U_{kl}.
$$

Функтор $K$, как и любое другое отображение, способен лишь терять информацию (в лучшем случае, сохранять). И так как он ведёт из начального объекта в любой другой, то категория $\mathcal{Kl}_T$ обязана быть *самой минимальной* среди всех прочих объектов $\mathcal{Adj}_T$. 

С другой стороны оказывается, что в $\mathcal{Adj}_T$ всегда найдётся такое сопряжение, где функтор $F$ будет сопоставлять объекты $\mathcal{C}$ и $\mathcal{D}$ *инъективно*, не «схлопывая» разные объекты в один, «различать» объекты исходной категории. На данный момент, это совсем не очевидный факт, но одним из его примеров будет *терминальный* объект в $\mathcal{Adj}_T$, который мы рассмотрим чуть далее. Очевидно, что такие различающие сопряжения всегда окажутся полнее, «начальнее» любого забывающего. Значит, свободный функтор $F_{kl}$ начального сопряжения также обязан быть инъективным на объектах, сопоставляющим каждому объекту из $C$ ровно один объект в $\mathcal{Kl}_T$.

Учитывая необходимость минимальности $\mathcal{Kl}_T$ и «различимость» $F_{kl}$ получаем, что объекты начальной промежуточной категории *взаимо-однозначно соответсmвутют* объектам исходной: $\mathrm{Obj}(\mathcal{Kl}_T) \cong \mathrm{Obj}(\mathcal{C})$!

Теперь разберёмся с морфизмами в $\mathcal{Kl}_T$. Безо всяких обиняков будем считать объекты $X, Y: \mathcal{C}$ одновременно объектами в $\mathcal{Kl}_T$, значит  $\mathrm{Hom}_{\mathcal{Kl}_T}(F_{kl}X, F_{kl}Y) \equiv \mathrm{Hom}_{\mathcal{Kl}_T}(X, Y)$. Кроме того, из сопряжения имеем $\mathrm{Hom}_{\mathcal{Kl}_T}(F_{kl}X, F_{kl}Y) \cong \mathrm{Hom}_{\mathcal{C}}(X, U_{kl}F_{kl}Y)$. По условию задачи композиция этих функторов даёт монаду $U_{kl} \circ F_{kl}=T$, так что в итоге получаем
$$
\mathrm{Hom}_{\mathcal{Kl}_T}(X, Y) \cong \mathrm{Hom}_{\mathcal{C}}(X, TY).
$$
То есть, каждый морфизм категории $\mathcal{Kl}_T$ — это по сути морфизм $X \to TY$ в исходной категории $\mathcal{C}$! Законы категории опираются на возможности монады $(T, \mu, \eta)$:
- для морфизмов $f: \mathrm{Hom}_{\mathcal{Kl}_T}(X,Y)$ и $g: \mathrm{Hom}_{\mathcal{Kl}_T}(Y,Z)$ имеем композицию $U_{kl}\,g \circ f = \mu_Z \circ Tg \circ f: \mathrm{Hom}_{\mathcal{Kl}_T}(X,Z)$,
- а единица монады задаёт тождественный морфизм $\eta_X: \mathrm{Hom}_{\mathcal{Kl}_T}(X,X)$.

Полученная категория называется [категорией Клейсли](http://en.wikipedia.org/wiki/Kleisli_category).

Свободный функтор $F_{kl}$ преобразует морфизмы $f: \mathrm{Hom}_{\mathcal{C}}(X, Y)$ в $F_{kl}\,f=\eta_Y \circ f: \mathrm{Hom}_{\mathcal{Kl}_T}(X, Y)$. В свою очередь, забывающий функтор $U_{kl}$ действует на $f: \mathrm{Hom}_{\mathcal{Kl}_T}(X, Y)$ следующим образом: $U_{kl}\,f = \mu_Y \circ Tf$, а объекты он просто «запаковывает» в монаду: $X \overset{U_{kl}}{\to} TX$. Эти функторы образуют так называемое **сопряжение Клейсли**.

Категория Клейсли трактует монаду как *минимальный интерфейс* — это просто возможность выстраивать целые пути из шагов-морфизмов вида $A \to TB$. Мы не знаем, как «распаковывается» функтор $T$, какой «эффект» несёт в себе, но зато мы точно умеем комбинировать «T-эффективные» морфизмы. Все другие сопряжения, дающее ту же самую монаду, будут устроены сложнее чем начальное сопряжение Клейсли.

В Scala в библиотеке Cats морфизмы категории Клейсли (для монады `T` в категории типов) представлены классами примерно такого вида:
```scala
case class Kleisli[T[_]: Monad, A, B](run: A => T[B]):
  def compose[C](f: Kleisli[T, C, A]): Kleisli[T, C, B] =
    Kleisli(forget `compose` f.run) // μ ∘ T(run) ∘ f.run
  def andThen[C](f: Kleisli[T, B, C]): Kleisli[T, A, C] =
    f `compose` this
  def forget: T[A] => T[B] = // аналогичного метода нет в Cats
    flatten[T][B] `compose` fmap[T](run) // μ ∘ T(run) или (_: T[A]).flatMap(run)
  
object Kleisli:
  def fromFunction[T[_]: Monad as T] =
    [A, B] => (f: A => B) => T.pure[B] `compose` f // η ∘ f
```
По сути, это «T-эффективная» функция `run`, а также прямая и обратная композиции. Кроме того, здесь представлены методы `fromFunction` и `forget`, играющие роль свободного и забывающего функторов. Работает композиция Клейсли так:
```scala
val stringToInt = Kleisli((_: String).toIntOption)  
val signOfInt   = Kleisli((i: Int) => Option.when(i != 0)(i > 0))  
  
val signOfStringNumber = signOfInt `compose` stringToInt
signOfStringNumber.run("42") // Some(true)
```

Возможности, предоставляемые `Kleisli` из Cats, значительно шире показанных здесь, но всё же с ними не очень-то удобно работать на практике, из-за необходимости постоянного обёртывания функций с помощью конструктора класса. К счастью, в библиотеке определены комбинаторы `andThenF` и `composeF`, работающие и для обычных функций:
```scala
import cats.syntax.all.*

val stringToInt: String => Option[Int]     = _.toIntOption
val signOfInt:   Int    => Option[Boolean] = i => Option.when(i != 0)(i > 0)

val isPositiveNumber = signOfInt `composeF` stringToInt
isPositiveNumber("42") // Some(true)
```
Комбинаторы Клейсли дают наиболее выразительную, [бесточечную](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%81%D1%82%D0%BE%D1%87%D0%B5%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) технику функционального программирования для работы с эффектами. С ней вам не придётся не только явно вызывать намозоливший глаза `flatMap`, но и не нужно будет придумывать названия для промежуточных состояний-точек (и путаться в них) внутри каких-нибудь for-выражений.

Итак, сопряжение Клейсли раскрывает монаду $T$ как интерфейс для комбинирования $T$-эффективных вычислений. Давайте теперь посмотрим на противоположную сторону мон~~еты~~ады.




# Сопряжение Эйленберга-Мура

Ни на что не намекая)), обозначим терминальное сопряжение как $(\mathcal{D}_{Alg}, F_{Alg}, U_{Alg})$. Его универсальное свойство утверждает, что для любого сопряжения $(\mathcal{D}, F, U)$, порождающего $T$, существует *единственный* функтор $K:\mathcal{D}\rightarrow \mathcal{D}_{Alg}$ такой, что:
$$
U_{Alg}\circ K=U, \hspace{2cm}   K \circ F=F_{Alg}.
$$

Этот универсальный функтор, как и любой другой морфизм в категории сопряжений обязан сохранять сопряжения. Он действует между промежуточными категориями $\mathcal{D}$, среди морфизмов которых точно есть все компоненты коединицы сопряжения $\varepsilon: F \circ U \rightsquigarrow Id_{\mathcal{D}}$:
$$
\forall d:\mathcal{D},\; \varepsilon_d: \mathrm{Hom}_{\mathcal{D}}(FUd, d).
$$
Функтор $K$ обязан сохранять эти морфизмы именно как коединицы:
$$
K\varepsilon_{d} = \varepsilon _{Kd}^{Alg}.
$$
Чтобы соотнести данное правило с исходной категорией, подействуем на обе его стороны забывающим функтором $U_{Alg}: \mathcal{D_{Alg}} \to \mathcal{C}$. Получим
$$
U_{Alg} K \varepsilon_d = U \varepsilon_d = U_{Alg} \varepsilon^{Alg}_{Kd}.
$$
В каждом сопряжении забывающий функтор переводит коединицу в морфизмы исходной категории $Id_U \circ \varepsilon: U \circ F \circ U \rightsquigarrow U$. Так как $U \circ F = T$, получаем, что $U \varepsilon_d: T(Ud) \to Ud$ — это «распаковка» эндофунктора $T$ для объектов образа $U$, согласованная с законами монады.

Каждому объекту терминальной категории $a: \mathcal{D}_{Alg}$ взаимо-однозначно соответствует компонента коединицы $\varepsilon^{Alg}_a$, отвечающая за $T$-распаковку объектов исходной категории  $U_{Alg}a: \mathcal{C}$. С другой стороны, в $\mathcal{D}_{Alg}$ нас приводят универсальные функторы $K$ *всех* других сопряжений, у которых будут отличаться коединицы. Значит, объекты $a: \mathcal{D}_{Alg}$ будут *отличаться* для $\varepsilon_d$ разных сопряжений, даже если $d:\mathcal{D}$ для них будет общий. Другими словами, объекты $a: \mathcal{D}_{Alg}$ обязаны «помнить» каждый способ распаковки $U \varepsilon_d: T(Ud) \to Ud$ от каждого сопряжения $(\mathcal{D}, F, U)$.

Впитывая в себя все прочие сопряжения, терминальная категория не может потерять информацию об исходной и образ забывающего функтора $U_{Alg}$ должен покрывать всю исходную категорию $\mathcal{C}$ (совпадать с ней). Собирая всё воедино, получаем, что объекты терминальной категории должны быть *зависимой парой* $(c: \mathcal{C},\, h: Tc \to c): \mathcal{D}_{Alg}$.



### 3. Действие забывающего функтора $G_{T}$
Применим $G_{T}$ к обеим частям равенства $K(\varepsilon _{d})=\varepsilon _{K(d)}^{T}$:
$$
G_{T}(K\varepsilon _{d})=G_{T}(\varepsilon _{Kd}^{T})
$$

- Левая часть:Используем условие морфизма сопряжений $G_{T}\circ K=G$. Тогда:$G_{T}(K\varepsilon _{d})=G(\varepsilon _{d})$Здесь $G(\varepsilon _{d})$ — это морфизм в базовой категории $\mathcal{C}$ вида $G(FGd)\rightarrow Gd$.Так как $GF=T$, то это морфизм:$G(\varepsilon _{d}):T(Gd)\rightarrow Gd$
- Правая часть:Обозначим объект $K(d)$ как $\mathbb{A}$ и его «носитель» $G_{T}(\mathbb{A})$ как $A$. Тогда:$G_{T}(\varepsilon _{\mathbb{A}}^{T}):G_{T}(F_{T}A)\rightarrow A$Так как $G_{T}F_{T}=T$, то это морфизм: $G_{T}(\varepsilon _{\mathbb{A}}^{T}):T(A)\rightarrow A$
### 4. Конструктивный вывод структуры
Сравним результаты: Для любого объекта $d\in \mathcal{D}$ в базовой категории всегда существует морфизм $h_{d}=G(\varepsilon _{d})$ из $T(Gd)$ в $Gd$.В терминальной категории образ этого объекта $\mathbb{A}=K(d)$ всегда обладает морфизмом $h_{\mathbb{A}}^{T}=G_{T}(\varepsilon _{\mathbb{A}}^{T})$ из $T(A)$ в $A$.
Вывод: Чтобы функтор $K$ мог существовать и быть единственным для любого сопряжения $\mathcal{D}$, объект $\mathbb{A}$ в терминальной категории обязан «знать» о морфизме $G_{T}(\varepsilon _{\mathbb{A}}^{T})$, так как он является прямой проекцией коединицы в базовую категорию. Если бы объект $\mathbb{A}$ состоял только из носителя $A$, мы бы не смогли восстановить морфизм $G(\varepsilon _{d})$, который в разных сопряжениях $\mathcal{D}$ может быть разным. Следовательно, чтобы $G_{T}(K\varepsilon _{d})$ имело смысл, объект в $\mathcal{C}_{Term}$ должен быть парой $(A,h)$, где $h=G_{T}(\varepsilon _{\mathbb{A}}^{T})$.
### 5. Аксиомы структуры $h$
Откуда берутся свойства $h$? Из треугольных тождеств сопряжения в $\mathcal{D}$: $\varepsilon _{Fd}\circ F\eta _{d}=\text{Id}_{Fd}$$G\varepsilon _{d}\circ \eta _{Gd}=\text{Id}_{Gd}$Применим $K$, а затем $G_{T}$ ко второму тождеству:$G_{T}(K(G\varepsilon _{d}\circ \eta _{Gd}))=\text{Id}_{Gd}\implies h_{d}\circ \eta _{Gd}=\text{Id}_{Gd}$Это в точности закон единицы для алгебры. Итог: Забывающий функтор $G_{T}$ переводит коединицу терминального сопряжения в структуру «схлопывания» алгебры. Это и делает терминальную категорию категорией алгебр.

## Шаг 3: Определение функторов терминального объекта
- Из условия $G_{T}(K(d))=G(d)$ следует, что $G_{T}(A,h)=A$.
- Из условия $K(F(X))=F_{T}(X)$ и того, что $K(d)=(Gd,G\varepsilon _{d})$, следует:$F_{T}(X)=(GFX,G\varepsilon _{FX})=(TX,\mu _{X})$.
Это в точности конструкция категории алгебр $\mathcal{C}^{T}$. 

## Итог
Терминальный объект выводится через **анализ структуры носителя** произвольного сопряжения (приводит к алгебрам).

### 3. Почему это не происходит в Клейсли?

В начальном сопряжении (Клейсли) ситуация обратная. Там мы фиксируем морфизмы, чтобы они могли отобразиться куда угодно. Там «свобода» (начальность) заставляет нас расширять пространство стрелок.
В терминальном сопряжении «универсальность» заставляет нас сужать пространство объектов, помечая каждый объект тем морфизмом h, который он «обязуется» использовать в качестве своей коединицы.

# Модифицирование монад



# Промежуточный итог