
# Забывающе-свободные сопряжения

Функциональные отношения могут быть инъективными — *разным* объектам из области определения инъективной функции ставятся в соответствие *разные* объекты в её образе. В этом случае информация не теряется, и по любому объекту из образа всегда можно восстановить исходный объект. Однако, очень часто функция оказывается не инъективной и её образ оказывается меньше области определения, когда некоторые разные исходные объекты приводят в один и тот же. Такая функция *забывает* часть исходной информации, она оказывается *необратимой*.

Функторы — это по сути те же функции, преобразующие морфизмы одной категории в морфизмы другой. И также как и функции, функторы имеют «забывающую природу». Сопряжённые же функторы, действуют навстречу другу другу, и когда один из них теряет особенности исходной категории, другой, наоборот, старается восстановить как можно больше потерянной информации.

![[! Диаграммы для 6 части#Сопряжение LR]]
Рассмотрим сопряжение $L \dashv R$ функторов $R: \mathcal{C} \rightarrow \mathcal{D}$ и $L: \mathcal{D} \rightarrow \mathcal{C}$. Такие обозначения выбраны не случайно — функтор $L$ (*left*) сопряжён *слева* и на диаграмме действует «влево», тогда как $R$ (*right*) сопряжён справа и действует «вправо». Каждый из них пытается «восстановить» информацию, теряемую другим функтором, но делают они это по-разному.

Пусть функтор $R$ для объектов $c,\, c': \mathcal{C}$ (для их тождественных морфизмов) даёт один и тот же $Rc=Rc'=d:\; \mathcal{D}$. Очевидно, что функтор $L$ не сможет из этого объекта восстановить одновременно $c$ и $c'$. Но вместо этого он может вернуть «более общий» объект $L\,d:\;\mathcal{C}$, из которого исходные объекты можно восстановить посредством коединицы сопряжения $\varepsilon:\; L \circ R \rightsquigarrow Id$, компоненты которой индексированы $c$ и $c'$.

![[! Диаграммы для 6 части#Восстановление забытого LR]]


Правый функтор $R$ также делает всё возможное, чтобы восполнить потери $L$, но несколько иначе. Объект $RLd=RLd': \mathcal{D}$ будет «наиболее общим» в том смысле, что мы всегда сможем *получить его* из исходных объектов $d,\, d':\: \mathcal{D}$. Тут нам помогает единица сопряжения $\eta:\; Id \rightsquigarrow R \circ L$.

![[! Диаграммы для 6 части#Восстановление забытого RL]]

Ещё раз:
> сопряжённый функтор приводит к «наиболее общим» объектам, близким по свойствам к исходным, тогда как за собственно «восстановление» отвечают естественные преобразования сопряжения.

![[Pasted image 20251204204643.png|Примерно так сопряжение помогает востановить всё то, что функторы растеряли по дороге.|600]]

Часто выделяют особый класс *забывающих функторов*, объединённых одной идеей. Пусть левая категория $\mathcal{C}$ состоит из тех же объектов, что и $\mathcal{D}$, но морфизмов в ней меньше — hom-объекты в $\mathcal{C}$ ограничены дополнительными условиями. Типичный пример: справа у нас категория множеств $\mathrm{Set}$ со всеми возможными функциями, а слева — категория моноидов над множествами $\mathrm{Mon}(\mathrm{Set})$. Объекты $m$ в ней являются такой конструкцией $(a \in \mathrm{Set},\,mon:\; a \otimes a + 1 \rightarrow a,\, \text{законы моноида})$. Допустимы лишь те морфизмы, что переводят одни моноиды в другие, то есть коммутируют с $mon$, сохраняя законы ассоциативности композиции и нейтрального элементы. Нас тут интересует функтор $U:\; \mathrm{Mon(Set)} \rightarrow \mathrm{Set}$, сопоставляющий каждому моноиду его множество.

![[! Диаграммы для 6 части#Забывание моноида]]
В категории $\mathrm{Set}$ между любыми объектами полно морфизмов, которых нет в $\mathrm{Mon(Set)}$. Функтор $U$ **забывает ограничения** $\mathrm{Mon(Set)}$ — «особенные» морфизмы сохраняющие моноиды буквально теряются в $\mathrm{Set}$ среди прочих морфизмов. Функторы, отображающие hom-множества *не сюръективно*, называют «забывающим».

За восстановление потерянных данных отвечает функтор $F$, сопряжённый к $U$ слева: $F \vdash U$.
![[! Диаграммы для 6 части#Изоморфизм hom-объектов для сопряжения $F \vdash U$]]
Для любого множества $a$ функтор $F$ подбирает такой моноид $Fa$, чтобы каждому морфизму моноидов $Fa \rightarrow m$ взаимно однозначно соответствовал морфизм множеств $a \rightarrow Um$. Очевидно, что $UFa \neq a$, то есть функтор $F$ приводит к моноиду, у которого *основное множество* будет отличаться от исходного. Объект $Fa$ представляет собой *наиболее общий моноид* для множества $a$, такой, что для него существует столько же способов получить произвольный моноид $m$, сколько и обычных функций от $a$ к множеству $m$. Бинарная операция для $Fa$ должна быть максимально обобщённой, *свободной* от привязки к другим бинарным операциям и позволяющей получить любую из них. Такой объект называется *свободным моноидом* для множества $a$. Функторы, сопряженные к забывающим слева, называют **свободными функторами**.

Наверняка вы уже знаете, что свободным моноидом над множеством является *список* его элементов. Проверить это не сложно, но гораздо важнее научится *конструктивно выводить* подобные знания из условий задачи. Это мы сделаем позже, когда у нас будет алгоритм вычисления сопряжений.

Сама идея свободных функторов нам ещё пригодится в дальнейшем. Сейчас же давайте сконцентрируемся на «обратности» сопряженных функторов по отношению к исходному.


# Расширения Кана

Пусть у нас есть функтор $F$, и нам нужно найти для него такой $G_F$, для которого имелись бы естественные преобразования
$$
\begin{eqnarray}
G_F \circ F \rightsquigarrow Id\\
Id \rightsquigarrow F \circ G_F\\
\end{eqnarray}
$$

Функтор $G_F$ выглядит обратным к $F$ в том смысле, что их композиция позволяет получить тождественный функтор $Id$, и наоборот. Поэтому для $G_F$ можно встретить другое обозначение: $Id/F$, что делает сопряжение более наглядным:
$$
\begin{eqnarray}
&Id/F \circ F \rightsquigarrow Id\\
&Id \rightsquigarrow F \circ Id/F\\
\\
&F \dashv Id/F
\end{eqnarray}
$$



![[! Диаграммы для 6 части#Расширение Кана]]



- Пределы и колимиты можно выразить как определенные Кана расширения.  Это позволяет использовать инструменты для работы с Кана расширениями для изучения пределов и колимитов. 
- Точечные Кана расширения (Pointwise Kan extensions):  В некоторых случаях, Кана расширения можно вычислять "поточечно", что значительно упрощает их анализ. Теория предпучков играет важную роль в определении условий, при которых Кана расширения являются точечными.



## !!! композиция расширений Кана

https://stringdiagram.com/2022/12/06/codensity-monads-and-kan-extensions/

$$
\mathsf{Lan}_J(-) \dashv (-) \circ J \qquad\text{ и }\qquad (-) \circ J \dashv \mathsf{Ran}_J(-)
$$

$$
\mathsf{Lift}_J(-) \dashv J \circ (-) \qquad\text{and}\qquad J \circ (-) \dashv \mathsf{Rift}_J(-)
$$



# !!! Категория запятой


https://en.wikipedia.org/wiki/Comma_category
$$
\begin{eqnarray}
F&:& \mathcal{C} \rightarrow \mathcal{D}\\
G&:& \mathcal{E} \rightarrow \mathcal{D}\\
F \downarrow G&:& \{ f: Fc \rightarrow Ge \}\\
F/d = F \downarrow d &:& \{ f: Fc \rightarrow d \} \;\;\;\;\; \text{здесь $d$ - это функтор из $1$ в $D$, выбирающий $d$}
\end{eqnarray}
$$


$$
\begin{eqnarray}
\mathrm{Cone}_F:\; \mathcal{C}^{op} \rightarrow \mathrm{Hom}_{\mathcal{C}^{\mathcal{I}}}(\Delta\, \_,\, F)\\
\mathrm{Hom}_{\mathcal{C}^{\mathcal{I}}}(\Delta\, \_,\, F) =
\Delta \mathcal{C} / F =
\Delta \downarrow F\\
U_{\mathrm{Lim}F}:\; \mathcal{C}^{op} \rightarrow {\rm Hom}_{\mathcal{C}}(\_,\, {\rm Lim}\, F)\\
{\rm Hom}_{\mathcal{C}}(\_,\, {\rm Lim}\, F) =
\mathcal{C} / {{\rm Lim}\, F} =
Id \downarrow ({\rm Lim}\, F)\\
\end{eqnarray}
$$
F ↓ Id ≅ Id ↓ G является абсолютно корректным следствием существования сопряженных функторов F ⊣ G
$$
F \dashv G
\hspace{1cm} \Longrightarrow \hspace{1cm}
F \downarrow Id \cong Id \downarrow G
$$


# !! Концы

![[Слово Конец.png|1000]]


## !! Диестественные преобразования



# !!! Йонеда

 Теорема Йонеды устанавливает связь между объектами категории и предпучками на этой категории.  Для любой локально малой категории C и любого объекта X в C, функтор Йонеды Hom(-, X) : C^op -> Set отображает X в предпучок, который кодирует все морфизмы в X.  Теорема Йонеды говорит, что для любого предпучка P : C^op -> Set, множество естественных преобразований Nat(Hom(-, X), P) (между предпучком Йонеды, связанным с X, и предпучком P) естественно изоморфно множеству P(X).  То есть:

    Nat(Hom(-, X), P) ≅ P(X)



### !!! выяснить!!
> Наиболее важное свойство сопряжённых функторов — их непрерывность: каждый функтор, имеющий левый сопряжённый (то есть являющийся правым сопряжённым), коммутирует с [пределами](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\) "Предел (теория категорий)") в категорном смысле. Соответственно, функтор, имеющий правый сопряжённый, _конепрерывен_, то есть коммутирует с [копределами](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\)&action=edit&redlink=1 "Копредел (теория категорий) (страница отсутствует)").


http://comonad.com/reader/2011/monads-from-comonads/



# !!! (Ко)свободные конструкции

[The Continuation Monad](https://stringdiagram.com/2022/11/21/the-continuation-monad/)

>[We are now ready to explain](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=We%20are%20now%20ready%20to%20explain%20why%2C%20in%20Haskell%2C%20the%20right%20adjoint%20is%20automatically%20a%20representable%20functor.) why, in Haskell, the right adjoint is automatically a [representable functor](https://bartoszmilewski.com/2015/07/29/representable-functors/).


# !! Монадные трансформеры

[Where do monads come from?](https://stringdiagram.com/2022/05/17/where-do-monads-come-from/)
[The Codensity Monad Transformer](https://stringdiagram.com/2023/05/14/the-codensity-monad-transformer/)
[Right Kan Extension as (almost) a Monad Transformer](http://comonad.com/reader/2008/kan-extensions-ii/#:~:text=Right%20Kan%20Extension%20as%20(almost)%20a%20Monad%20Transformer)



# Дополнительная литература


- [String Diagrams](https://stringdiagram.com/) (Dan Marsden)
	- [Codensity Monads and Kan Extensions](https://stringdiagram.com/2022/12/06/codensity-monads-and-kan-extensions/)
	- [Where do monads come from?](https://stringdiagram.com/2022/05/17/where-do-monads-come-from/)
	- [The Codensity Monad Transformer](https://stringdiagram.com/2023/05/14/the-codensity-monad-transformer/)
	- [The Continuation Monad](https://stringdiagram.com/2022/11/21/the-continuation-monad/)
- [Bartosz Milewski's Programming Cafe](https://bartoszmilewski.com/ "Bartosz Milewski's Programming Cafe")
	- [Kan extensions](https://bartoszmilewski.com/2017/04/17/kan-extensions/)
	- [Pointwise Kan extensions](https://bartoszmilewski.com/2018/01/23/pointwise-kan-extensions/)
	- [Monads categorically](https://bartoszmilewski.com/2016/12/27/monads-categorically/)
	- [Algebras for monads](https://bartoszmilewski.com/2017/03/14/algebras-for-monads/)
- [Comonads](http://comonad.com/reader/) (Ed Kmett)
	- [Kan Extensions](http://comonad.com/reader/2008/kan-extensions/ "Permanent Link: Kan Extensions")
	- [Kan Extensions II: Adjunctions, Composition, Lifting](http://comonad.com/reader/2008/kan-extensions-ii/ "Permanent Link: Kan Extensions II: Adjunctions, Composition, Lifting")
- [Higher Order](https://blog.higher-order.com/) (Rúnar Óli Bjarnason)
	- [Freedom and Forgetfulness](https://blog.higher-order.com/blog/2015/10/12/freedom-and-forgetfulness/)
	- [Free Monoids and Free Monads](https://blog.higher-order.com/blog/2013/08/20/free-monads-and-free-monoids/)




# Промежуточный итог

This monad provides a useful opportunity for optimization. For instance Janis Voigtländer noted in [Asymptotic improvement of functions over Free Monads](http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf) that a particular monad could be used to improve performance -- Free monads as you'll recall are the tool used in Wouter Sweirstra's [Data Types á la Carte](http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf), and provide an approach for, among other things, decomposing the `IO` monad into something more modular, so this is by no means a purely academic exercise!