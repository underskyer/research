
![[Саундерс Маклейн.jpg]]

# Забывающе-свободные сопряжения

Функциональные отношения могут быть инъективными — *разным* объектам из области определения инъективной функции ставятся в соответствие *разные* объекты в её образе. В этом случае информация не теряется, и по любому объекту из образа всегда можно восстановить исходный объект. Однако, очень часто функция оказывается не инъективной и её образ оказывается меньше области определения, когда некоторые разные исходные объекты приводят в один и тот же. Такая функция *забывает* часть исходной информации, она оказывается *необратимой*.

Функторы — это по сути те же функции, преобразующие морфизмы одной категории в морфизмы другой. И также как и функции, функторы имеют «забывающую природу». Сопряжённые же функторы, действуют навстречу другу другу, и когда один из них теряет особенности исходной категории, другой, наоборот, старается восстановить как можно больше потерянной информации.

![[! Диаграммы для 6 части#Сопряжение LR]]
Рассмотрим сопряжение $L \dashv R$ функторов $R: \mathcal{C} \rightarrow \mathcal{D}$ и $L: \mathcal{D} \rightarrow \mathcal{C}$. Такие обозначения выбраны не случайно — функтор $L$ (*left*) сопряжён *слева* и на диаграмме действует «влево», тогда как $R$ (*right*) сопряжён справа и действует «вправо». Каждый из них пытается «восстановить» информацию, теряемую другим функтором, но делают они это по-разному.

Пусть функтор $R$ для объектов $c,\, c': \mathcal{C}$ (для их тождественных морфизмов) даёт один и тот же $Rc=Rc'=d:\; \mathcal{D}$. Очевидно, что функтор $L$ не сможет из этого объекта восстановить одновременно $c$ и $c'$. Но вместо этого он может вернуть «более общий» объект $L\,d:\;\mathcal{C}$, из которого исходные объекты можно восстановить посредством коединицы сопряжения $\varepsilon:\; L \circ R \rightsquigarrow Id$, компоненты которой индексированы $c$ и $c'$.

![[! Диаграммы для 6 части#Восстановление забытого LR]]


С другой стороны, единица сопряжения $\eta:\; Id \rightsquigarrow R \circ L$ «стягивает» два объекта $a,\,b: \mathcal{D}$ в один $RLd=RLd': \mathcal{D}$. Из образа функтора $R$ не получится перейти к исходным объектам. И всё же, объекты образа будут «наиболее общими» в таком же смысле, что и, например, произведение типов среди всех кандидатов. 

![[! Диаграммы для 6 части#Восстановление забытого RL]]

### !!! про своеобразность обратности правого сопряжения


Часто выделяют особый класс *забывающих функторов*, объединённых одной идеей. Пусть левая категория $\mathcal{C}$ состоит из тех же объектов, что и $\mathcal{D}$, но морфизмов в ней меньше — hom-объекты в $\mathcal{C}$ ограничены дополнительными условиями. Типичный пример: справа у нас категория множеств $\mathrm{Set}$ со всеми возможными функциями, а слева — категория моноидов над множествами $\mathrm{Mon}(\mathrm{Set})$. Объекты $m$ в ней являются такой конструкцией $(a \in \mathrm{Set},\,mon:\; a \otimes a + 1 \rightarrow a,\, \text{законы моноида})$. Допустимы лишь те морфизмы, что переводят одни моноиды в другие, то есть коммутируют с $mon$, сохраняя законы ассоциативности композиции и нейтрального элементы. Нас тут интересует функтор $U:\; \mathrm{Mon(Set)} \rightarrow \mathrm{Set}$, сопоставляющий каждому моноиду его множество.

![[! Диаграммы для 6 части#Забывание моноида]]
В категории $\mathrm{Set}$ между любыми объектами полно морфизмов, которых нет в $\mathrm{Mon(Set)}$. Функтор $U$ **забывает ограничения** $\mathrm{Mon(Set)}$ — «особенные» морфизмы сохраняющие моноиды буквально теряются в $\mathrm{Set}$ среди прочих морфизмов. Функторы, отображающие hom-множества *не сюръективно*, называют «забывающим».

За восстановление потерянных данных отвечает функтор $F$, сопряжённый к $U$ слева: $F \vdash U$.
![[! Диаграммы для 6 части#Изоморфизм hom-объектов для сопряжения $F \vdash U$]]
Для любого множества $a$ функтор $F$ подбирает такой моноид $Fa$, чтобы каждому морфизму моноидов $Fa \rightarrow m$ взаимно однозначно соответствовал морфизм множеств $a \rightarrow Um$. Очевидно, что $UFa \neq a$, то есть функтор $F$ приводит к моноиду, у которого *основное множество* будет отличаться от исходного. Объект $Fa$ представляет собой *наиболее общий моноид* для множества $a$, такой, что для него существует столько же способов получить произвольный моноид $m$, сколько и обычных функций от $a$ к множеству $m$. Бинарная операция для $Fa$ должна быть максимально обобщённой, *свободной* от привязки к другим бинарным операциям и позволяющей получить любую из них. Такой объект называется *свободным моноидом* для множества $a$. Функторы, сопряженные к забывающим слева, называют **свободными функторами**.

![[Вспомнить всё.png|Примерно так свободный функтор пытается восстановить всё то, что растерял забывающий.|600]]

Наверняка вы уже знаете, что свободным моноидом над множеством является *список* его элементов. Проверить это не сложно, но гораздо важнее научится *конструктивно выводить* подобные знания из условий задачи. Это мы сделаем позже, когда у нас будет алгоритм вычисления сопряжений. Сейчас же давайте сконцентрируемся на «обратности» сопряженных функторов по отношению к исходному.



# Правые расширения Кана

Пусть у нас есть функтор $F$, и нам нужно найти для него такой $G_F$, чтобы существовало сопряжение $G_F \dashv F$ с естественными преобразованиями
$$
\begin{eqnarray}
\eta:\; Id \rightsquigarrow F \circ G_F,\\
\varepsilon:\; G_F \circ F \rightsquigarrow Id.
\end{eqnarray}
$$

Функтор $G_F$ выглядит обратным к $F$ в том смысле, что их композиция позволяет получить тождественный функтор $Id$, играющий роль «единицы» для операции композиции, напоминающей «произведение» функторов. Поэтому для $G_F$ встречается другое обозначение: $Id/F$, что делает сопряжение чуть более наглядным:
$$
\begin{eqnarray}
&\varepsilon:\; Id/F \circ F \rightsquigarrow Id,\\
&\eta:\; Id \rightsquigarrow F \circ Id/F;\\
\\
&Id/F \dashv F.
\end{eqnarray}
$$

Конечно же, имеется виду не привычное деление, которое могло бы получиться, если бы здесь были строгие равенства и операция $\circ$ коммутировала. Сейчас это просто обозначение, в котором искомый функтор сформулирован через два известных, участвующих в естественных преобразованиях сопряжения. Но оно толсто намекает на *обобщение*, получаемое, если в коединице сопряжения заменить тождественный функтор на произвольный $K$, определённый на той же категории, что и $F$:


![[! Диаграммы для 6 части#Правое расширение Кана]]

> **Правым расширением Кана** функтора $K:\mathcal{C}\rightarrow\mathcal{D}$ вдоль функтора $F:\;\mathcal{C}\rightarrow\mathcal{A}$ называется такой функтор $\mathrm{Ran}_FK \equiv K/F:\; \mathcal{A}\rightarrow\mathcal{D}$ вместе с естественным преобразованием $\varepsilon: K/F \circ F \rightsquigarrow K$, что для любого кандидата $G:\mathcal{A} \rightarrow \mathcal{D}$ с преобразованием $\alpha: G \circ F \rightsquigarrow K$ существует единственное преобразование $u_\alpha: G \rightsquigarrow K/F$, такое что $\alpha=\varepsilon \cdot (u_\alpha \circ Id_F)$.
> Обозначение $\mathrm{Ran}$ происходит от «**R**ight K**an** Extension», а преобразование $\varepsilon$ называют *коединицей* правого расширения Кана.
> Вертикальная $\cdot$ и горизонтальная $\circ$ композиции естественных преобразований были [представлены в обзоре ранее](https://habr.com/ru/articles/951574/).

Как же можно «расширить» один функтор «вдоль» другого? У математиков вообще очень своеобразное воображение. Но давайте всё же попробуем их понять ~~и простить~~.

Перерисуем предыдущую категориальную диаграмму в таком виде:
### !!! Поправить шрифты
![[Pasted image 20251214230949.png|800]]
Функторы $K$ и $F$ отображают категорию $\mathcal{C}$ в $\mathcal{A}$ и $\mathcal{D}$. Само это отображение уже как бы «сопоставляет» между собой образы функторов, подкатегории $K\mathcal{C}$ и $F\mathcal{C}$. Задача функтора $K/F$ — продемонстрировать это сопоставление, «расширив» его с образа $F\mathcal{C}$ на всю категорию $\mathcal{A}$ так, чтобы естественное преобразование $\varepsilon$ явно переводило объекты образа композиции $K/F\,\circ\,F$ в образ $K$. Получается, что подкатегория $K\mathcal{C}$ как бы «расширяется» до $(K/F)\mathcal{A}$, внутри которой есть подкатегория $(K/F\,\circ\,F)\mathcal{C}$, явно сопоставленная с $K\mathcal{C}$ преобразованием $\varepsilon$… Ну всё же очевидно, да? Впрочем, неважно — главное, что математики делают вид, что такое название вполне соответствует сути.


# Свойства правого расширения Кана

Запись правого расширения Кана через инфиксный оператор $F/G$ отражает своего рода «обратность» этой конструкции по отношению к композиции функторов, аналогично делению по отношению к умножению. В частности, для *композиции* расширений Кана $Ran_H \circ Ran_G$ справедлива привычная алгебраическая формула:
$$
(F/G)/H \cong F/(H \circ G).
$$

Обозначение $\mathrm{Ran}_GF$ является более стандартным. В этом случае $\mathrm{Ran}_G$ сам выступает в роли функтора, действующему между категориями функторов. Если $G:\mathcal{C}\rightarrow\mathcal{A}$, то для любой категории $\mathcal{D}$ получаем $\mathrm{Ran}_G:\mathcal{D}^\mathcal{C}\rightarrow\mathcal{D}^\mathcal{A}$. Любопытно, что этот функтор оказывается сопряжённым справа к *функтору предкомпозиции* функторов $\_ \circ G: \mathcal{D}^\mathcal{C}\rightarrow\mathcal{D}^\mathcal{A}$ (вместо подчёркивания подставляется функтор, композиция которого с $G$ даёт новый функтор):
$$
\_ \circ G \dashv \mathrm{Ran}_G.
$$

Действительно, для любого $H:\mathcal{A}\rightarrow\mathcal{D}$ справедлив следующий изоморфизм:
$$
\mathrm{Hom}_{\mathcal{D}^\mathcal{C}}(H \circ G,\, F) \cong \mathrm{Hom}_{\mathcal{D}^\mathcal{A}}(H,\, \mathrm{Ran}_G F).
$$
Слева здесь морфизмы в категории функторов $\mathcal{D}^\mathcal{C}$ — совокупность естественных преобразований $\alpha: H \circ G \rightsquigarrow F$, каждое из которых вместе с функтором $H$ образует *кандидата* в правое расширение Кана. Слева же — универсальный морфизм $u: H \rightsquigarrow \mathrm{Kan}_GF$ для этого кандидата. Изоморфизм просто говорит о том, что каждому кандидату взаимно однозначно соответствует единственный универсальный морфизм. Коединица такого сопряжения $\varepsilon_F: (F / G) \circ G \rightsquigarrow F$ соответствует коединице расширения Кана, а единица имеет вид $\eta_F:  F \rightsquigarrow (F \circ G) / G$.

Ранее в [предыдущей части обзора](https://habr.com/ru/articles/970762/#scala) мы разбирали сопряжение эндофункторов в категории типов `Writer[S] ⊣ Reader[S]`. Любопытно, что для него получается очень похожий hom-изоморфизм: $\mathrm{Hom}(A \times S, B) \cong \mathrm{Hom}(A, B^S)$. Произведение объектов аналогично (с некоторой натяжкой) композиции функторов, но если первой операции противопоставляется экспоненциал, то во втором случае мы получили что-то вроде деления! Неужели эти понятия как-то связаны, или же так получилось случайно? На самом деле, случайности не случайны, и чуть позже мы убедимся в этом.

### !!! поточечные раширения Кана
https://ncatlab.org/nlab/show/Kan+extension#Pointwise


Перечисленные здесь свойства характерны не только для правых расширений Кана, они без труда переносится и на

# Левые расширения Кана

Мы пришли к правому расширению Кана, обобщив задачу поиска левого сопряжения (как ни парадоксально)). Если же мы бы начали с поиска правого расширения, то, ожидаемо, получили бы левое расширение Кана:

>**Левым расширением Кана** функтора $K:\mathcal{C}\rightarrow\mathcal{D}$ вдоль функтора $F:\;\mathcal{C}\rightarrow\mathcal{A}$ называется такой функтор $\mathrm{Lan}_FK:\; \mathcal{A}\rightarrow\mathcal{D}$ вместе с естественным преобразованием $\eta: K \rightsquigarrow \mathrm{Lan}_FK \circ F$, что для любого кандидата $G:\mathcal{A} \rightarrow \mathcal{D}$ с преобразованием $\alpha: K \rightsquigarrow G \circ F$ существует единственное преобразование $u_\alpha: \mathrm{Lan}_FK \rightsquigarrow G$, такое что $\alpha= (u_\alpha \circ Id_{K}) \cdot \eta$.
>Обозначение $\mathrm{Lan}$ происходит от «**L**eft K**an** Extension», а преобразование $\eta$ называют *единицей* левого расширения Кана.

![[! Диаграммы для 6 части#Левое расширение Кана]]

В данном обзоре наравне с общепринятым будет использоваться нестандартное обозначение $F \backslash K \equiv \mathrm{Lan}_FK$. Функтор, который мы факторизуем располагается как бы над чертой, а через который факторизуем — под ней. Такое обозначение «левого деления функторов» отражает дуализм по отношению к «правому делению» $K/F$.

По аналогии с $\mathrm{Ran}_G$, универсальное свойство для $\mathrm{Lan}_G$ образует похожее сопряжение с функтором предкомпозиции, что даёт такую [сопряжённую тройку](https://habr.com/ru/articles/970762/#triple):
$$
\mathsf{Lan}_G \dashv (\_ \circ G) \dashv \mathsf{Ran}_G.
$$
Для левых расширений Кана работает похожее правило композиции: $Lan_H (Lan_G F) \cong Lan_{H \circ G} F$, или в других обозначениях
$$
H\backslash(G\backslash F) = (H \circ G)\backslash F.
$$

### !!! Спойлер Подъёмы Кана

>Расширения Кана строятся для функторов, *исходящих* из одной категории. Но можно пойти и другим путём — рассматривать функторы, *сходящиеся* в одну и ту же категорию. Тогда получатся ещё два способа факторизации одного функтора по другому. Эти конструкции называются *подъёмами Кана* $\mathrm{Lift}$ и $\mathrm{Rift}$. В отличие от расширений Кана, они образуют сопряжённую тройку вокруг *посткомпозиции*:
$$
\mathrm{Lift}_G \dashv (G \circ \_) \dashv \mathrm{Rift}_G.
$$
Подъёмы Кана обладают свойствами, аналогичными расширениям, и они имеют те же основания называться «делением функторов». Так что в сумме мы имеем целых четыре различные операции, «обратные» композиции функторов. И это одна из причин, почему инфиксный оператор $/$ не часто используется в качестве обозначения правого расширения Кана.
Тем не мнее, расширений Кана вполне достаточно для решения большинства задач и подъёмы Кана практически нигде не рассматриваются.



Давайте посмотрим на конкретные примеры как левых, так и правых расширений Кана.





# Примеры расширений Кана

## (Ко)пределы

Для начала давайте вспомним, как устроены (ко)пределы функторов. Для некоторого (не для каждого) функтора $F:\mathcal{C} \rightarrow \mathcal{D}$ существуют такие объекты $\mathrm{(Co)Lim}\, F: \mathcal{D}$, которые в некотором смысле наилучшим образом представляют этот самый функтор. Такой объект, вместе с семейством морфизмов, индексированных объектами $c:\mathcal{C}$ образуют универсальный [(ко)конус](https://habr.com/ru/articles/970762/#cones) — естественное преобразование между заданным функтором $F$ и константным $\Delta_{\mathrm{(Co)Lim}\,F}$.

Константный функтор $\Delta_d: \mathcal{C} \rightarrow \mathcal{D}$ сочетает в себе две операции — полное «забывание» всей структуры категории $\mathcal{C}$ и *выбор* конкретного объекта $d: \mathcal{D}$. Удобно факторизовать диагональный функтор на два вспомогательных — один будет отвечать за «схлопывание» исходной категории в категорию $1$, состоящую из единственного объекта и его тождественного морфизма, а другой функтор будет отображать $1$ в $\mathcal{D}$, выбирая там нужный объект $d$:
$$
\begin{eqnarray}
\Delta_d &:& \mathcal{C} \rightarrow \mathcal{D} = d\, \circ\, !,\; \text{где}\\
!&:& \mathcal{C} \rightarrow 1,\\
d&:& 1 \rightarrow \mathcal{D}.
\end{eqnarray}
$$

Категория $1$ является *терминальным объектом* в категории категорий — функтор $!$ является его универсальным морфизмом, *единственным образом* «забывающим» структуру исходной категории, переводя все её морфизмы в тождественный для единственного объекта. Эта ситуация аналогична той, что мы рассматривали раньше в категории типов — тип `Unit` является её терминальным объектом, так существует единственный способ (функция) привести к нему любой другой тип.

Любой функтор, исходящий из $1$ моделирует её в конечной категории $D$, то есть, по сути, выбирает из неё единственный объект. Категория таких функторов $D^1$ изоморфна дискретной подкатегории, построенной на тех же объектах что и $D$. Поэтому часто для простоты эти функторы обозначают также, как и объекты $d: 1 \rightarrow \mathcal{D}$.

Получается следующая диаграмма в категории категорий:
![[! Диаграммы для 6 части#(Ко)предел]]

Функтор $F$ факторизуется через $!$ посредством «наилучших» $\mathrm{Colim}_F$ и $\mathrm{Lim}_F$, что отсылает нас к расширениям Кана. Действительно, несложно убедиться, что
$$
\begin{eqnarray}
\mathrm{Lim}\, F &\cong& F / !,\\
\mathrm{Colim}\, F &\cong& ! \backslash F.
\end{eqnarray}
$$
Другими словами, если (ко)предел функтора $F$ существует, то соответствующий «выбирающий функтор» будет изоморфен (левому)правому расширению Кана $F$ вдоль $!$.


## Сопряжения
Ранее уже были намёки, но теперь скажем открыто: если для функтора $F:\, \mathcal{C}\rightarrow\mathcal{D}$ существуют левое/правое сопряжение, то это будет (с точностью до изоморфизма) правое/левое расширение Кана тождественного функтора $Id:\mathcal{C}\rightarrow\mathcal{C}$ вдоль $F$:
$$
\begin{eqnarray}
{Id} / F \dashv F \dashv F \backslash {Id}.
\end{eqnarray}
$$
В [предыдущей части обзора](https://habr.com/ru/articles/970762/#triple) было показано, как сопряжённые тройки порождают монады и комонады. Представленная тройка интересна тем, что она параметризирована по сути единственным функтором $F$ — он один порождает целую россыпь (ко)монад! В частности, для эндофункторов $F \circ (Id/F):\;\mathcal{D}\rightarrow\mathcal{D}$ и $(F \backslash Id) \circ F:\;\mathcal{C}\rightarrow\mathcal{C}$ из данной тройки мы получаем монады, а для $(Id/F) \circ F:\;\mathcal{C}\rightarrow\mathcal{C}$ и $F \circ (F \backslash Id):\; \mathcal{D}\rightarrow\mathcal{D}$ — комонады. 

## Монада коплотности

Конечно же, не для каждого функтора могут существовать левое и правое сопряжение. В таких случаях расширения Кана можно рассматривать как «наилучшие попытки» построить сопряжения. Если для функтора $F:\, \mathcal{C}\rightarrow\mathcal{D}$ сопряжения всё же существуют, то справедливыми оказываются следующие изоморфизмы:
$$
\begin{eqnarray}
F \circ (Id/F) \cong F/F,\\
F \circ (F \backslash Id) \cong F \backslash F.
\end{eqnarray}
$$
Соотношения кажутся очевидными со школы, но ввиду не совсем обычных операций «деления функторов», для их выполнения требуются определённые условия, вроде наличия сопряжения и строгого порядка функторов.

К примеру, рассмотрим первый изоморфизм, представленный двумя встречными естественными преобразованиями:
$$
\begin{eqnarray}
\varphi:\;& F \circ (Id / F) &\rightsquigarrow&& F/F,\\
\psi:\;& F/F &\rightsquigarrow&& F \circ (Id / F).\\
\end{eqnarray}
$$
Они должны фиксироваться известными преобразованиями сопряжения, а также коединицей расширения Кана $\varepsilon_{\mathrm{Ran}}$:
$$
\begin{eqnarray}
\varepsilon_\dashv:\;& (Id / F) \circ F &\rightsquigarrow Id, \\
\eta_\dashv:\;& Id &\rightsquigarrow F \circ (Id / F), \\
\varepsilon_{\mathrm{Ran}}:\;& (F / F) \circ F &\rightsquigarrow F.
\end{eqnarray}
$$
С их помощью одна ветвь изоморфизма выражается так:
$$
\psi = (\varepsilon_{\mathrm{Ran}} \circ Id_{Id/F}) \cdot (Id_{F/F} \circ \eta_\dashv).
$$

А вот для явного выражения $\varphi$ данных преобразований не достаточно. Тут нас выручит универсальный морфизм расширения Кана $u_G:\; G \rightsquigarrow F/F$, *взаимно однозначно* соответствующему преобразованию $\alpha_G: F \circ G \rightsquigarrow F$, заданного для произвольного кандидата $G: \mathcal{D} \rightarrow \mathcal{D}$. Выберем в качестве кандидата тождественный функтор $Id$ в категории $\mathcal{D}$ с тождественным преобразованием $\alpha_{Id}=Id_F: F \rightsquigarrow F$. Для такого кандидата у нас будет универсальный морфизм вида
$$
u_{Id} = Id \rightsquigarrow F/F.
$$
и он поможет нам явно выписать другую ветвь искомого изоморфизма:
$$
\varphi = (Id_{F/F} \circ \varepsilon_\dashv) \cdot (u_{Id} \circ Id_{F \circ (Id/F)}).
$$

Тут можно заметить подвох — утверждается, что у нас уже есть преобразование $u_{Id}$, однозначно фиксированное известными $\varepsilon_{\mathrm{Ran}}$ и $\alpha_{Id}$ через универсальное свойство. Однако, $u_{Id}$, определяется как *решение уравнения* $\alpha_{Id}=\varepsilon_{\mathrm{Ran}} \cdot (u_{Id} \circ Id_F)$, и для него просто нет явного выражения в виде композиции естественных преобразований! Мы, конечно, могли бы попробовать ввести что-то вроде операции «деления естественных преобразований», но есть и другой подход, мы рассмотрим его позднее. Пока же достаточно того, что нам удалось продемонстрировать корректность изоморфизма $F \circ (Id/F) \cong F/F$.

Зачем же нам заморачиваться с этим изоморфизмом и функтором $F/F$? Сопряжение даёт нам монаду для $F \circ (Id/F)$, но фокус в том, что $F/F$ *образует монаду даже тогда, когда функтор $F$ вообще не имеет левого сопряжения*! Правое расширение Кана функтора $F$ вдоль самого себя называется **монадой коплотности** функтора $F$:
$$
\mathrm{Codens}\, F \equiv \mathrm{Ran}_F F.
$$

Преобразования монады можно получить, воспользовавшись знакомым трюком, основанном на эксплуатации универсального свойства расширения Кана для конкретных кандидатов. Полученное ранее преобразование $u_{Id} = Id \rightsquigarrow F/F$ даёт «запаковку» для нашей монады. Если же в качестве кандидата выберем $F/F \circ F/F$ с преобразованием $\alpha: F/F \circ F/F \circ F \rightsquigarrow F = \varepsilon_{\mathrm{Ran}} \cdot (Id_{F/F} \circ \varepsilon_{\mathrm{Ran}})$, то ему будет взаимно однозначно соответствовать *универсальный морфизм* $u: F/F \circ F/F \rightsquigarrow F/F$, по счастливой случайности отвечающий как раз за «разматрёшивание» монады.

### !!! СПОЙЛЕР Сопряжение для монады коплотности
> Даже если у функтора $F:\mathcal{C} \to \mathcal{D}$ нет лево-сопряжённого, всё равно можно построить монаду его коплотности в категории $\mathcal{D}$. Но, как уже говорилось в предыдущей части обзора, каждая монада порождается сопряжением. Выглядит как парадокс, но на самом деле тут всё в порядке. Каждую монаду можно получить более чем из одного сопряжения функторов, и эти функторы проходят через дополнительные категории, зачастую не совпадающие ни с $\mathcal{D}$, ни с исходной $\mathcal{C}$.
> Например, для выбора сопряжения, подходящего монаде $F$, часто эксплуатируют категорию алгебр Эйленберга-Мура $\mathcal{D}^T$. Объекты здесь будут парами $(d:\mathcal{D},\, Fd \to d)$, а морфизмы сохраняют монадные преобразования и «распаковку». Также у нас есть очевидный забывающий функтор $U^T:\mathcal{D}^T \to \mathcal{D}$, просто отбрасывающий «распаковку», и свободный функтор $F^T$, который действует на объекты так: $F^Td=(F/Fd,\, \mu_{d})$, где преобразование $\mu$ — это «разматрёшивание» монады $F/F$. Эти функторы и образуют искомое сопряжение $F^T \dashv U^T$, порождающее монаду коплотности $F/F = U^T \circ F^T$.
> Более того, у нас автоматически получается забавный изоморфизм:
$$
F/F \cong (F/F) / (F/F).
$$
> А ещё нам доступен так называемый «функтор сравнения» $K: \mathcal{C} \to \mathcal{D}^T$. Он действует на объекты так: $Kc = (Fc, \varepsilon_c)$, где $\varepsilon: (F/F) \circ F \rightsquigarrow F$ есть коединица расширения Кана $F/F$. Функтор сравнения интересен тем, что через него факторизуется исходный функтор: $F = U^T \circ K$.

Универсальное свойство монады коплотности обладает ещё одной замечательной особенностью. Дело в том, что преобразования $\alpha: (F/F)^n \circ F \rightsquigarrow F$ для кандидатов вида $(F/F)^n$ можно записать как $\alpha = \varepsilon \cdot (Id_{F/F} \circ (\varepsilon \cdot (Id_{F/F} \circ (\varepsilon \cdot \ldots)))) = \varepsilon \cdot (Id_{F/F} \circ \varepsilon) \cdot (Id^2_{F/F} \circ \varepsilon) \cdot \ldots$. Явное устройство универсального морфизма $u$, взаимно однозначно соответствующего этому $\alpha$, мы рассмотрим позже, но уже сейчас выглядит очевидным, что «разматрёшивание» вложенных функторов коплотности $(F/F)^n \rightsquigarrow F/F$ *одинаково «атомарно» для любого* $n$. Оно описывается аналогично $\alpha$ — это просто композиция ~~функций~~ преобразований! Поэтому в программировании монада коплотности даёт мощную оптимизацию вычислений цепочек функций с эффектами. Ассоциативность «разматрёшивания» монады коплотноти эквивалентна ассоциативности композиции морфизмов и фактически встроена в универсальное свойство.

В программировании монада коплотности больше известна как *монадный трансформер продолжения* $\mathop{ContT} F \equiv \mathop{Codens} F$. Он трансформирует эндофунктор категории типов в новый, обладающий монадными возможностями, причём для обратного преобразования в $F$ требуется передать функцию с эффектом $F$, *продолжающую* вычисления с «запакованным» значением. Способности монады коплотности к оптимизации вычислений с эффектами лежат в основе особой техники программирования — *стиля передачи продолжения* (**C**ontinuation **P**assing **S**tyle). Эта техника встроена в компиляторы многих языков программирования и [применяется](https://habr.com/ru/articles/807495/#continuations) в Scala в новомодном Direct Style, раскручиваемом Мартином Одерски.

Аналогично доказывается изоморфизм $F \circ (F \backslash Id) \cong F \backslash F$. Левое расширение Кана функтора $F$ вдоль самого себя образует **комонаду плотности** $\mathrm{Dens}\, F \equiv F \backslash F$ и её существование не зависит от наличия правого сопряжения к $F$. Эта «универсальная комонада» полезна сама по себе, но далее мы рассмотрим любопытные сочетания её с другими расширениями Кана.

Концепция плотности позаимствована из топологии. Считается, что множество $C$ плотно в $D$ (как рациональные числа в вещественных), если любая точка $d \in D$ является пределом последовательности из $C$. Теория категорий обобщает это понятие: функтор $F:\mathcal{C}\to\mathcal{D}$ называется *(ко)плотным*, если для каждого $d:\mathcal{D}$ в образе $F$ найдётся такая диаграмма, что $d$ будет её (ко)пределом.

### !!! СПОЙЛЕР подробнее про плотность
> Для плотного функтора $F$ выполнятся условие $F \backslash F \cong Id$, а для коплотного — $F / F \cong Id$. Если эти расширения Кана не изоморфны тождественному эндофунктору, значит функтор $F$ отображает исходную категорию «не плотно» — либо в исходной категории не достаточно данных, либо самого функтор слишком «забывчивый» .
> Плотные функторы позволяют «воссоздать» из своего образа все объекты категории $\mathcal{D}$. 
> Коплотные функторы содержат в своём образе достаточно диаграмм, чтобы «детектировать» все объекты в $\mathcal{D}$, различить их только на основе морфизмов из образа.
> И плотные, и коплотные функторы отвечают за своеобразное «кодирование» целой категории лишь малой его частью, но делают они это по-разному, дуально. Очевидно, что большинство функторов не обладают ни тем ни другим свойством, но есть и такие, которые являются и плотными и коплотными одновременно. Например, это изоморфизмы категорий, или отображения в *скелет категории* (содержащий лишь по одному объекту для каждого изоморфизма в категории).

(Ко)монады в категории $\mathcal{C}$, порождённые сопряжённой тройкой, построенной вокруг функтора $F:\mathcal{C} \to \mathcal{D}$, также иногда описывают с позиции «плотности»:
$$
\begin{eqnarray}
(F \backslash Id) \circ F &\;\;-\;& \text{монада плотности;}\\
(F / Id) \circ F &\;\;-\;& \text{комонада коплотности.}
\end{eqnarray}
$$
Они связаны не с расширениями, а с упомянутыми ранее подъёмами Кана, и используются редко.




## Представления Йонеды

Ранее мы видели расширения функтора $F$ вдоль себя и тождественного вдоль $F$. Для полноты картины рассмотрим расширение функтора вдоль тождественного:
![[! Диаграммы для 6 части#Йонеда]]

Эти расширения Кана соответствуют так называемым *представлениям Йонеды*:
$$
\begin{eqnarray}
&&よ &=& \mathrm{Ran}_{Id},\\
&&よ^{op} &=& \mathrm{Lan}_{Id}.
\end{eqnarray}
$$

### !!! СПОЙЛЕР Трудности перевода

> Японский математик Нобуо Йонеда (написание через «йо» уже устоялось) доказал в теории категорий очень важную лемму и мы ещё рассмотрим её позднее. Саундерс Маклейн, один из основателей теории категорий, предложил назвать эту лемму именем автора. То же имя получили специфичный для леммы функтор $\mathcal{C} \to \mathrm{Set}^{\mathcal{C}}$ (вложение Йонеды), а также рассмотренные выше представления функторов.
> Для этих конструкций иногда используют обозначения $\mathcal{Y}$ или просто $\operatorname{Yoneda}$, но в [одной работе 2015 года](https://arxiv.org/abs/1502.06526) предложили более короткое обозначение $\operatorname{よ}$ — букву японской азбуки хирагана, читающуюся как «ё», первый слог фамилии Йонеды.
> Японские фамилии обычно записывают иероглифами, которые могут иметь разное прочтение, и японцы пользуются хираганой, чтобы пояснять, как правильно читать их фамилии. Оригинальная запись фамилии Йонеды состоит из двух иероглифов: «米田», где «米» имеет самостоятельное значение «рис», а читается как \[коме]\. Поэтому использовать такой символ в качестве математического обозначения было бы не лучше идеей.
> Авторы той статьи обосновывали отказ от символа 米 как-то так: «в нём слишком много черт, и неудобно записывать на доске»… В данном же обзоре символ $\operatorname{よ}$ выбран ещё и потому, что его произношение «Ё» несёт особую энергетику, которая призвана помочь программистам в усвоении основ теории категорий))).
> Кстати, обычно этот символ используют для вложения Йонеды, но здесь им обозначены именно представления Йонеды, так как они более важны в программировании.

Интересной особенностью представлений Йонеды является то, что они изоморфны исходным функторам:
$$
\mathop{よ} F \cong F \cong \mathop{よ^{op}} F.
$$

Действительно, возьмём к примеру представление ко-Йонеды $\mathop{よ^{op}}F = Id \backslash F$. Единица этого расширения Кана даёт одну ветвь изоморфизма $\eta: F \rightsquigarrow \mathop{よ^{op}}F$. Обратную ветвь (коединицу) мы получим как универсальный морфизм $u_F: \mathop{よ^{op}}F \rightsquigarrow F$, если в качестве кандидата выберем $F$ с преобразованием $\alpha= u_F \cdot \eta=Id_F$. Универсальный морфизм буквально является *обратным* к единице и при этом он однозначно фиксирован выбором кандидата. Для представления Йонеды $\mathop{よ}F = F / Id$ результат будет аналогичный.

Казалось бы, какая может быть польза от изоморфных функторов? Секрет в том, что представления позволяют оптимизировать цепочки *простых* преобразований внутри «контейнера» $F: \mathcal{C} \to \mathcal{D}$. А именно, если последовательность морфизмов из категории $\mathcal{C}$ по шагам переносится представлением Йонеды функтора $F$ в $\mathcal{D}$, то, (внезапно!) сам функтор $F$ при этом не задействуется! Представление $よ$ на каждом шаге комбинирует преобразования в одно действие, тогда как $よ^{op}$ запоминает их в своеобразном «списке» . В обоих случаях реальное использование функтора $F$ происходит лишь в момент «распаковки» представления посредством изоморфизма. Наиболее принципиальное различие между представлениями заключается лишь в том, на каком этапе требуется предоставить доказательства функториальности $F$ — при переходе к представлению, или при возвращении обратно.

К сожалению, не нашёл способа продемонстрировать эту оптимизацию, не вникая в устройство представлений Йонеды и расширений Кана. Но мы обязательно сделаем это в продолжении обзора.

### !!! Свободный функтор и дуальное понятие


 
## Представление передачи продолжений


$$
\mathop{Cps} F = (Id/F) / F
$$
```scala
type Cps[F[_], A] = 
  [Y] => (A => F[Y]) => ([Z] => (Y => Z) => F[Z])
```

```  
```scala
type OptimizedEff[F[_], A] = Free[Coyoneda[F, *], A]
```

```haskell
type FastFree f a = Codensity (Free (Yoneda f)) a
```


## Свобоная монада

![[GPT свободная монада]]


### !!! ????

$$
\operatorname{𝐿𝑎𝑛}_{Yoneda}𝐹
$$


![[GPT Lan вдоль Йонеды]]


## Бесплатная свободная монада

Zero-cost free monad - это CPS-обёртка над свободной монадой


# Дополнительная литература


- [String Diagrams](https://stringdiagram.com/) (Dan Marsden)
	- [Codensity Monads and Kan Extensions](https://stringdiagram.com/2022/12/06/codensity-monads-and-kan-extensions/)
	- [Where do monads come from?](https://stringdiagram.com/2022/05/17/where-do-monads-come-from/)
	- [The Codensity Monad Transformer](https://stringdiagram.com/2023/05/14/the-codensity-monad-transformer/)
	- [The Continuation Monad](https://stringdiagram.com/2022/11/21/the-continuation-monad/)
- [Bartosz Milewski's Programming Cafe](https://bartoszmilewski.com/ "Bartosz Milewski's Programming Cafe")
	- [Kan extensions](https://bartoszmilewski.com/2017/04/17/kan-extensions/)
	- [Pointwise Kan extensions](https://bartoszmilewski.com/2018/01/23/pointwise-kan-extensions/)
	- [Monads categorically](https://bartoszmilewski.com/2016/12/27/monads-categorically/)
	- [Algebras for monads](https://bartoszmilewski.com/2017/03/14/algebras-for-monads/)
- [Comonads](http://comonad.com/reader/) (Ed Kmett)
	- [Kan Extensions](http://comonad.com/reader/2008/kan-extensions/ "Permanent Link: Kan Extensions")
	- [Kan Extensions II: Adjunctions, Composition, Lifting](http://comonad.com/reader/2008/kan-extensions-ii/ "Permanent Link: Kan Extensions II: Adjunctions, Composition, Lifting")
- [Higher Order](https://blog.higher-order.com/) (Rúnar Óli Bjarnason)
	- [Freedom and Forgetfulness](https://blog.higher-order.com/blog/2015/10/12/freedom-and-forgetfulness/)
	- [Free Monoids and Free Monads](https://blog.higher-order.com/blog/2013/08/20/free-monads-and-free-monoids/)

![[Расширения Кана]]

Ссылки из [[GPT Йонеда]]


# Промежуточный итог


Изоморфизм $G\circ \>\mathrm{Ran}\>{}_{F}\text{Id}\cong \>\mathrm{Ran}\>{}_{F}G$ гарантированно выполняется в следующих случаях:
- $G$ — правый сопряженный: Если у функтора $G$ есть левый сопряженный $L \dashv G$, то он сохраняет все пределы, и, следовательно, сохраняет правые расширения Кана.
- Наличие левого сопряжения у $F$: Если у функтора $F$ есть левый сопряженный $L \dashv F$, то, как мы разбирали ранее, $\mathrm{Ran}\>{}_{F}X\cong X\circ L$. В этом случае изоморфизм становится тривиальным свойством ассоциативности композиции функторов: $G\circ (\text{Id}\circ L)\cong (G\circ \text{Id})\circ L\cong G\circ L$
- $\mathrm{Ran}_{F}\text{Id}$ — *абсолютное расширение Кана*: Это расширение, которое сохраняется вообще любым функтором $G$. Это редкий случай, встречающийся, например, если $F$ — вполне верный функтор с сопряжением (или изоморфизм категорий).

http://comonad.com/reader/2015/categories-of-structures-in-haskell/

http://comonad.com/reader/2008/kan-extensions-ii/#:~:text=Changing%20Representation

Given a `f -| g`, ``g `O` f`` is a monad, and ``Ran (g `O` f) (g `O` f)`` is the monad generated by ``(g `O` f)``, described in the previous post. We showed above that this monad can do many of the same things that the original monad could do. From there you can `decomposeRan` to get ``Ran g (Ran f (g `O` f))``, which you can show to be yet another monad, and you can continue on from there.

Each of these monads may have different operational characteristics and performance tradeoffs. For instance the codensity monad of a monad can offer [better asymptotic performance](http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf) in some usage scenarios.

Similarly the left Kan extension can be used to manipulate the representation of a comonad.




This monad provides a useful opportunity for optimization. For instance Janis Voigtländer noted in [Asymptotic improvement of functions over Free Monads](http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf) that a particular monad could be used to improve performance -- Free monads as you'll recall are the tool used in Wouter Sweirstra's [Data Types á la Carte](http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf), and provide an approach for, among other things, decomposing the `IO` monad into something more modular, so this is by no means a purely academic exercise!


### !!! выяснить!!
> Наиболее важное свойство сопряжённых функторов — их непрерывность: каждый функтор, имеющий левый сопряжённый (то есть являющийся правым сопряжённым), коммутирует с [пределами](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\) "Предел (теория категорий)") в категорном смысле. Соответственно, функтор, имеющий правый сопряжённый, _конепрерывен_, то есть коммутирует с [копределами](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB_\(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9\)&action=edit&redlink=1 "Копредел (теория категорий) (страница отсутствует)").
