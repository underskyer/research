
# Наивные варианты


# Стрелки

Профункторы представляют функциональные отношения в категории типов. И технически они могут быть морфизмами, но для этого нужно предоставить для них законопослушную композицию и тождественный морфизм. Если для некого `Pro[-_, +_]` есть экземпляры классов типов `Profunctor[Pro]` и `Category[Pro]` (см. **предыдущую часть обзора**), то такой профунктор называется **стрелкой**.

```scala
type Arrow[==>[_, _]] = Profunctor[==>] × Category[==>]
```

В предыдущей части обзора упоминался hom-тип категории Клейсли
```scala
type Kleisli[F[+_]] = [A, B] =>> A => F[B]
```
Такие морфизмы описывают вычисления «с эффектами»,  определёнными конструктором типов `F[+_]`. Класс типов `Category[Kleisli[F]]` даст удобные средства для построения цепочки эффективных вычислений, а, в свою очередь, `Profunctor[Kleisli[F]]` позволит встраивать в эту цепочку простые (типа, «чистые») функции вида `A => B`. В этом и заключается идея объединения возможностей `Profunctor` и `Category` в один класс типов `Arrow`.

Стрелки отвечают за композицию вычислений, поэтому их зачастую снабжают дополнительными возможностями. В библиотеке Cats класс типов [Arrow](https://www.javadoc.io/doc/org.typelevel/cats-core_3/latest/cats/arrow/Arrow.html) наследует не просто профунктор, но так называемы «сильный профунктор» [Strong](https://www.javadoc.io/doc/org.typelevel/cats-core_3/latest/cats/arrow/Strong.html), который позволяет стрелке `Pro[_, _]` коммутировать с произведением типов, расщепляя путь вычисления на два *параллельных* (независимых). В той же библиотеке есть [ArrowChoice](https://www.javadoc.io/doc/org.typelevel/cats-core_3/latest/cats/arrow/ArrowChoice.html) который, помимо прочего, позволяет стрелке коммутировать с суммой типов, расщепляя путь вычисления на два *альтернативных*.

Стрелки [рассматривались в одном из моих предыдущих обзоров](https://habr.com/ru/articles/807495/#arrows) и, возможно, мы вернёмся к этой теме под конец данного.



# Алгебраические эффекты

Kyo
https://koka-lang.github.io/koka/doc/book.html#sec-effect-types


# Монадные трансформеры


## !!! (Ко)свободные конструкции

https://blog.higher-order.com/blog/2015/10/12/freedom-and-forgetfulness/

[The Continuation Monad](https://stringdiagram.com/2022/11/21/the-continuation-monad/)

>[We are now ready to explain](https://bartoszmilewski.com/2016/04/18/adjunctions/#:~:text=We%20are%20now%20ready%20to%20explain%20why%2C%20in%20Haskell%2C%20the%20right%20adjoint%20is%20automatically%20a%20representable%20functor.) why, in Haskell, the right adjoint is automatically a [representable functor](https://bartoszmilewski.com/2015/07/29/representable-functors/).

https://blog.higher-order.com/blog/2013/08/20/free-monads-and-free-monoids/


## !! Монадные трансформеры

[Where do monads come from?](https://stringdiagram.com/2022/05/17/where-do-monads-come-from/)
[The Codensity Monad Transformer](https://stringdiagram.com/2023/05/14/the-codensity-monad-transformer/)
[Right Kan Extension as (almost) a Monad Transformer](http://comonad.com/reader/2008/kan-extensions-ii/#:~:text=Right%20Kan%20Extension%20as%20(almost)%20a%20Monad%20Transformer)


![asa](http://comonad.com/reader/2008/kan-extensions-ii/#Changing%20Representation)



# Императивный стиль


[Direct-style Effects Explained](https://noelwelsh.com/posts/direct-style/)

# Возможности (Capabilities)


# Теории Лавера




