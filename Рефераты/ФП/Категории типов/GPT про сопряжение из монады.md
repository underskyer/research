Это отличный вопрос, который бьет точно в центр путаницы между «функтором, из которого мы строили» и «функтором, который получился в итоге».

Вы абсолютно правы: если есть монада, для неё обязано существовать сопряжение.

Разгадка кроется в том, что для монады $T = Ran_F F$ это сопряжение не обязано вовлекать исходный функтор $F$ и исходную категорию $\mathcal{C}$.

▌1. Два разных сопряжения

Пусть $F: \mathcal{C} \to \mathcal{D}$. Мы построили монаду $T = Ran_F F$ на категории $\mathcal{D}$.

1. Сопряжение, которого может не быть: $L \dashv F$, где $L: \mathcal{D} \to \mathcal{C}$.
  Вы верно говорите: мы исходим из того, что такого $L$ нет.
2. Сопряжение, которое есть всегда: Для любой монады $T$ на $\mathcal{D}$ мы можем построить категорию алгебр Эйленберга-Мура $\mathcal{D}^T$. Там всегда есть каноническое сопряжение $F^T \dashv U^T$:
  •  $U^T: \mathcal{D}^T \to \mathcal{D}$ (забывающий функтор).
  •  $F^T: \mathcal{D} \to \mathcal{D}^T$ (свободный функтор).
  •  И по определению $T = U^T \circ F^T$.

В чем фокус?
Функтор $U^T$ (забывающий функтор из категории алгебр) — это не то же самое, что ваш исходный функтор $F$. И категория алгебр $\mathcal{D}^T$ — это не то же самое, что ваша исходная категория $\mathcal{C}$.

▌2. Что же такое «виртуальная монада»?

Под словом «виртуальная» я имел в виду вот что:

Если бы у $F$ был левый сопряженный $L$, то монада $T$ была бы просто $F \circ L$. В этом случае $F$ сам бы играл роль «забывающего функтора» в сопряжении, порождающем монаду.

Но когда у $F$ нет левого сопряженного, $Ran_F F$ все равно создает монаду. Эта монада «выглядит и пахнет» как монада сопряжения, но она не может найти своего «родителя» $L$ в категории $\mathcal{C}$. Она находит его в другой категории — в категории своих собственных алгебр.

Связь между ними:
Существует канонический функтор $K: \mathcal{C} \to \mathcal{D}^T$ (функтор сравнения). Он связывает ваш исходный функтор $F$ и забывающий функтор монады коплотности $U^T$:
$$F \cong U^T \circ K$$
То есть $F$ — это всего лишь «часть» забывающего функтора $U^T$.

▌3. Интуитивный пример (программирование)

Представьте монаду Codensity f.
•  Функтор f — это просто какой-то тип данных (например, BinaryTree), у которого нет flatMap и который не является результатом никакого сопряжения. У него «нет пары».
•  Но Codensity BinaryTree — это монада. Значит, для неё есть сопряжение. Где оно?
•  Оно существует между категорией всех типов и категорией «алгебр» этой конкретной монады коплотности.
•  Мы как бы «симулировали» существование сопряжения для BinaryTree, создав вокруг него более сложную структуру.

▌Итог
Утверждение Милевски «Каждая монада является коплотной монадой для этого сопряжения» означает следующее:

1. Возьмите монаду $T$.
2. Найдите её каноническое сопряжение $F^T \dashv U^T$ (через алгебры).
3. Тогда $T \cong Ran_{U^T} U^T$.

А ваше замечание говорит о другом: «Мы можем построить коплотную монаду даже для функтора $F$, который не является частью никакого сопряжения».

Это правда. Но как только вы её построили, вы создали новое сопряжение (с категорией алгебр), в котором $F$ будет участвовать лишь опосредованно.

Почему это важно? Это позволяет нам работать с любым функтором $F$ так, будто у него есть сопряженный, даже если в реальности (в категории $\mathcal{C}$) его не существует. Мы как бы «выдумываем» недостающую структуру. Именно в этом смысле она «виртуальна» относительно исходной категории $\mathcal{C}$.