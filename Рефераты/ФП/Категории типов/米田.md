


Йонеда – ленивый функтор с предварительной композицией преобразований внутри контейнера 
Койонеда – по сути то же самое, но требование функториальности контейнера переносится в конец
И Йонеда, и Койонеда – это естественные преобразования


[Yoneda lemma (Кубужок)](https://kubuszok.com/2018/the-f-words-functors-and-friends/#yoneda-lemma)
[Maths - Category Theory - Yoneda](https://www.euclideanspace.com/maths/discrete/category/higher/yoneda/index.htm) (картинки)
[Free monads for less: Yoneda](http://comonad.com/reader/2011/free-monads-for-less-2/)
[Free monads for less: Yielding IO](http://comonad.com/reader/2011/free-monads-for-less-3/)
[[Type Arithmetic and the Yoneda Perspective.pdf]]
[Free Monads and the Yoneda Lemma](http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/)

https://journeyinmath.wordpress.com/2021/10/29/yo/ — про сложность よ

В математике возник вопрос, каким символом обозначить конструкцию, предложенную Нобуо Йонедой? На японском языке эта фамилия записывается двумя иероглифами «米田», где `米` сам по себе читается как \[коме\], в переводе значит «рис». Поэтому в математической литературе используется не иероглиф, а буква `よ` из японской азбуки хирагана. Эта буква не имеет самостоятельного смысла и читается как \[йо\] – первый слог фамилии Йонеда.

https://arxiv.org/abs/1502.06526
$ょ: F \rightarrow \mathrm{Set}^F$ — вложение Йонеды
$ょ_c$  — вложение ко-Йонеды





Вот пример реализации концепции правых расширений Кана (Kan extensions) вместе с вложением Йонеды (Yoneda's embedding) на языке программирования Scala. Этот пример включает использование типов высших порядков и комбинаторов для выражения абстрактных конструкций теории категорий.

Общие структуры
```scala
trait Category[C[_], _A, _B]:
  def id[A]: C[A]
  def compose[X, Y, Z](f: C[X => Y], g: C[Y => Z]): C[X => Z]
```
Здесь мы определяем категорию (Category), которая представляет собой совокупность объектов и морфизмов между ними. Она принимает два параметра типа: ковариантный контейнер C и объекты категории _A, _B. Мы требуем наличие двух операций: единицы (идентичности) и композиции морфизмов.

Каноническое вложение Йонеды
```scala
object YonedaEmbedding {
  type Yoneda[F[_], A] = ({type λ[B] = F[B] =>* A})#λ // Вложение Функтора F в категорию предфункционалов

  trait Embedding[F[_], C[_]] extends Category[C, _, _]:
    def embed[A](fa: F[A]): Yoneda[F, A]
}
```
Мы вводим понятие вложенного функтора, представляя каждый объект категории через соответствующий контравариантный предфункционал (presheaf). Здесь мы используем вложенный тип и оператор =>* для представления гомоморфизма (morphism).

Правые расширения Кана

Правое расширение Кана для функторов определяется следующим образом:
```scala
import scalaz._
import Scalaz._

// Тип права Kan extension
case class RightKanExtension[D[_], E[_], X](run: D[X])

// Определение операции Ran для произвольных функторальных структур
def rightKanExtend[F[_], G[_], H[_], A](f: F[A])(implicit ev: Representable[H]): RightKanExtension[({type l[a]=H[a]}), G, A] =
  new RightKanExtension((ga: G[A]) => f.foldMap(ev.represent(ga)))
```
Здесь используется имплицитный экземпляр класса типа Representable, обеспечивающего представление контейнера через индексируемый доступ. Это позволяет нам вычислить канонический образ функторного отображения.

Применение на практике

Рассмотрим простой пример использования нашего аппарата для преобразования функционалов. Предположим, мы хотим реализовать преобразование между двумя различными структурами данных.
```scala
sealed trait Tree[A]
final case class Leaf[A](value: A) extends Tree[A]
final case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]

val treeFunctor: Functor[Tree] = new Functor[Tree]:
  override def map[A, B](ta: Tree[A])(f: A => B): Tree[B] = ta match
    case Leaf(a)     => Leaf(f(a))
    case Branch(l, r) => Branch(map(l)(f), map(r)(f))

val listFunctor: Functor[List] = List.functor

val leafValue = Leaf("Hello")
val branchValue = Branch(Leaf("World"), Leaf("Scala"))

val result = rightKanExtend(treeFunctor.map(_))(branchValue)
println(result.run(List.empty)) // Получаем пустой список
```

Заключение

Приведённый пример демонстрирует применение концепций теории категорий на практике в Scala. Использование правых расширений Кана и вложения Йонеды позволяет выражать мощные абстракции и строить функциональные программы с высокоуровневыми конструкциями. Однако, хотя теоретически всё выглядит изящно, реализация подобных подходов требует тщательного проектирования и глубокого понимания лежащих в основе понятий.

- А. Yoneda (Правое расширение / Монада коплотности) Используется, когда у вас уже есть Functor для F, но вы хотите оптимизировать композицию. Изоморфизм: F[A] $\leftrightarrow $ Yoneda[F, A].Польза: Yoneda переводит map из области манипуляции данными в область композиции функций. Вместо $N$ проходов по структуре данных вы делаете 1 проход в самом конце. Это «фьюжн» (fusion) на стероидах.
- Б. Coyoneda (Левое расширение) Используется, когда у вас нет (или вы не хотите реализовывать) Functor для F. Изоморфизм: $F[A] \leftrightarrow  Coyoneda[F, A]$.Польза: Coyoneda позволяет вызывать map на чем угодно (даже на обычном типе или GADT), сохраняя цепочку функций в памяти. Вы «дарите» своему типу свойство функтора бесплатно. Изоморфизм «завершается» только в момент интерпретации, когда вы предоставляете реальный способ отобразить F в какой-то другой функтор
- G. Резюме с позиции расширений Кан
	- Yoneda — это способ смотреть на данные через призму всех возможных результатов (продолжений)
	- Coyoneda — это способ смотреть на данные через призму всех возможных источников (причин).
	- В обоих случаях расширения Кана гарантируют, что этот «взгляд со стороны» ничего не теряет и не добавляет лишнего относительно исходного типа F[A]. Изоморфизм — это математическая гарантия того, что такая абстракция «честна».