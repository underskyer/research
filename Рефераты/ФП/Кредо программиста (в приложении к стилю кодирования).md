![[Эцио.png|600]]

Однажды меня попросили подготовить рекомендации по программированию на Scala для сотрудников нашей компании Solar. В поисках лучших рецептов приходилось заглядывать в самые пыльные уголки Интернета, и в одном из них, в старом проржавелом сундуке я заметил старинный конверт. Просто из любопытства решил заглянуть туда, благо конверт был уже вскрыт. Ветхие страницы, поблекшие чернила, но содержание настолько меня заворожило, что я просто не мог не поделиться со всеми!

К сожалению, не удалось установить ни автора, ни адресата. Местами текст совершенно невозможно было прочитать, так что пришлось додумывать самому. Но даже несмотря на потери, письмо всё ещё достойно Вашего внимания.

>Приятного чтения!


Для удобства разбил письмо на озаглавленные части, а свои комментарии оставил в \[`таких скобочках`\].

# Содержание


# Кредо

Приветствую тебя, дорогой друг!

Приятно было получить твоё письмо и узнать, что у вас… \[`Фрагмент утрачен`\]

В письме ты интересуешься кредо, чем оно способно помочь в достижении наших целей. Я расскажу тебе всё, что знаю сам.

> **Ничто не истинно, всё дозволено.**

Это может показаться циничной доктриной. Но *кредо* ## всего лишь отражение природных вещей. Тезис «Ничто не истинно» подразумевает, что основы, на которых держится современная разработка, зыбки, и мы сами должны строить свои программы. Говоря «Всё дозволено», мы подразумеваем, что сами решаем, что нам делать, и несём ответственность за последствия, какими бы они ни были.

Кредо – это то что необходимо держать в голове и вспоминать, когда необходимо принимать какое-либо решение. В былые времена во время обряда посвящения в программисты произносилась такая формула:
>— Когда остальные слепо следуют за популярными парадигмами, помни…  
— Ничто не истинно…  
— Когда остальные ограничены набором паттернов и «лучших практик», помни…  
— Всё дозволено…

В каждый момент мы полагаемся только на собственное чутье и то, что нам известно в данный момент. Завтра ты можешь внезапно осознать, что ошибся вчера, но это нормально! Такое открытие обязательно пригодится тебе в будущем. Принимая неудачные решения бессмысленно оправдываться чужим опытом, авторитетными мнениями, или просто привычкой. Ты несёшь персональную ответственность за все сделанные выборы и должен уметь обосновывать их каждому, а прежде всего, самому себе.

## Ничто не истинно

В нашем цеху мы занимается автоматизацией различных процессов, что даёт людям возможность свободнее распоряжаться своим временем. Наше с тобой призвание – <u>нести людям свободу</u>.

Но нужно помнить, что сама наша работа отнимает время у всех, кто к ней причастен. Значит и здесь нам нужно обеспечивать максимальную свободу как товарищам по цеху, так и самим себе. В частности, не стоит вводить <u>необоснованные</u> ограничения на написание программного кода.

Одним и примеров таких ограничений можно считать <u>паттерны программирования</u>. Среди них, конечно, встречаются полезные примеры, с которыми стоит познакомится каждом неофиту, но вот их навязывание, постоянное упоминание в книгах, публичных обсуждениях, приводит к тому, что в общественном сознании закрепляется ошибочное мнение, будто бы знание паттернов необходимо для качественного программирования! Будь осторожен – это всё происки \[`Abstergo? Ubisoft? Невозможно разобрать`\].

На самом деле частые мысли о паттернах приводит к формированию <u>шаблонного мышления</u>, развитию эффекта «туннельного зрения». Вместо прямого решения поставленной задачи, программист будет стараться натянуть её на полюбившийся ему паттерн. Это явление может показаться даже забавным, когда сталкиваешься с ним впервые, но такая беда встречается повсеместно! И если у опытных программистов получаются просто многословные и хрупкие решения, то начинающие способны сходу снести «правильными», но неуместными паттернами все заслоны тестирования.

Также в некоторых командах принято жёстко фиксировать правила форматирования кода – как расставлять скобки, отступы, табуляции внутри строки и т.п. Или хуже, настраивают в среде разработке механизмы автоматического форматирования. Оправдывается это зачастую тем, что строгие правила призваны сэкономить команде время на споры о «красоте кода», предотвратить возможные конфликты. Но так ли это ценно? Ведь, как известно, в споре рождается истина, а с «конфликтностью» стоит бороться путём повышения культуры общения! Встречал и такое, что опытные программисты <u>теряют способность воспринимать чужой код</u>, не укладывающийся в привычный формат.

То же самое касается и утверждения какого-либо конкретного стиля кодирования, что особенно критично для языка программирования Scala, допускающего множество разных стилей. Подобные ограничения не только приводят к невыразительному коду, что само по себе косвенно снижает качество программы, но, что гораздо хуже, <u>ограничивают развитие навыков</u> программирования.

Однако, не все «истины» навязываются извне. Нередко случается, что программист сам ограничивает себя выработанными привычками. И это не всегда плохо – полезные привычки бывают действительно… полезны! Вот только эту самую <u>«полезность» стоит регулярно перепроверять</u>, не потерялась ли она в связи с обретением новых знаний и навыков. А такая привычка, к сожалению, встречается не у каждого программиста.

Возможно ты уже слышал про «принцип наименьшего удивления». Обычно имеется ввиду прежде всего «неприятное» удивление, вызывающее вопросы типа «а зачем тут это вообще?». Но название принципа само по себе просто ужасно! Оно намекает, что удивление – это что-то плохое! Как раз именно из этого пытаются вывести ценность знаний о паттернах, строгих правилах форматирования кода и т.п… 

Удивление – это позитивное понятие, это когда ты открываешь для себя что-то новое и хорошее. Когда же человек теряет способность удивляться, значит он стареет душой. Что же до программирования, то не нужно ставить себе целью удивить читателя, не и <u>не нужно боятся чем-то удивить</u>. Качество кода вообще никак не связано с чьим-то «удивлением».

Перечисленные мною ограничения не оставляют места творческой составляющей, отнимают необходимость самостоятельно видеть, оценивать и выбирать лучше решения. Лишенный свободы выбора человек деградирует, теряет себя. Мы не должны этого допускать.

## Всё дозволено

Если ничто не истинно, чем же тогда руководствоваться в принятии решений? Конечно же, в любом случае нужно выполнить техническое задание, удовлетворить всем функциональным и нефункциональным требованиям. Поэтому я расскажу только об оформлении этих решений – о стиле, формате и прочих мелочах.

Программируя, необходимо по-максимуму использовать все знания имеющиеся на данный момент. Но нужно пропускать эти знания через себя, каждый раз анализировать, на сколько они применимы для решения текущей задачи. Возможно уже <u>завтра</u> (после ревью, или здорового сна) ты убедишься, что можно было бы сделать лучше, но <u>сейчас</u> – это не важно.

Объективные критерии качества кода определяет многовековой опыт человечества. Но эти критерии не высечены на каменных скрижалях – они ежедневно меняются, подстраиваясь под всё новые знания. Причём в каждый момент времени сосуществуют несколько взаимоисключающих подходов. И всё же среди них можно найти общие черты.

Тексты наших программ имеют двоёное назначение – их должны понимать как компьютер, так и люди. Значит мы должны, используя возможности языка программирования, <u>создать свой язык</u> так, чтобы описанные на нём модели данных и логика работы с ними были наиболее понятны всем людям, кто будет в дальнейшем работать с этим кодом, в том числе и самому себе. Код удовлетворяющий такому требованию иногда называют «cамодокументирующимся». 

Чтобы писать понятный код, нужно \[`всего лишь`\] <u>уметь выражать свои мысли</u>. Как говорил мой учитель,
>Если ты не можешь что-то объяснить другому человеку, значит ты просто это не понимаешь.

В достижении понятности кода нам помогает многовековой <u>литературный опыт</u> человечества.

Кроме того, нужно учесть, что наш код будет жить и развиваться, и нам, помимо прочего, необходимо упростить и обезопасить внесение любых изменений. Это очень важный аспект, специфичный именно для программирования. Но здесь также можно нащупать более или менее объективные критерии. А поможет нам в написании устойчивого к изменениям кода ~~тестирование~~ \[`кажется, автор письма сейчас не об этом`\] компилятор и/или инструменты подсветки синтаксиса, проверяющие код на соответствие заявленным типам.


# Литературный стиль


## Выразительные определения

Прежде всего, программистам полезно научиться точно формулировать понятия предметной области, которые он использует в своих алгоритмах. Идентификаторы типов, сущностей, отношений должны легко читаться и однозначно указывать на свою семантику. Недопустимо предлагать читателям текст, составленный из безликих слов вида `Item`, `do`, или вообще из бессмысленных наборов букв – `i`, `foo`, и т.п…

Так уж повелось, что термины мы формируем из слов \[`какого-то «мёртвого языка»; латынь?`\], разделяяИхЗаглавнымиБуквами. Поэтому полезно хоть немного знать лексику и грамматику этого языка, чтобы не написать `styleForm` вместо `formStyle`, или `forSeal` вместо `forSale`. Ну и всегда можно воспользоваться услугами толмачей.

К идентификаторам для удобства можно дописывать необязательные окончания. Например, если в переменной храниться физическая величина, то хорошо бы подчеркнуть это в имени переменной. В итоге переменная для хранения количества секунд паузы между повторениями может быть объявлена так: `val repeatingDelaySecOpt: Option[Int]`.

Не всегда удаётся выразить смысл сущности в коротком идентификаторе, но это не страшно. Всё равно гораздо лучше читать какой-нибудь `selectedElephantsForAlpinCampaign`, нежели «ленивое» `yoprst`.

Для программ на нашем языке Scala характерно ещё одно очень логичное соглашение об именовании – идентификаторы из вселенной значений принято начинать с маленькой буквы, тогда как во вселенной типов всё начинается с заглавной: `value: Type`. Впрочем, из этого правила также есть исключения, например, объекты-компаньоны типов, которые суть значения, именуются в точности также, как и их типы, с заглавной буквы.


## Секреты скорочтения

В современных инструментах редактирования и просмотра кода длина строк практически не ограничена. Всю программу можно написать хоть в одну строчку. Очевидно, что навигация по такому коду с помощью горизонтальной прокрутки экрана будет весьма утомительной. Обычно длину строк рекомендуют ограничивать восьмьюдесятью символами, потому что считается, что такие строки будут видны целиком на большинстве экранов, следовательно, при работе с кодом горизонтальная прокрутка не потребуется. Рекомендация полезная, но (ничто не истинно, всё дозволено) из любых правил бывают исключения, и жёсткое ограничение длины строки периодически часто будет приводить наоборот к некрасивому коду.

Впрочем, о длине строки есть и другие соображения. Во всём мире при верстке газет и журналов текст размещается в колонках, строки которых обычно не длиннее сорока символов. Уже давно было замечено, что такие строку читатель способен воспринимать <u>целиком</u>, а не как последовательность отдельных символов, или даже слов. В этом заключается секрет скорочтения –  взгляд ходит не слева на право, а практически только <u>сверху вниз</u> от строчки к строчке.

Эту идею очень полезно иметь ввиду при написании программного кода. «Вертикальное чтение» могут облегчить такие факторы:
- короткие строки – жёстких ограничений нет, всегда нужно полагаться на свой глазомер;
- текст выровнен по левому краю;
- простой синтаксис в каждой строке;
- каждая строка по возможности имеет собственный законченный смысл;
- смыслы подряд идущих строк достаточно однородны, чтобы легко читалась суть всей последовательности.

И, наоборот, чтению мешают:
- длинные строки;
- навязываемые различной автоматизацией отступы, как, например, для списка аргументов методов в Scala,
- отступы для вложенных конструкций – «ёлочки» (лежащей на боку);
- множество знаков препинания, сложные синтаксические конструкции;
- даже короткие строки могут быть перенасыщены смыслом;
- «бессмысленные» строки, например, содержащие только скобки, или аргументы $\lambda$-выражений;
- частая смена смыслов, контекстов разных строчек, когда рвется нить повествования.

Опять же, для любых правил существуют исключения. Иногда (реже чем кажется!) действительно бывает полезно отвлечь внимание читателя строкой с отступом, или отдельной скобкой. В то же время, события для журналирования, или сообщения об ошибках могут не укладываться по длине ни в какие границы. Но такие строки мало кому интересны, и насильственно разрывать их на несколько строк, только чтобы уложиться в жёсткие рамки какого-то формата – это издевательство над большинством читателей!


## Простые предложения

В классических художественных произведениях можно встретить громоздкие предложения, которые даже не всегда умещаются на одной странице. Не всякий читатель удержит в голове всё хитросплетение вложенных сложноподчинённых предложений и поймёт основную мысль, которую хотел передать автор. Это достаточно стандартный художественный приём, применяемый совершенно осознанно, и его использование совершенно уместно в некоторых художественных произведениях.

Но навряд ли кто-то найдёт оправдание этого приёма в продуктовой разработке. Наша задача состоит не в том, чтобы запутать читателя, но, наоборот, как можно короче и понятнее передать ему суть алгоритма. Тут нужны короткие, но ёмкие фразы из всего нескольких терминов. Сами же эти термины раскрываются уже в других «предложениях». Нужно стремиться избегать как перечисления большого количества операций, так и избыточной вложенности, которая обычно выглядит как «ёлочка».

Один из самых лучших способов достижения простоты является <u>декомпозиция</u>. Достаточно разбить сложный алгоритм на небольшие предложения, имеющие самостоятельный смысл, назначить им подходящие по смыслу идентификаторы, и тогда исходная программа представляется в виде простой комбинации вызовов всего нескольких подпрограмм! Конечно, такой приём требует некоторых усилий, но ведь это и есть наша работа – упрощать жизнь всем, кому достанутся результаты наших трудов.

А иногда встречается код, в котором вложенность удаётся устранить даже не прибегая к декомпозиции. Типичный пример – выполнение некоторых действий, только в случае, если выполняется некоторое условие. Частенько встречаются функции с телом вида
```scala
if (условие) {
  `Большое,
  очень большое
  описание
  счастливого пути`
} else
  `однострочный несчастливый вариант`
```
В этом случае вложенность совершенно не обоснована. Её можно устранить, применив технику <u>раннего выхода</u>:
```scala
if (!условие)
  return `однострочный несчастливый вариант`

`Большое,
очень большое
описание
счастливого пути`
```

В последнем фрагменте кода показан пример разбиения текста на <u>абзацы</u> – последовательности предложений с законченным смыслом отделяются друг от друга пустой строкой (изредка даже несколькими).

Также существует практика, когда в теле функции описываются <u>вложенные функции</u>. Инкапсуляция зависимостей в месте их использования обеспечивает «сильную связность» целостного фрагмента кода, делает его более «модульным». Например, при переносе большой функции в другое место будет меньше шансов что-то упустить – такое решение защищает от ошибок рефакторинга. Но вот читать такой код значительно сложнее – основная суть метода теряется где-то за описаниями вложенных функций. А модульность лучше получать, например, размещая сильно связанный код в отдельных файлах.

Конечно же, вложенные функции не всегда бывают неудобными. Например, если целевая и вложенная в неё функции достаточно маленькие, то основная суть скорее наоборот будет выделяться яснее.


## Избегаем повторов

Не могу припомнить книг, в которых мне встретились <u>повторяющиеся фрагменты текста</u>. Читатель, встречая <u>повторяющиеся фрагменты текста</u> задастся вопросами: «Зачем я потратил время на то, что уже прочёл ранее? Чего добивался автор?». Издательства такие сочинения стараются не тиражировать.

А вот в программном коде <u>повторяющиеся фрагменты текста</u>, к сожалению, часто проходят заслоны ревью. Причина их появления в том, что бездумное копирование кода немного проще, чем переиспользование, или декомпозиция (например, вынос этого фрагмента в отдельный метод). Да и распознать такое мошенничество не так-то просто. Ведь в отличие от книг, текст программы, разбитый на блоки (методы, классы и т.п.), не подразумевает, что его будут читать «подряд», наталкиваясь на <u>повторяющиеся фрагменты текста</u>. Наоборот, расследуя сбои, или внося правки зачастую сложно заметить такие повторы.

Как раз в этом и прячется наибольшая опасность – ты может обмануться, посчитав важным лишь один фрагмент кода, но не заметив его копии. И это особенно важно, если требуется поправить данную логику, что может привести к одновременному существованию разных её версий, дающих непредсказуемое поведение в зависимости от контекста обращения к ней. Дублирование кода принесло слишком много боли человечеству… Но даже если ты потратишь время на поиски всех копии, придётся либо вносить правки в каждой, либо (правильный выбор!) самому устранить дублирование, с которым почему-то не справился предыдущий автор.

Устраняется дублирование кода знакомым способом – вводится новый идентификатор, за которым скрывается <u>повторяющийся фрагмент кода</u>, а все копии заменяются на обращение к этому идентификатору.

>Но получается, что теперь сам идентификатор постоянно повторяется. Можно ли избежать и этого? Один из способов защиты от такого дублирования – **линейные типы**. Идентификатор значения такого типа может встретиться в тексте программы лишь дважды – в момент определения (присвоения) и в момент <u>единственного</u> использования. Линейные типы могут принести много пользы, но работа с ними требует определённых навыков, ещё несвойственных современной культуре программирования. Да и реализованы они пока лишь в нескольких не самых популярных языках программирования.

И всё же, иногда повторение кода может быть оправдано. Например, это могут быть части совершенно независимой логики, и лишь на данном этапе эти части случайно оказались одинаковыми, но известно, что в дальнейшем их пути развития разойдутся, они перестанут быть похожими. Такие рассуждения применимы не только к логике, но и моделям данных – описание интерфейсов разных приложений может частично совпадать, но нет причин устранять это дублирование.

Помимо ситуаций полного дублирования кода, может встречаться также множество фрагментов кода, организованных по определённому шаблону. Обычно такое встречается при обработке громоздких структур данных в пределах одного метода, поэтому сразу бросается в глаза при чтении. Шаблонный код чреват теми же проблемами, что и повторяющийся, поэтому когда сталкиваешься с таким кодом можно попробовать следующее:
- поискать возможность устранить повторяемость;
- собрать шаблонный код в одном месте, строчка за строчкой;
- по возможности, отформатировать шаблонный код, расставив пробелы, чтобы получилось некое подобие таблицы.

Вот пример табулированного шаблонного кода:
```scala
ifaceName             = ifname,
area                  = area,
authentication        = fields("authentication")     .headOption.flatten,
simpleKey             = fields("authentication-key") .headOption.flatten,
helloIntervalSec      = fields("hello-interval")     .headOption.flatten.flatMap(_.toIntOption),
deadIntervalSec       = fields("dead-interval")      .headOption.flatten.flatMap(_.toIntOption),
retransmitIntervalSec = fields("retransmit-interval").headOption.flatten.flatMap(_.toIntOption),
cost                  = fields("cost")               .headOption.flatten.flatMap(_.toIntOption),
priority              = fields("priority")           .headOption.flatten.flatMap(_.toIntOption),
passiveAddress        = fields("passive")            .headOption.pipe(ThreeState.fromOptOpt),
md5Keys               = fields("message-digest-key") .flatten.pipe(parseMd5Keys),
```

Выгода от такого форматирования в том, что элементы шаблона, будучи единожды прочитаны, больше не отнимают внимания читателя, а вот любое нарушение шаблонности сразу бросается в глаза. Табулирование даёт некую предсказуемость при чтении шаблонного кода, и в этом смысле его можно сравнить с рифмой в поэзии.


## Ничего лишнего



### знаки препинания и императивные операторы – это усложнение!

В тексте сложность привносят
- разнообразие синтаксических конструкций
- знаки препинания (точки, скобки и т.п.)



### Инфиксная форма – “подлежащее-сказуемое-дополнение”

### Знание интсрументария


## Вызов функции – самое простое

В наше время \[`не то, что сейчас!`\] всё ещё в моде <u>императивный</u> стиль программирования, в котором пишутся <u>инструкции для исполнителя</u>, последовательность приказов (императивов), таких как «пойди сюда», «возьми то», «отправь туда», «получи оттуда», «положи тут», «вернись обратно» и т.п. Так сложилось испокон веков, когда в ранних языках программирования были только такие команды, ориентированные на общепринятую архитектуру вычислительной машины. Языки развивались, но большинство из них по прежнему предлагали в основном императивные конструкции.

В то же время ещё до появления ЭВМ программисты знали, что чтобы написать хорошую программу достаточно всего двух основных языковых конструкций – <u>объявление функции и её применение</u> к значению \[`см. λ-исчисление`\]. Но мало того, что синтаксис такого языка максимально прост, оказывается, что и корректность алгоритмов на нём удобно проверять ещё до их исполнения автоматическими средствами!

Функции сами могут выступать в роли значений \[`функции, как объекты первого класса`\] – их можно передавать как аргументы в другие функции, и получать их в результате вычислений. Ввиду ориентированности на функции, такой подход называют <u>функциональным программированием</u>.

Программа строится не как последовательность приказов недотёпе-компьютеру, а как декларация ожидаемого результата: «нужен результат выполнения `функции1`, которая принимает на вход результат `функции2`, получающей на вход сумму первоначальных аргументов, передаваемых нашей программе». Поэтому функциональное программирование часто называют <u>декларативным</u>. Оно подразумевает, что компьютер сам должен понять, что от него ожидают, и составить последовательность низкоуровневых команд, приводящих к требуемому результату.

В этом смысле любые императивные управляющие конструкции, обусловленные прежде всего исторически сложившейся привязкой к архитектуре ЭВМ,


## О священной войне
### for/цепочки/комбинаторы
### Cтрелки
### Операторы/инфиксная форма
### Контексты, вывод типов и логическое программирование
### Вычислительная эффективность, отказ от преждевременной оптимизации



## Эклектика
## Рефакторинг

Как говорил один наш великий предшественник
> Всё должно быть изложено настолько просто, на сколько это возможно, но не проще.

Со сложным кодом тяжело работать, он может ввести в заблуждение, что в итоге приведёт к неочевидным ошибкам при попытке внести туда правки. Поэтому найдя и реализовав решение поставленной задачи всегда полезно посмотреть на его составляющие и подумать, «нужно ли мне это?», «нет ли тут чего-то лишнего?», «можно ли сделать проще?».


Основная причина – лень. Спешка. 
Если не можешь выразит словами, значит ты этого не понимаешь.




# PS

Нет абсолютных истин. В том числе это послание – лишь личное мнение, синтезированное на основе ограниченного опыта, как чужого, так и собственного. Возможно сам оспорю всё это уже завтра.

Нельзя навязать стремление к свободе. Общайся, убеждай, но всегда будь готовым к тому, что чужая истина может показаться тебе «более истинной».

Слова, вообще, лгут.


Когда тебя убеждают, что одна парадигма программирования лучше другой, помни:
**Ничто не истинно!**

Когда тебе не рекомендуют пользоваться шаблонными решениями, помни
**Всё дозволено!**

~~Да направит тебя Отец Понимания!~~
~~Да прибудет с тобой сила!~~
\[`Точно не уверен, какое там напутствие`\]
![[8ball.png|Не привыкай доверять готовым ответам. Окончательное решение принимать тебе.]]
