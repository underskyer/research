![[Эцио.png|600]]

Однажды меня попросили подготовить рекомендации по программированию на Scala для сотрудников нашей компании Solar. В поисках лучших рецептов приходилось заглядывать в самые пыльные уголки Интернета, и в одном из них, в старом проржавелом сундуке я заметил старинный конверт. Просто из любопытства решил заглянуть туда, благо конверт был уже вскрыт. Ветхие страницы, поблекшие чернила, но содержание настолько меня заворожило, что я просто не мог не поделиться со всеми!

К сожалению, не удалось установить ни автора, ни адресата. Местами текст совершенно невозможно было прочитать, так что пришлось додумывать самому. Но даже несмотря на потери, письмо всё ещё достойно Вашего внимания.

>Приятного чтения!


Для удобства разбил письмо на озаглавленные части, а свои комментарии оставил в \[`таких скобочках`\].

# Содержание


# Кредо

Приветствую тебя, дорогой друг!

Приятно было получить твоё письмо и узнать, что у вас… \[`Фрагмент утрачен`\]

В письме ты интересуешься кредо, чем оно способно помочь в достижении наших целей. Я расскажу тебе всё, что знаю сам.

> **Ничто не истинно, всё дозволено.**

Это может показаться циничной доктриной. Но *кредо* ## всего лишь отражение природных вещей. Тезис «Ничто не истинно» подразумевает, что основы, на которых держится современная разработка, зыбки, и мы сами должны строить свои программы. Говоря «Всё дозволено», мы подразумеваем, что сами решаем, что нам делать, и несём ответственность за последствия, какими бы они ни были.

Кредо – это то что необходимо держать в голове и вспоминать, когда необходимо принимать какое-либо решение. В былые времена во время обряда посвящения в программисты произносилась такая формула:
>— Когда остальные слепо следуют за популярными парадигмами, помни…  
— Ничто не истинно…  
— Когда остальные ограничены набором паттернов и «лучших практик», помни…  
— Всё дозволено…

В каждый момент мы полагаемся только на собственное чутье и то, что нам известно в данный момент. Завтра ты можешь внезапно осознать, что ошибся вчера, но это нормально! Такое открытие обязательно пригодится тебе в будущем. Принимая неудачные решения бессмысленно оправдываться чужим опытом, авторитетными мнениями, или просто привычкой. Ты несёшь персональную ответственность за все сделанные выборы и должен уметь обосновывать их каждому, а прежде всего, самому себе.

## Ничто не истинно

В нашем цеху мы занимается автоматизацией различных процессов, что даёт людям возможность свободнее распоряжаться своим временем. Наше с тобой призвание – <u>нести людям свободу</u>.

Но нужно помнить, что сама наша работа отнимает время у всех, кто к ней причастен. Значит и здесь нам нужно обеспечивать максимальную свободу как товарищам по цеху, так и самим себе. В частности, не стоит вводить <u>необоснованные</u> ограничения на написание программного кода.

Одним и примеров таких ограничений можно считать <u>паттерны программирования</u>. Среди них, конечно, встречаются полезные примеры, с которыми стоит познакомится каждом неофиту, но вот их навязывание, постоянное упоминание в книгах, публичных обсуждениях, приводит к тому, что в общественном сознании закрепляется ошибочное мнение, будто бы знание паттернов необходимо для качественного программирования! Будь осторожен – это всё происки \[`Abstergo? Ubisoft? Невозможно разобрать`\].

На самом деле частые мысли о паттернах приводит к формированию <u>шаблонного мышления</u>, развитию эффекта «туннельного зрения». Вместо прямого решения поставленной задачи, программист будет стараться натянуть её на полюбившийся ему паттерн. Это явление может показаться даже забавным, когда сталкиваешься с ним впервые, но такая беда встречается повсеместно! И если у опытных программистов получаются просто многословные и хрупкие решения, то начинающие способны сходу снести «правильными», но неуместными паттернами все заслоны тестирования.

Также в некоторых командах принято жёстко фиксировать правила форматирования кода – как расставлять скобки, отступы, табуляции внутри строки и т.п. Или хуже, настраивают в среде разработке механизмы автоматического форматирования. Оправдывается это зачастую тем, что строгие правила призваны сэкономить команде время на споры о «красоте кода», предотвратить возможные конфликты. Но так ли это ценно? Ведь, как известно, в споре рождается истина, а с «конфликтностью» стоит бороться путём повышения культуры общения! Встречал и такое, что опытные программисты <u>теряют способность воспринимать чужой код</u>, не укладывающийся в привычный формат.

То же самое касается и утверждения какого-либо конкретного стиля кодирования, что особенно критично для языка программирования Scala, допускающего множество разных стилей. Подобные ограничения не только приводят к невыразительному коду, что само по себе косвенно снижает качество программы, но, что гораздо хуже, <u>ограничивают развитие навыков</u> программирования.

Однако, не все «истины» навязываются извне. Нередко случается, что программист сам ограничивает себя выработанными привычками. И это не всегда плохо – полезные привычки бывают действительно… полезны! Вот только эту самую <u>«полезность» стоит регулярно перепроверять</u>, не потерялась ли она в связи с обретением новых знаний и навыков. А такая привычка, к сожалению, встречается не у каждого программиста.

Все подобные ограничения не оставляют места творческой составляющей, отнимают необходимость самостоятельно видеть, оценивать и выбирать лучше решения. Лишенный свободы выбора человек деградирует, теряет себя.

## Всё дозволено

Если ничто не истинно, чем же тогда руководствоваться в принятии решений? Конечно же, в любом случае нужно выполнить техническое задание, удовлетворить всем функциональным и нефункциональным требованиям. Поэтому я расскажу только об оформлении этих решений – о стиле, формате и прочих мелочах.

Программируя, необходимо по-максимуму использовать все знания имеющиеся на данный момент. Но нужно пропускать эти знания через себя, каждый раз анализировать, на сколько они применимы для решения текущей задачи. Возможно уже <u>завтра</u> (после ревью, или здорового сна) ты убедишься, что можно было бы сделать лучше, но <u>сейчас</u> – это не важно.

Объективные критерии качества кода определяет многовековой опыт человечества. Но эти критерии не высечены на каменных скрижалях – они ежедневно меняются, подстраиваясь под всё новые знания. Причём в каждый момент времени сосуществуют несколько взаимоисключающих подходов. И всё же среди них можно найти общие черты.

# Литературный стиль

Найдя решение задачи мы оформляем его в таком виде, чтобы,
- во-первых, как можно понятнее донести до читателя суть описываемой логики,
- во-вторых, упростить и обезопасить внесение любых изменений. 

Чтобы удовлетворить первому пункту нужно (всего лишь) <u>уметь выражать свои мысли</u>. Определяя свои термины, моделирующие конкретную предметную область, мы комбинируем их с помощью синтаксических конструкций языка программирования. В результате получается <u>текст</u>, одной из основных целей которого является простоя и точная передача знаний о логике программы как другим программистам, так и самому себе. И тут могут выручить проверенные веками принципы написания <u>грамотных литературных сочинений</u>.

### Принцип наименьшего удивления

Удивляться - хорошо. Если теряешь способность удивляться - стареешь. Но не надо ставить целью удивить читателя.

### Самодокументирующийся код


## Выразительные идентификаторы

Прежде всего, программистам полезно научиться точно формулировать понятия предметной области, которые он использует в своих алгоритмах. Идентификаторы типов, сущностей, отношений должны легко читаться и однозначно указывать на свою семантику. Недопустимо предлагать читателям текст, составленный из безликих слов вида `Item`, `receive`, или вообще из бессмысленных наборов букв – `i`, `fo`, и т.п…

Так уж повелось, что термины мы формируем из слов \[`какого-то «мёртвого языка»; латынь?`\], разделяяИхЗаглавнымиБуквами. Поэтому полезно хоть немного знать лексику и грамматику этого языка, чтобы не написать `styleForm` вместо `formStyle`, или `forSeal` вместо `forSale`. Ну и всегда можно воспользоваться услугами толмачей.

Иногда не удаётся выразить смысл сущности в коротком идентификаторе. Это не страшно. Всё равно гораздо лучше читать какой-нибудь `selectedElephantsForAlpinCampaign`, нежели «ленивое» `yoprst`.

## Секреты скорочтения

В современных инструментах редактирования и просмотра кода длина строк практически не ограничена. Всю программу можно написать хоть в одну строчку. Очевидно, что навигация по такому коду с помощью горизонтальной прокрутки экрана будет весьма утомительной. Обычно длину строк рекомендуют ограничивать восьмьюдесятью символами, потому что считается, что такие строки будут видны целиком на большинстве экранов, следовательно, при работе с кодом горизонтальная прокрутка не потребуется. Рекомендация полезная, но (ничто не истинно, всё дозволено) из любых правил бывают исключения, и жёсткое ограничение длины строки периодически часто будет приводить наоборот к некрасивому коду.

Впрочем, о длине строки есть и другие соображения. Во всём мире при верстке газет и журналов текст размещается в колонках, строки которых обычно не длиннее сорока символов. Уже давно было замечено, что такие строку читатель способен воспринимать <u>целиком</u>, а не как последовательность отдельных символов, или даже слов. В этом заключается секрет скорочтения –  взгляд ходит не слева на право, а практически только <u>сверху вниз</u> от строчки к строчке.

Эту идею очень полезно иметь ввиду при написании программного кода. «Вертикальное чтение» могут облегчить такие факторы:
- короткие строки – жёстких ограничений нет, всегда нужно полагаться на свой глазомер;
- текст выровнен по левому краю;
- простая грамматика в каждой строке;
- каждая строка по возможности имеет собственный законченный смысл;
- смыслы подряд идущих строк достаточно однородны, чтобы легко читалась суть всей последовательности.

И, наоборот, чтению мешают:
- длинные строки;
- навязываемые различной автоматизацией отступы, как, например, для списка аргументов методов в Scala,
- отступы для вложенных конструкций – «ёлочки» (лежащей на боку);
- множество знаков препинания, сложные синтаксические конструкции;
- даже короткие строки могут быть перенасыщены смыслом;
- «бессмысленные» строки, например, содержащие только скобки, или аргументы $\lambda$-выражений;
- частая смена смыслов, контекстов разных строчек, когда рвется нить повествования.

Опять же, для любых правил существуют исключения. Иногда (реже чем кажется!) действительно бывает полезно отвлечь внимание читателя строкой с отступом, или отдельной скобкой. В то же время, события для журналирования, или сообщения об ошибках могут не укладываться по длине ни в какие границы. Но такие строки мало кому интересны, и насильственно разрывать их на несколько строк, только чтобы уложиться в жёсткие рамки какого-то формата – это издевательство над большинством читателей!


## Сложные  предложения

В классических художественных произведениях можно встретить громоздкие предложения, которые даже не всегда умещаются на одной странице. Не всякий читатель удержит в голове всё хитросплетение вложенных сложноподчинённых предложений и поймёт основную мысль, которую хотел передать автор. Это достаточно стандартный художественный приём, применяемый совершенно осознанно, и его использование совершенно уместно в некоторых художественных произведениях.

Но навряд ли кто-то найдёт оправдание этого приёма в продуктовой разработке. Наша задача состоит не в том, чтобы запутать читателя, но, наоборот, как можно короче и понятнее передать ему суть алгоритма. Тут нужны короткие, но ёмкие фразы из всего нескольких терминов. Сами же эти термины раскрываются уже в других «предложениях». Нужно стремиться избегать как перечисления большого количества операций, так и избыточной вложенности, которая обычно выглядит как «ёлочка».

Один из самых лучших способов достижения простоты является <u>декомпозиция</u>. Достаточно разбить сложный алгоритм на небольшие предложения, имеющие самостоятельный смысл, назначить им подходящие по смыслу идентификаторы, и тогда исходная программа представляется в виде простой комбинации вызовов всего нескольких подпрограмм! Конечно, такой приём требует некоторых усилий, но ведь это и есть наша работа – упрощать жизнь всем, кому достанутся результаты наших трудов.

А иногда встречается код, в котором вложенность удаётся устранить даже не прибегая к декомпозиции. Типичный пример – выполнение некоторых действий, только в случае, если выполняется некоторое условие. Частенько встречаются функции с телом вида
```scala
if (условие) {
  `Большое,
  очень большое
  описание
  счастливого пути`
} else
  `однострочный несчастливый вариант`
```
В этом случае вложенность совершенно не обоснована. Её можно устранить, применив технику <u>раннего выхода</u>:
```scala
if (!условие)
  return `однострочный несчастливый вариант`

`Большое,
очень большое
описание
счастливого пути`
```

В последнем фрагменте кода показан пример разбиения текста на <u>абзацы</u> – последовательности предложений с законченным смыслом отделяются друг от друга пустой строкой (изредка даже несколькими).

## Одно и то же

Не могу припомнить книг, в которых мне встретились <u>повторяющиеся фрагменты текста</u>. Читатель, встречая <u>повторяющиеся фрагменты текста</u> задастся вопросами: «Зачем я потратил время на то, что уже прочёл ранее? Чего добивался автор?». Издательства такие сочинения стараются не тиражировать.

А вот в программном коде <u>повторяющиеся фрагменты текста</u>, к сожалению, часто проходят заслоны ревью. Причина их появления в том, что бездумное копирование кода немного проще, чем переиспользование, или декомпозиция (например, вынос этого фрагмента в отдельный метод). Да и распознать такое мошенничество не так-то просто. Ведь в отличие от книг, текст программы, разбитый на блоки (методы, классы и т.п.), не подразумевает, что его будут читать «подряд», наталкиваясь на <u>повторяющиеся фрагменты текста</u>. Наоборот, расследуя сбои, или внося правки зачастую сложно заметить такие повторы.

Как раз в этом и прячется наибольшая опасность – ты может обмануться, посчитав важным лишь один фрагмент кода, но не заметив его копии. И это особенно важно, если требуется поправить данную логику, что может привести к одновременному существованию разных её версий, дающих непредсказуемое поведение в зависимости от контекста обращения к ней. Дублирование кода принесло слишком много боли человечеству… Но даже если ты потратишь время на поиски всех копии, придётся либо вносить правки в каждой, либо (правильный выбор!) самому устранить дублирование, с которым почему-то не справился предыдущий автор.

Устраняется дублирование кода знакомым способом – вводится новый идентификатор, за которым скрывается <u>повторяющийся фрагмент кода</u>, а все копии заменяются на обращение к этому идентификатору.

>Но получается, что теперь сам идентификатор постоянно повторяется. Можно ли избежать и этого? Один из способов защиты от такого дублирования – **линейные типы**. Идентификатор значения такого типа может встретиться в тексте программы лишь дважды – в момент определения (присвоения) и в момент <u>единственного</u> использования. Линейные типы могут принести много пользы, но работа с ними требует определённых навыков, ещё несвойственных современной культуре программирования. Да и реализованы они пока лишь в нескольких не самых популярных языках программирования.

И всё же, иногда повторение кода может быть оправдано. Например, это могут быть части совершенно независимой логики, и лишь на данном этапе эти части случайно оказались одинаковыми, но известно, что в дальнейшем их пути развития разойдутся, они перестанут быть похожими. Такие рассуждения применимы не только к логике, но и моделям данных – описание интерфейсов разных приложений может частично совпадать, но нет причин устранять это дублирование.

Помимо ситуаций полного дублирования кода, может встречаться также множество фрагментов кода, организованных по определённому шаблону. Обычно такое встречается в пределах одного метода, поэтому сразу бросается в глаза при чтении. Шаблонный код чреват теми же проблемами, что повторяющийся, поэтому когда сталкиваешься с таким кодом можно попробовать следующее:
- поискать возможность устранить повторяемость;
- если не получилось, собрать шаблонный код в одном месте, строчка за строчкой;
- по возможности, отформатировать шаблонный код, расставив пробелы, получить подобие таблицы.

```scala
i.passiveAddress match
  case ThreeState.value(addr) => Some("ip ospf passive " + addr)
  case ThreeState.no          => Some("no ip ospf passive")
  case ThreeState.default     => oldPassiveState match
    case ThreeState.value(_)  => Some("no ip ospf passive")
    case ThreeState.no        => Some("ip ospf passive")
    case ThreeState.default   => None
```


### Табулирование шаблонного кода
работа с громоздкими моделями



## Простота грамматики
### знаки препинания и императивные операторы – это усложнение!
### Вызов функции – самое простое
### Инфиксная форма – “подлежащее-сказуемое-дополнение”


## Священная война
### for/цепочки/комбинаторы
### Cтрелки
### Операторы/инфиксная форма
### Контексты, вывод типов и логическое программирование
### Вычислительная эффективность, отказ от преждевременной оптимизации



## Эклектика
## Рефакторинг

Основная причина – лень. Спешка. 
Если не можешь выразит словами, значит ты этого не понимаешь.




# PS

Нет абсолютных истин. В том числе это послание – лишь личное мнение, синтезированное на основе ограниченного опыта, как чужого, так и собственного. Возможно сам оспорю всё это уже завтра.

Нельзя навязать стремление к свободе. Общайся, убеждай, но всегда будь готовым к тому, что чужая истина может показаться тебе «более истинной».

Слова, вообще, лгут.


Когда тебя убеждают, что одна парадигма программирования лучше другой, помни:
**Ничто не истинно!**

Когда тебе не рекомендуют пользоваться шаблонными решениями, помни
**Всё дозволено!**

~~Да направит тебя Отец Понимания!~~
~~Да прибудет с тобой сила!~~
\[`Точно не уверен, какое там напутствие`\]
![[8ball.png|Не привыкай доверять готовым ответам. Окончательное решение принимать тебе.]]
