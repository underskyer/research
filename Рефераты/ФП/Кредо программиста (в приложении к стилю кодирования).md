![[Эцио.png|600]]

Однажды меня попросили подготовить рекомендации по программированию на Scala для сотрудников нашей компании Solar. В поисках лучших рецептов приходилось заглядывать в самые пыльные уголки Интернета, и в одном из них, в старом проржавелом сундуке я заметил старинный конверт. Просто из любопытства решил заглянуть туда, благо конверт был уже вскрыт. Ветхие страницы, поблекшие чернила, но содержание настолько меня заворожило, что я просто не мог не поделиться со всеми!

К сожалению, не удалось установить ни автора, ни адресата. Местами текст совершенно невозможно было прочитать, так что пришлось додумывать самому. Но даже несмотря на потери, письмо всё ещё достойно Вашего внимания.

>Приятного чтения!


Для удобства разбил письмо на озаглавленные части, а свои комментарии оставил в \[таких скобочках\].

# Содержание


# Кредо

Приветствую тебя, дорогой друг!

Приятно было получить твоё письмо и узнать, что у вас… \[Фрагмент утрачен\]

В письме ты интересуешься кредо, чем оно способно помочь в достижении наших целей. Я расскажу тебе всё, что знаю сам.

> **Ничто не истинно, всё дозволено.**

Это может показаться циничной доктриной. Но *кредо* — всего лишь отражение природных вещей. Тезис «Ничто не истинно» подразумевает, что основы, на которых держится современная разработка, зыбки, и мы сами должны строить свои программы. Говоря «Всё дозволено», мы подразумеваем, что сами решаем, что нам делать, и несём ответственность за последствия, какими бы они ни были.

Кредо — это то что необходимо держать в голове и вспоминать, когда необходимо принимать какое-либо решение. В былые времена во время обряда посвящения в программисты произносилась такая формула:
>— Когда остальные слепо следуют за популярными парадигмами, помни…  
— Ничто не истинно…  
— Когда остальные ограничены набором паттернов и «лучших практик», помни…  
— Всё дозволено…

В каждый момент мы полагаемся только на собственное чутье и то, что нам известно в данный момент. Завтра ты можешь внезапно осознать, что ошибся вчера, но это нормально! Такое открытие обязательно пригодится тебе в будущем. Принимая неудачные решения бессмысленно оправдываться чужим опытом, авторитетными мнениями, или просто привычкой. Ты несёшь персональную ответственность за все сделанные выборы и должен уметь обосновывать их каждому, а прежде всего, самому себе.

## Ничто не истинно

В нашем цеху мы занимается автоматизацией различных процессов, что даёт людям возможность свободнее распоряжаться своим временем. Наше с тобой призвание — <u>нести людям свободу</u>.

Но нужно помнить, что сама наша работа отнимает время у всех, кто к ней причастен. Значит и здесь нам нужно обеспечивать максимальную свободу как товарищам по цеху, так и самим себе. В частности, не стоит вводить <u>необоснованные</u> ограничения на написание программного кода.

Одним и примеров таких ограничений можно считать <u>паттерны программирования</u>. Среди них, конечно, встречаются полезные примеры, с которыми стоит познакомится каждом неофиту, но вот их навязывание, постоянное упоминание в книгах, публичных обсуждениях, приводит к тому, что в общественном сознании закрепляется ошибочное мнение, будто бы знание паттернов необходимо для качественного программирования! Будь осторожен — это всё происки \[Abstergo? Ubisoft? Невозможно разобрать\].

На самом деле частые мысли о паттернах приводит к формированию <u>шаблонного мышления</u>, развитию эффекта «туннельного зрения». Вместо прямого решения поставленной задачи, программист будет стараться натянуть её на полюбившийся ему паттерн. Это явление может показаться даже забавным, когда сталкиваешься с ним впервые, но такая беда встречается повсеместно! И если у опытных программистов получаются просто многословные и хрупкие решения, то начинающие способны сходу снести «правильными», но неуместными паттернами все заслоны тестирования.

Также в некоторых командах принято жёстко фиксировать правила форматирования кода — как расставлять скобки, отступы, табуляции внутри строки и т.п. Или хуже, настраивают в среде разработке механизмы автоматического форматирования. Оправдывается это зачастую тем, что строгие правила призваны сэкономить команде время на споры о «красоте кода», предотвратить возможные конфликты. Но так ли это ценно? Ведь, как известно, в споре рождается истина, а с «конфликтностью» стоит бороться путём повышения культуры общения! Встречал и такое, что опытные программисты <u>теряют способность воспринимать чужой код</u>, не укладывающийся в привычный формат.

То же самое касается и утверждения какого-либо конкретного стиля кодирования, что особенно критично для языка программирования Scala, допускающего множество разных стилей. Подобные ограничения не только приводят к невыразительному коду, что само по себе косвенно снижает качество программы, но, что гораздо хуже, <u>ограничивают развитие навыков</u> программирования.

Однако, не все «истины» навязываются извне. Нередко случается, что программист сам ограничивает себя выработанными привычками. И это не всегда плохо — полезные привычки бывают действительно… полезны! Вот только эту самую <u>«полезность» стоит регулярно перепроверять</u>, не потерялась ли она в связи с обретением новых знаний и навыков. А такая привычка, к сожалению, встречается не у каждого программиста.

Возможно ты уже слышал про «принцип наименьшего удивления». Обычно имеется ввиду прежде всего «неприятное» удивление, вызывающее вопросы типа «а зачем тут это вообще?». Но название принципа само по себе просто ужасно! Оно намекает, что удивление — это что-то плохое! Как раз именно из этого пытаются вывести ценность знаний о паттернах, строгих правилах форматирования кода и т.п… 

Удивление — это позитивное понятие, это когда ты открываешь для себя что-то новое и хорошее. Когда же человек теряет способность удивляться, значит он стареет душой. Что же до программирования, то не нужно ставить себе целью удивить читателя, не и <u>не нужно боятся чем-то удивить</u>. Качество кода вообще никак не связано с чьим-то «удивлением».

Перечисленные мною ограничения не оставляют места творческой составляющей, отнимают необходимость самостоятельно видеть, оценивать и выбирать лучше решения. Лишенный свободы выбора человек деградирует, теряет себя. Мы не должны этого допускать.

## Всё дозволено

Если ничто не истинно, чем же тогда руководствоваться в принятии решений? Конечно же, в любом случае нужно выполнить техническое задание, удовлетворить всем функциональным и нефункциональным требованиям. Поэтому я расскажу только об оформлении этих решений — о стиле, формате и прочих мелочах.

Программируя, необходимо по-максимуму использовать все знания имеющиеся на данный момент. Но нужно пропускать эти знания через себя, каждый раз анализировать, на сколько они применимы для решения текущей задачи. Возможно уже <u>завтра</u> (после ревью, или здорового сна) ты убедишься, что можно было бы сделать лучше, но <u>сейчас</u> — это не важно.

Объективные критерии качества кода определяет многовековой опыт человечества. Но эти критерии не высечены на каменных скрижалях — они ежедневно меняются, подстраиваясь под всё новые знания. Причём в каждый момент времени сосуществуют несколько взаимоисключающих подходов. И всё же среди них можно найти общие черты.

Тексты наших программ имеют двоёное назначение — их должны понимать как компьютер, так и люди. Значит мы должны, используя возможности языка программирования, <u>создать свой язык</u> так, чтобы описанные на нём модели данных и логика работы с ними были наиболее понятны всем людям, кто будет в дальнейшем работать с этим кодом, в том числе и самому себе. Код удовлетворяющий такому требованию иногда называют «cамодокументирующимся». 

Кроме того, нужно учесть, что наш код будет жить и развиваться, и нам, помимо прочего, необходимо упростить и обезопасить внесение любых изменений. Это очень важный аспект, специфичный именно для программирования. Но здесь также можно нащупать более или менее объективные критерии. А поможет нам в написании устойчивого к изменениям кода ~~тестирование~~ \[кажется, автор письма сейчас не об этом\] компилятор и/или инструменты подсветки синтаксиса, проверяющие код на соответствие заявленным типам.

### SOLID — устойчивость к правкам
### Вычислительная эффективность, отказ от преждевременной оптимизации



Чтобы писать понятный код, нужно \[всего лишь\] <u>уметь выражать свои мысли</u>. Как говорил мой учитель,
>Если ты не можешь что-то объяснить другому человеку, значит ты просто это не понимаешь.

В достижении понятности кода нам помогает многовековой <u>литературный опыт</u> человечества.


# Литературный стиль

## Выразительные определения

Прежде всего, программистам полезно научиться точно формулировать понятия предметной области, которые он использует в своих алгоритмах. Идентификаторы типов, сущностей, отношений должны легко читаться и однозначно указывать на свою семантику. Недопустимо предлагать читателям текст, составленный из безликих слов вида `Item`, `do`, или вообще из бессмысленных наборов букв — `i`, `foo`, и т.п…

Так уж повелось, что термины мы формируем из слов \[какого-то «мёртвого языка»; латынь?\], разделяяИхЗаглавнымиБуквами. Поэтому полезно хоть немного знать лексику и грамматику этого языка, чтобы не написать `styleForm` вместо `formStyle`, или `forSeal` вместо `forSale`. Ну и всегда можно воспользоваться услугами толмачей.

К идентификаторам для удобства можно дописывать необязательные окончания. Например, если в переменной храниться физическая величина, то хорошо бы подчеркнуть это в имени переменной. В итоге переменная для хранения количества секунд паузы между повторениями может быть объявлена так: `val repeatingDelaySecOpt: Option[Int]`.

Не всегда удаётся выразить смысл сущности в коротком идентификаторе, но это не страшно. Всё равно гораздо лучше читать какой-нибудь `selectedElephantsForAlpinCampaign`, нежели «ленивое» `yoprst`.

Для программ на нашем языке Scala характерно ещё одно очень логичное соглашение об именовании — идентификаторы из вселенной значений принято начинать с маленькой буквы, тогда как во вселенной типов всё начинается с заглавной: `value: Type`. Впрочем, из этого правила также есть исключения, например, объекты-компаньоны типов, которые суть значения, именуются в точности также, как и их типы, с заглавной буквы.


## Секреты скорочтения

В современных инструментах редактирования и просмотра кода длина строк практически не ограничена. Всю программу можно написать хоть в одну строчку. Очевидно, что навигация по такому коду с помощью горизонтальной прокрутки экрана будет весьма утомительной. Обычно длину строк рекомендуют ограничивать восьмьюдесятью символами, потому что считается, что такие строки будут видны целиком на большинстве экранов, следовательно, при работе с кодом горизонтальная прокрутка не потребуется. Рекомендация полезная, но (ничто не истинно, всё дозволено) из любых правил бывают исключения, и жёсткое ограничение длины строки периодически часто будет приводить наоборот к некрасивому коду.

Впрочем, о длине строки есть и другие соображения. Во всём мире при верстке газет и журналов текст размещается в колонках, строки которых обычно не длиннее сорока символов. Уже давно было замечено, что такие строку читатель способен воспринимать <u>целиком</u>, а не как последовательность отдельных символов, или даже слов. В этом заключается секрет скорочтения —  взгляд ходит не слева на право, а практически только <u>сверху вниз</u> от строчки к строчке.

Эту идею очень полезно иметь ввиду при написании программного кода. «Вертикальное чтение» могут облегчить такие факторы:
- короткие строки — жёстких ограничений нет, всегда нужно полагаться на свой глазомер;
- текст выровнен по левому краю;
- простой синтаксис в каждой строке;
- каждая строка по возможности имеет собственный законченный смысл;
- смыслы подряд идущих строк достаточно однородны, чтобы легко читалась суть всей последовательности.

И, наоборот, чтению мешают:
- длинные строки;
- навязываемые различной автоматизацией отступы, как, например, для списка аргументов методов в Scala,
- отступы для вложенных конструкций — «ёлочки» (лежащей на боку);
- множество знаков препинания, сложные синтаксические конструкции;
- даже короткие строки могут быть перенасыщены смыслом;
- «бессмысленные» строки, например, содержащие только скобки, или аргументы $\lambda$-выражений;
- частая смена смыслов, контекстов разных строчек, когда рвется нить повествования.

Опять же, для любых правил существуют исключения. Иногда (реже чем кажется!) действительно бывает полезно отвлечь внимание читателя строкой с отступом, или отдельной скобкой. В то же время, события для журналирования, или сообщения об ошибках могут не укладываться по длине ни в какие границы. Но такие строки мало кому интересны, и насильственно разрывать их на несколько строк, только чтобы уложиться в жёсткие рамки какого-то формата — это издевательство над большинством читателей!


## Простые предложения

В классических художественных произведениях можно встретить громоздкие предложения, которые даже не всегда умещаются на одной странице. Не всякий читатель удержит в голове всё хитросплетение вложенных сложноподчинённых предложений и поймёт основную мысль, которую хотел передать автор. Это достаточно стандартный художественный приём, применяемый осознанно, и его использование совершенно уместно в некоторых художественных произведениях.

Но навряд ли кто-то найдёт оправдание этого приёма в продуктовой разработке. Наша задача состоит не в том, чтобы запутать читателя, но, наоборот, как можно короче и понятнее передать ему суть алгоритма. Тут нужны короткие, но ёмкие фразы из всего нескольких терминов. Сами же эти термины раскрываются уже в других «предложениях». Нужно стремиться избегать как перечисления большого количества операций, так и избыточной вложенности, которая обычно выглядит как «ёлочка».

Один из самых лучших способов достижения простоты является <u>декомпозиция</u>. Достаточно разбить сложный алгоритм на небольшие предложения, имеющие самостоятельный смысл, назначить им подходящие по смыслу идентификаторы, и тогда исходная программа представляется в виде простой комбинации вызовов всего нескольких подпрограмм! Конечно, такой приём требует некоторых усилий, но ведь это и есть наша работа — упрощать жизнь всем, кому достанутся результаты наших трудов.

А иногда встречается код, в котором вложенность удаётся устранить даже не прибегая к декомпозиции. Типичный пример — выполнение некоторых действий, только в случае, если выполняется некоторое условие. Частенько встречаются функции с телом вида
```scala
if (условие) {
  `Большое,
  очень большое
  описание
  счастливого пути`
} else
  `однострочный несчастливый вариант`
```
В этом случае вложенность совершенно не обоснована. Её можно устранить, применив технику <u>раннего выхода</u>:
```scala
if (!условие)
  return `однострочный несчастливый вариант`

`Большое,
очень большое
описание
счастливого пути`
```

В последнем фрагменте кода показан пример разбиения текста на <u>абзацы</u> — последовательности предложений с законченным смыслом отделяются друг от друга пустой строкой (изредка даже несколькими).

Также существует практика, когда в теле функции описываются <u>вложенные функции</u>. Инкапсуляция зависимостей в месте их использования обеспечивает «сильную связность» целостного фрагмента кода, делает его более «модульным». При переносе большой функции в другое место будет меньше шансов что-то упустить — такое решение защищает от ошибок рефакторинга. Но вот читать такой код значительно сложнее, так как основная суть метода теряется где-то за описаниями вложенных функций. А модульность лучше получать, например, сразу размещая сильно связанный код в отдельных файлах.

Конечно же, вложенные функции не всегда бывают неудобными. Например, если целевая и вложенная в неё функции достаточно маленькие, то основная суть скорее наоборот будет выделяться яснее.

## Знание языка и диалектов (подъязыков из библиотек)

Сложность кода иногда может быть обусловлена несоответствием используемых инструментов актуальным версиям языка и библиотек. Очень важно не только регулярно поднимать версии зависимостей, но проверять, что же там изменилось. Возможно, там были закрыты некоторые уязвимости, или появились более простые инструменты, позволяющие упростить код и тем самым повысить его читаемость и устойчивость к правкам.

Твоя среда разработки может даже иногда посоветовать как заменить существующий код на более простой и, как правило, эффективный. Например, вместо `.filter(cond).headOption` удобнее писать `.find(cond)`. Обычно это действительно полезные советы, но, как и всегда, решения нужно принимать самостоятельно.

Но, например, при работе с библиотекой Cats среда разработки уже не подскажет, что вместо `.map(x => x -> x.id)` точнее будет `.fproduct(_.id)`, а вместо `.map(f).sequence.map(_.flatten)` лучше писать `.flatTraverse(f)`. Поэтому полезно самостоятельно изучать возможности используемых библиотек и каждый раз задумываться, какой инструмент будет сподручнее.

Чтобы находить наиболее удобные инструменты нужно понимать некоторые <u>математические основы программирования</u>. Различные Scala-библиотеки предоставляют свои контейнерные типы для работы с эффектами, но в них есть много общего, так как все они основаны на фундаментальных понятиях теории категорий. Полезно ознакомиться хотя бы элементами этой теории — что такое функторы, естественные преобразования и основанные на них монады, сопряжённые и аппликативные функторы, профункторы и стрелки т.п. Тогда, зная что искать, <u>в любой библиотеке ты сможешь найти наиболее подходящие возможности контейнерных типов</u>.



## Избегаем повторов

Не могу припомнить книг, в которых мне встретились <u>повторяющиеся фрагменты текста</u>. Читатель, встречая <u>повторяющиеся фрагменты текста</u> задастся вопросами: «Зачем я потратил время на то, что уже прочёл ранее? Чего добивался автор?». Издательства такие сочинения стараются не тиражировать.

А вот в программном коде <u>повторяющиеся фрагменты текста</u>, к сожалению, часто проходят заслоны ревью. Причина их появления в том, что бездумное копирование кода немного проще, чем переиспользование, или декомпозиция (например, вынос этого фрагмента в отдельный метод). Да и распознать такое мошенничество не так-то просто. Ведь в отличие от книг, текст программы, разбитый на блоки (методы, классы и т.п.), не подразумевает, что его будут читать «подряд», наталкиваясь на <u>повторяющиеся фрагменты текста</u>. Наоборот, расследуя сбои, или внося правки зачастую сложно заметить такие повторы.

Как раз в этом и прячется наибольшая опасность — ты может обмануться, посчитав важным лишь один фрагмент кода, но не заметив его копии. Правки такой логики могут привести к одновременному существованию разных её версий, дающих непредсказуемое поведение в зависимости от контекста обращения к ней. Дублирование кода принесло слишком много боли человечеству… Но даже если ты потратишь время на поиски всех копии, придётся либо вносить правки в каждой, либо (правильный выбор!) самому устранить дублирование, с которым почему-то не справился предыдущий автор.

Устраняется дублирование кода знакомым способом — вводится новый идентификатор, за которым скрывается <u>повторяющийся фрагмент кода</u>, а все копии заменяются на обращение к этому идентификатору.

>Но получается, что теперь сам идентификатор постоянно повторяется. Можно ли избежать и этого? Один из способов защиты от такого дублирования дают **линейные типы**. Идентификатор значения такого типа может встретиться в тексте программы лишь дважды — в момент определения (присвоения) и в момент <u>единственного</u> использования. Линейные типы могут принести много пользы, но работа с ними требует определённых навыков, ещё несвойственных современной культуре программирования. Да и реализованы они пока лишь в нескольких не самых популярных языках программирования.

И всё же, иногда повторение кода может быть оправдано. Например, это могут быть части совершенно независимой логики, и лишь на данном этапе эти части случайно оказались одинаковыми, но известно, что в дальнейшем их пути развития разойдутся, они перестанут быть похожими. Такие рассуждения применимы не только к логике, но и моделям данных — описание интерфейсов разных приложений может частично совпадать, но нет причин устранять это дублирование.

При сопоставлении с шаблонами какого либо типа-суммы часто встречается шаблонный код вида
```scala
case MyAlgebraicType.Constructor1(_, _) => ???
case MyAlgebraicType.Constructor2(_)    => ???
case MyAlgebraicType.Constructor3       => ???
...
```
В большинстве подобных случаях будет удобнее заранее импортировать все члены типа- суммы:
```scala
import MyAlgebraicType.*
```

Аналогично, при работе с большими типами-произведений (например, при конвертировании DTO), чтобы не повторять <u>перед каждым полем</u> `entityDto.` можно импортировать все члены сущности:
```scala
def convertToDomain(entityDto: MyEntityDTO) = {
  import entityDto.*
  MyDomainEntity(
    dtoField2,
    dtoField3,
    dtoField1,
    ...
  )
}
```

Ещё одна разновидность повторений связана с частой привычкой расставлять везде аннотации типов. Следующий код прямо-таки тяжело читать:
```scala
val elephant: Elephant = Elephant()
```

Не нужно подражать Капитану О\[чего-то там\]. Ошибочно считать, что повсеместная расстановка типов способствует лучшему пониманию кода. Типы нужны компилятору для проверки корректности кода, но при чтении кода гораздо важнее точные названия переменных и функций. Проставлять типы полезно лишь для тех возможностей, которые действительно предназначены для стороннего использования:
```scala
trait MyService[F[_]]:
  def method: (SomeData, SomeAnotherData) => F[SomeResult] // только типы

object MyService:
  def apply = MyService[IO]:
    val method = (someData, someAnotherData) => ???        // только значения
```
Подобных аннотаций должно быть достаточно компилятору, чтобы проверить всю программу.

У автоматических средств проверки программы иногда возникает каприз, когда они требует либо явно проставлять типы у публичных членов, либо приписывать к ним модификатор `private`. Оба варианта приводят к необоснованному повторению кода. Про аннотирование интерфейсов я только что рассказал. В свою очередь, мания «прятать изменчивые потроха классов» берёт своё начало из объектно-ориентрованного программирования и практически неактуальна в Scala. Чтобы избавить код необходимости повторять аннотации типов, или ООП-шный `private`, я рекомендую тебе найти способ отключить такую проверку насовсем.

Помимо ситуаций полного дублирования кода, может встречаться также множество фрагментов кода, организованных по определённому шаблону. Обычно такое встречается при обработке громоздких структур данных в пределах одного метода, поэтому сразу бросается в глаза при чтении. Шаблонный код чреват теми же проблемами, что и повторяющийся, поэтому когда сталкиваешься с таким кодом можно попробовать следующее:
- поискать возможность устранить повторяемость;
- собрать шаблонный код в одном месте, строчка за строчкой;
- по возможности, отформатировать шаблонный код, расставив пробелы, чтобы получилось некое подобие таблицы.

Вот пример табулированного шаблонного кода:
```scala
ifaceName             = ifname,
area                  = area,
authentication        = fields("authentication")     .headOption.flatten,
simpleKey             = fields("authentication-key") .headOption.flatten,
helloIntervalSec      = fields("hello-interval")     .headOption.flatten.flatMap(_.toIntOption),
deadIntervalSec       = fields("dead-interval")      .headOption.flatten.flatMap(_.toIntOption),
retransmitIntervalSec = fields("retransmit-interval").headOption.flatten.flatMap(_.toIntOption),
cost                  = fields("cost")               .headOption.flatten.flatMap(_.toIntOption),
priority              = fields("priority")           .headOption.flatten.flatMap(_.toIntOption),
passiveAddress        = fields("passive")            .headOption.pipe(ThreeState.fromOptOpt),
md5Keys               = fields("message-digest-key") .flatten.pipe(parseMd5Keys),
```

Выгода от такого форматирования в том, что элементы шаблона, будучи единожды прочитаны, больше не отнимают внимания читателя, а вот любое нарушение шаблонности сразу заметно. Табулирование даёт некую предсказуемость при чтении шаблонного кода, и в этом смысле его можно сравнить с рифмой в поэзии.



## Знаки запинания

Язык Scala по синтаксису схож со многими популярных языков программирования: аргументы функций перечисляются через запятую в круглых скобках, блоки кода заключаются в фигурные скобки, вызовы метода отделяется от объекта точкой и т.п. В отличие от легко читаемых литературных текстов, программный код зачастую бывает перегружен целым ворохом подобных знаков препинания, что, конечно же, затрудняет чтение. К счастью, во многих случаях Scala позволяет облегчить код, смахнув ненужные значки.

Если реализация функции укладывается в единственное выражение то его вовсе не обязательно обрамлять фигурными скобками. Если же у тебя возникает желание отметить закрывающейся скобкой тело функции со слишком большим выражением, то практически наверняка тебе стоит задуматься о декомпозиции. Также в третьей версии Scala поддерживается новый синтаксис, когда лишние фигурные скобки не нужно писать в `if`, `for`, сопоставлениях с шаблонами и даже сложных блоках кода, состоящих из нескольких операций. А если всё-таки сочтёшь нужным, то ты всегда можешь преднамеренно «закрыть скобку», с помощью нового ключевого слова `end`.

Кортежи в Scala записываются как перечисленные через запятую значения в квадратных скобках `(a, b, c, d)`. Но в то же время для наиболее часто встречающихся кортежей-пар есть и другая форма записи: `key -> value`. Если действительно подразумевается сопоставление «ключ-значение», то лучше использовать именно такую форму записи. Она не только наглядна сама по себе, но и позволяет убрать лишнюю пару скобок, что особенно важно в ситуациях, когда скобки идут подряд.

Для ООП привычен такой синтаксис вызова метода: `object.do(something)`. Тут просматривается стандартная форма предложения: «подлежащее сказуемое дополнение», но мешают лишние знаки препинания. С точки зрения естественного языка гораздо удобнее читается `object do something`. И Scala поддерживает этот синтаксис, но только если метод принимает только один аргумент. Такое ограничение нацелено на то, чтобы было удобнее объявлять <u>инфиксные операторы</u>, вроде `zip`, `andThen` (примеры: `list1 zip list2`, `funct1 andThen funct2`). Чтобы ты мог так же вызывать собственные методы в последней версии Scala, нужно либо при вызове заключить имя метода в апострофы ``object `do` something`` (что всё равно читается лучше), либо явно указать такую возможность в объявлении метода `infix def do(...)`.

Снова замечу, что приведённые мной примеры не навязывают строгие правила, но раскрывают возможности, которые нужно учитывать, когда мы стремимся сделать свой код лучше.


## Функциональное программирование

В наше время \[не то, что сейчас!\] всё ещё в моде <u>императивный</u> стиль программирования, в котором пишутся <u>инструкции для исполнителя</u>, последовательность приказов (императивов), таких как «пойди сюда», «возьми то», «отправь туда», «получи оттуда», «положи тут», «вернись обратно» и т.п. Так сложилось испокон веков, когда в ранних языках программирования были только такие команды, ориентированные на общепринятую архитектуру вычислительной машины. Языки развивались, но большинство из них по прежнему предлагали в основном императивные конструкции.

В то же время ещё до появления ЭВМ программисты знали, что чтобы написать хорошую программу достаточно всего двух основных языковых конструкций — <u>объявление функции и её применение</u> к значению \[см. λ-исчисление\]. Но мало того, что синтаксис такого языка максимально прост, оказывается, что и корректность алгоритмов на нём удобно проверять ещё до их исполнения автоматическими средствами!

Функции сами могут выступать в роли значений \[функции, как объекты первого класса\] — их можно передавать как аргументы в другие функции, и получать их в результате вычислений. Ввиду ориентированности на функции, такой подход называют <u>функциональным программированием</u>.

Программа строится не как последовательность приказов недотёпе-компьютеру, а как декларация ожидаемого результата: «нужен результат выполнения `функции1`, которая принимает на вход результат `функции2`, получающей на вход сумму первоначальных аргументов, передаваемых нашей программе». Поэтому функциональное программирование часто называют <u>декларативным</u>. Оно подразумевает, что компьютер сам должен понять, что от него ожидают, и составить последовательность низкоуровневых команд, приводящих к требуемому результату.

В функциональном программировании нет необходимости в императивных конструкциях, вроде `if`, `match`, `return`, `for`, ~~`goto`~~ и проч. В этом смысле все <u>они являются усложнением синтаксиса</u>, причём, зачастую, весьма существенным. Мы же стремимся избегать излишних сложностей в коде, делать код максимально простым.

В языке Scala во многих ситуациях вместо императивных операторов можно подобрать функциональные альтернативы:
- вместо `if` можно использовать использовать встроенные `Option.when`, `Either.cond`, или всякие `Applicative.whenA`, `FlatMap.ifM` и проч. из библиотеки Cats;
- сопоставление с шаблонами часто применяется для контейнерных типов, у которых есть встроенные возможности, вроде `fold`;
- ранний выход из функции (взамен  `if (!cond) return`) можно организовать разными способами, например с использованием `Option.traverse`;
- вместо `for`-выражений лучше использовать цепочки вызовов всяких `.map`,  `.flatMap` и прочих возможностей контейнерных типов.

Но вспомним наше кредо! Во-первых, возможностей стандартных типов может не хватить, чтобы красиво реализовать все наши идеи и императивный код внезапно может оказаться проще. Во-вторых, императивные конструкции преподаются со школы, и не смотря на то, что они объективно добавляют сложность языку, для многих программистов они совершенно привычны и не доставляют проблем (хотя такое впечатление бывает обманчивым). Так что, как обычно, в каждом случае самостоятельно оценивай, нравится ли тебе конечный результат, и примут ли его товарищи.

## Композиция вычислений

Язык Scala ориентирован на безопасную работу с эффектами, прежде всего, с асинхронностью. Эффекты обрабатываются по возможности «чисто», посредством цепочек монадических вычислений в типах-контейнерах. Синтаксис языка позволяет реализовать композицию таких вычислений различными способами. Вот самые типичные:
- простая «стековая» композиция;
- `for`-выражения;
- потоковые вычисления посредством комбинаторов вроде `.flatMap`;
- операторная композиция;
- бесточечный стиль посредством буквенных (`andThenK`) или символьных (`>=>`) комбинаторов.

Давай посмотрим их на примере таких функций:
```scala
import cats.syntax.all.* 
import cats.effect.IO

val funct1:  Int       => IO[Int] = ???
val funct2:  Int       => IO[Int] = ???
val funct3:  Int       =>    Int  = ???
val funct4: (Int, Int) => IO[Int] = ???
```
Общие выводы будут справедливы для любой системы эффектов.

Первый способ композиции, к счастью, практически нигде не используется:
```scala
val prog1 = (i: Int) =>
  val res1 = funct1(i)
  val res2 = res1.flatMap(funct2)
  val res3 = res2.map(funct3)
  val res4 = res1.product(res3) // res1 выполнится дважды!
  res4.flatMap(funct4.tupled)
```
Такая наивная программа имеет множество недостатков:
- она многословна,
- перенасыщена знаками препинания,
- множество идентификаторов, большинство которых нужны лишь в следующей строчке, но по ошибке могут использованы и позднее,
- а, пожалуй, главное — в случае «ленивого» контейнера `IO` эффект в `res1` будет выполнен дважды, что навряд ли является ожидаемым результатом.

Последняя проблема исчезает, если программу переписать с помощью `for`-выражения:
```scala
val prog2 = (i: Int) => for
  res1 <- funct1(i)
  res2 <- funct2(res1)
  res3 =  funct3(res2)
  res4 <- funct4(res3, res1)
yield res4
```
Заодно и код стал немного опрятнее, но большинство проблем осталось. Хоть и знаков препинания теперь меньше, но взамен появилась новая сложная синтаксическая конструкция. И по-прежнему сохранились типичные опасности стекового стиля:
- множество идентификаторов с неоправданно долгим временем жизни, которые не только перегружают код малополезной информацией, но и могут быть неосторожно использованы не по месту, причём даже компилятор не обнаружит ошибку;
- последовательность вычислений зачастую недостаточно фиксируется, из-за чего не только страдает производительность, но приводит к плохо предсказуемому срабатыванию побочных эффектов.

Последний пункт усугубляет то, что `for`-выражение обслуживает <u>лишь последовательную композицию вычислений</u>. Для независимых \[«аппликативных»\] вычислений придётся как и прежде явно вызывать подходящие методы у контейнеров эффектов. К сожалению, этот аспект частенько ускользает от внимания некоторых программистов, и все вычисления компонуются последовательно, посредством `for` \[вспоминается анекдот про Пурген как лекарство от всех болезней…\].

Кроме того, `for` является синтаксическим сахаром для всего трёх возможностей типов-контейнеров: `map`, `flatMap` и `filter`. На практике же очень часто приходится пользоваться и другими возможностями, что в сочетании `for` не то, чтобы сильно упрощает код, но иногда даже, наоборот, усложняет.

Пожалуй, наибольшая проблема связана с <u>популярностью for-выражений</u>. Многие программисты называют этот инструмент \[«killer feature»? что-то на латыни\] языка Scala, и используют этот паттерн повсеместно, даже не задумываясь. Не смотря на недостатки, `for`-выражения действительно бывают удобны и относительно безопасные в некоторых случаях. Но попробуй убедить коллег <u>хотя бы задумываться</u>, не найдётся ли вариант получше.

Например, такой:
```scala
val prog3 = (i: Int) =>
  funct1(i)
    .mproduct(funct2)
    .map(_.map(funct3))
    .flatMap(funct4.tupled)
```
Да, тут снова вернулись `map`, `flatMap`, которых не было с `for`, и всё же код стал гораздо компактнее. Ведь, помимо лишней синтаксической конструкции, не осталось и «промежуточных точек» — идентификаторов, откровенно засорявших код ранее. В данном же варианте от строчки к строчке передаётся только то состояние, которое требуется на следующем шаге. Нет смысла именовать его каждый раз затем, чтобы использовать его лишь в следующей строчке и сразу же забыть. Кроме того, этот код защищён от множества неочевидных ошибок, которые можно было бы допустить при внесении правок. 

Потоковый стиль могу рекомендовать в качестве универсального. Он даёт единообразный синтаксис вызова метода для обращения ко всем возможностям контейнерных типов. Вот только сам по себе этот синтаксис перенасыщен знаками препинания, что особенно заметно при наличии вложенных вызовов. Впрочем, в таких ситуациях всегда выручает декомпозиция.

От лишних знаков препинания можно избавиться, перейдя к инфиксной форме вызова методов:
```scala
val mapFunct3 = (_: (Int, Int)) map funct3 // декомпозиция
val prog4 = (i: Int) =>
  funct1(i)     mproduct
  funct2        map
  mapFunct3     flatMap
  funct4.tupled
```
Выглядит почти идеально! Инфиксная запись акцентирует внимание именно на шаги вычислений, а комбинаторы уходят на второй план. Однако, и тут есть ограничение — операторная форма допустима только для методов одного аргумента. Ещё аргумент `i` был нужен только в первой строчке, но он доступен во всём теле функции, что оставляет возможность его ошибочного использования.

Многие библиотеки предлагают символьные операторы, вроде `>>`, или `>>=` взамен `flatMap`. С ними запись может получиться более идиоматичной. К сожалению, единого стандарта этих операторов в Scala нет, и в разных библиотеках (Cats Effect, ZIO) для тех же самых комбинаторов зачастую используются разные наборы символов. Но даже если эти операторы кому-то незнакомы, обычно не возникает проблем с пониманием таких выражений. Поэтому считаю <u>вполне допустимым</u>, когда тело функции состоит из простой комбинации вида `f(a) >> g(b) >> h(c)`.

Наиболее выразительным является бесточечный стиль, когда новые функции мы буквально собираем как конструктор из существующих:
```scala
val funct23 = // Int => IO[Int]
  funct2 andThenF (funct3 andThen IO.pure)

val funct23Splitted = // Int => IO[(Int, Int)]
  identity[Int] merge funct23 andThen {_.sequence}

val prog5 =
  funct1          andThenF 
  funct23Splitted andThenF
  funct4.tupled
```
В данном примере видна 


## Системы эффектов

- Try, Future,
- IO, ZIO,
- TF,
- Freer,
- алгебраические эффекты(ContT)
- стрелки


- «императивный стиль» \[direct style\].

Последний пункт тут самый загадочный. Он вроде бы как и предлагает упрощение, но всё же возвращает к хоть и привычному, но избыточному императивному синтаксису, а также к стековым вычислениям с их концептуальной неустойчивостью к правкам. Кроме того, многие реализации императивного стиля основаны на макросах, которые, как известно, являются своеобразным «жульничеством», призванным исправить недостатки языка... Впрочем, новомодные решения вместо макросов используют «более честные» контекстные абстракции. Ещё некоторые библиотеки позволяют дополнительно облегчить синтаксис, устраняя проблему «цветных функций». Однако, есть мнение, что «обесцвечивание» функций может оказаться небезопасным, и такую возможность отключают намеренно.

### Контексты, вывод типов и логическое программирование


## Эклектика


## Рефакторинг

Как говорил один наш великий предшественник
> Всё должно быть изложено настолько просто, на сколько это возможно, но не проще.

Со сложным кодом тяжело работать, он может ввести в заблуждение, что в итоге приведёт к неочевидным ошибкам при попытке внести туда правки. Поэтому найдя и реализовав решение поставленной задачи всегда полезно посмотреть на его составляющие и подумать, «нужно ли мне это?», «нет ли тут чего-то лишнего?», «можно ли сделать проще?».


Основная причина — лень. Спешка. 
Если не можешь выразит словами, значит ты этого не понимаешь.




# PS

Нет абсолютных истин. В том числе это послание — лишь личное мнение, синтезированное на основе ограниченного опыта, как чужого, так и собственного. Возможно сам оспорю всё это уже завтра.

Нельзя навязать стремление к свободе. Общайся, убеждай, но всегда будь готовым к тому, что чужая истина может показаться тебе «более истинной».

Слова, вообще, лгут.


Когда тебя убеждают, что одна парадигма программирования лучше другой, помни:
**Ничто не истинно!**

Когда тебе не рекомендуют пользоваться шаблонными решениями, помни
**Всё дозволено!**

~~Да направит тебя Отец Понимания!~~
~~Да прибудет с тобой сила!~~
\[Точно не уверен, какое там напутствие\]
![[8ball.png|Не привыкай доверять готовым ответам. Окончательное решение принимать тебе.]]
