Теги: #ФП/Generics #ФП/Scala #ФП 

[оригинал](https://apocalisp.wordpress.com/2010/07/02/higher-rank-polymorphism-in-scala/)


Я читал [сообщение Тима Карстенса о функциях Haskell, которые он хотел бы видеть в других языках](http://intoverflow.wordpress.com/2010/06/30/haskell-features-id-like-to-see-in-other-languages/) , и одной из этих функций были типы ранга 2. Тим говорит, что убойное приложение для этого, чтобы обеспечить безопасность доступа к ресурсам, в системе типов. Короче говоря, эта функция позволяет нам убедиться, что если у нас есть значение определенного типа, то оно представляет собой системный ресурс, к которому можно безопасно получить доступ, и что это ошибка типа времени компиляции для доступа к закрытому или неоткрытому ресурсу. Я нахожу действительно захватывающим то, что мы можем получить такую ​​уверенность от системы типов.

Во-первых, краткое объяснение полиморфизма ранга 2. Обычная (ранг-1) полиморфная функция в Scala может выглядеть так:

```
def apply[A](f: A => A, a: A): A = f(a)
```

Это применит данную функцию к заданному значению любого _конкретного типа_ , и гарантируется, что типы аргументов и возвращаемых значений функции совпадают со значением, к которому она применяется. Здесь задействован только один тип, но это может быть любой конкретный тип. Но что, если мы хотим сказать, что функция `f`должна работать для всех типов? Например, функция, которая помещает свой аргумент в список. Такая функция должна работать для всех типов, если тип ввода и вывода совпадают. Например:

```
def singletonList[A](a: A): List[A] = List(a)
```

Теперь предположим, что мы хотим принять такую ​​функцию в качестве аргумента другой функции. Только с полиморфизмом ранга 1 мы не можем сделать это:


`def` `apply[A,B](f``:` `A` `=``> List[A], b``:` `B, s``:` `String)``:` `(List[B], List[String])` `=`

  `(f(b), f(s))`

Это ошибка типа, потому что `B`и `String`не являются `A`. То есть тип `A`фиксируется справа от квантификатора `[A,B]`. Мы действительно хотим, чтобы полиморфизм аргумента сохранялся, чтобы мы могли применять его полиморфно в теле нашей функции. Вот как это могло бы быть выражено, если бы в Scala были типы ранга n:


`def` `apply[B](f``:` `(A` `=``> List[A]) forAll { A }, b``:` `B, s``:` `String)``:` `(List[B], List[String])` `=`

  `(f(b), f(s))`

Это недопустимый код Scala, так что давайте посмотрим, как мы можем это обойти. Обратите внимание, что метод может быть полиморфным по своим аргументам, но значение типа Function1, Function2 и т. д. является мономорфным. Итак, что мы делаем, так это представляем полиморфную функцию ранга 2 с новым трейтом, который принимает аргумент типа в своем `apply`методе:


`trait` `~>[F[``_``],G[``_``]] {`

  `def` `apply[A](a``:` `F[A])``:` `G[A]`

`}`

Эта черта отражает нечто более общее, чем `Function1`, а именно естественное преобразование функтора `F`в функтор `G`. Обратите внимание, что `A`он нигде не появляется в типе и не передается до тех пор, пока фактически не будет вызван метод apply. Теперь мы можем смоделировать функцию, которая принимает значение и помещает его в список, как естественное преобразование функтора тождества в функтор списка:


`type` `Id[A]` `=` `A`

`val` `singletonList` `=` `new` `(Id ~> List) {`

  `def` `apply[A](a``:` `A)``:` `List[A]` `=` `List(a)`

`}`

И теперь мы можем взять такую ​​функцию в качестве аргумента:

`def` `apply[B](f``:` `Id ~> List, b``:` `B, s``:` `String)``:` `(List[B], List[String])` `=`

  `(f(b), f(s))`

Интересно, можем ли мы использовать это, чтобы получить статические гарантии безопасного доступа к ресурсам, как в монаде SIO, подробно описанной в [Lightweight Monadic Regions](http://www.cs.rutgers.edu/~ccshan/capability/region-io.pdf) .