
# Dot product

> Даны 2 вектора целых чисел одинаковой длины, заданные в сжатой форме списками пар вида `(value, count)`. Например, вектор `[4, 4, 5]` задается как `[(4, 2), (5, 1)]`. Необходимо посчитать скалярное произведение заданных векторов. Сжатие сохраняет порядок вектора.  

Сигнатура функции:
```scala
def dotProduct(vec1: List[(Int, Int)], vec2: List[(Int, Int)]): Long
```

Парочка сценариев для тестирования:
* `(List.empty[(Int, Int)], List.empty[(Int, Int)]) -> 0L`,
* `(List((4, 2), (5, 1)), List((2, 1), (1, 2)))     -> 17L`,
* `(List((1, 999999)), List((1, 999999)))           -> 999999L`.

## Анализ

## Наивное решение «в лоб»

Давайте просто сперва развернём сжатые вектора в исходные и вычислим обычное скалярное произведение:
```scala
val getOrigView: List[(Int, Int)] => View[Int] =  // Представление исходного вектора
  _.view.flatMap((i, n) => View.fill(n)(i))  

def simpleDotProduct(v1: Iterable[Int], v2: Iterable[Int]) =  
  (v1 `zip` v2).map(_ * _).sum  

def dotProduct(vec1: List[(Int, Int)], vec2: List[(Int, Int)]): Long =  
  simpleDotProduct(getOrigView(vec1), getOrigView(vec2))
```

Решение очень простое, прямо-таки тривиальное. Память алгоритма константная за счёт использования `View` — это, по сути, `SupperFree[Seq]` **ССЫЛКА!!!!**, псевдоколлекция, которая не только лениво накапливает применяемые к ней преобразования, но применяет их все поэлементно, не сохраняя в памяти промежуточные значения и результат. Оценка производительности стабильно пропорциональна длине исходных, несжатых векторов.

Однако, используемое в задаче сжатие вектора позволяет существенно оптимизировать вычисление скалярного произведения в случае, когда у векторов повторяются значения подряд идущих координат. Прогон такого алгоритма на втором тестовом сценарий со сжатыми векторами миллионной размерности демонстрирует на современных компах задержку, заметную глазу, хотя в этом случае результат вычисляется в уме, причём гораздо быстрее.

Нужно переписать алгоритм так чтобы при расчёте использовались преимущества сжатых векторов. Сделаем это с помощью рекурсии, например, так:
```scala
def dotProduct(vec1: List[(Int, Int)], vec2: List[(Int, Int)]): Long =  
  (vec1.headOption `zip` vec2.headOption)  
    .fold(0L) { case ((i1, n1), (i2, n2)) =>  
      val ii = (i1: Long) * i2  // важно не получить переполнение уже здесь
      val nn = n2 - n1  

      if nn > 0 then ii * n1 + dotProduct(vec1.tail, (i2, nn) +: vec2.tail)  
      else           ii * n2 + dotProduct((i1, -nn) +: vec1.tail, vec2.tail)  
    }
```
Если какой-то из списков пустой, то это не страшно — значит либо другой тоже пустой, либо там будет единственная пара с нулевым количеством повторений, и в этом случае возвращаем `0`. Иначе разбираем первые пары из обоих векторов: оптимизированно вычисляем промежуточную свёртку для первых `n1 min n2` измерений, и остаётся лишь добавить свёртку оставшихся хвостов с учётом недосчитанного остатка от нашей оптимизации.

Тестовые сценарии второй алгоритм обработает успешно, причём заметно быстрее первого варианта. Однако, ввиду передачи параметров через стек, данный алгоритм потребляет память, пропорциональную длинам сжатых векторов, и если в исходном векторе миллионной размерности вообще не будет повторяющихся последовательных значений, то произойдёт переполнение стека…

Хорошо, проблема обозначена, давайте решим её, переписав рекурсию в хвостовой форме, благо компилятор Scala умеет её оптимизировать. Для этого, в частности, вручную разберём `Option` с «головами» векторов, применим ранний выход, а также нам придётся добавить в список аргумент аккумулятор результата:
```scala
@tailrec  
def dotProductRec(accum: Long, vec1: List[(Int, Int)], vec2: List[(Int, Int)]): Long =  
  val heads = vec1.headOption `zip` vec2.headOption  
  if heads.isEmpty then return accum
  
  val ((i1, n1), (i2, n2)) = heads.get  
  
  val nextVec1 = if n1 > n2 then (i1, n1 - n2) +: vec1.tail else vec1.tail  
  val nextVec2 = if n2 > n1 then (i2, n2 - n1) +: vec2.tail else vec2.tail  
  
  
  dotProductRec(accum + (n1 min n2: Long) * i1 * i2, nextVec1, nextVec2)  
end dotProductRec  
  
def dotProduct(vec1: List[(Int, Int)], vec2: List[(Int, Int)]): Long =  
  dotProductRec(0L, vec1, vec2)
```

Вот такой реализации уже не страшны произвольные вектора больших размерностей, и потребляемая память не будет зависеть от длины векторов!

**!!! тут подробнее расписать переход к дальнейшему !!!**

Рекурсия чужеродна лямбда-исчислению, ссылки на ещё неопределённые термы опасны, их трудно контролировать. Благо, всегда есть возможность спрятать рекурсию в свёртку/развёртку тех или иных рекурсивных типов, неподвижных точек некоторых конструкторов типов **ССЫЛКА!!!**.

В данном случае такой конструктор типов (обобщённый тип!) легко вычисляется на основе последнего алгоритма, который
- в одном из вариантов останавливает вычисления,
- в другом варианте вычисления продолжаются с изменившимся состоянием
- результатом каждого шага вычиcлений будет `accum: Loong`.
Отсюда следует, что искомый конструктор типов будет иметь вид
```scala
type Cell[State] =>> Option[(Long, State)]
```
На каждом шаге используется состояние такого вида:
```scala
type State = (accum: Long, vec1: List[(Int, Int)], vec2: List[(Int, Int)])
```
Новое состояние вычисляется внутри контейнера посредством коалгебры функтора `Cell` (его функториальность достаточно же очевидна?):
```scala
type Coalgebra[F[_]] = [A] =>> A => F[A]

val coalgebra: Coalgebra[Cell][State] = // State => Option[(Long, State)] 
  case (accum, vec1, vec2) =>  
    (vec1.headOption `zip` vec2.headOption)  
      .map { case ((i1, n1), (i2, n2)) =>  
        val nextAccum = accum + (n1 min n2) * i1 * i2  

        val nextVec1 = if n1 > n2 then (i1, n1 - n2) +: vec1.tail else vec1.tail  
        val nextVec2 = if n2 > n1 then (i2, n2 - n1) +: vec2.tail else vec2.tail  

        nextAccum -> (nextAccum, nextVec1, nextVec2)  
      }
```
С помощью этой коалгебры нам нужно итеративно развернуть состояния, причём нас интересует только значение аккумулятора у самого последнего.

Результатом развёртки будет *неподвижная точка* для функтора `Cell`, которая очевидно будет списком:
```scala
case class Fix[F[_]](unfix: F[Fix[F]]) // неподвижная точка: F[Fix[F]] ≅ Fix[F]
type MyList[A] = Fix[OptCell[A]]       // да, тип изоморфен самому обычному списку
```

В этот раз мы поручим развёртку встроенному методу `Iterator.unfold`, который не сохраняет промежуточные значения, а свёртку — методу `lastOption`:
```scala
def dotProduct(vec1: List[(Int, Int)], vec2: List[(Int, Int)]): Long =  
  Iterator
    .unfold(0L, vec1, vec2)(coalgebra)
    .to(View) // промежуточные значения не сохранятся, но получаем новые возможности
    .lastOption.getOrElse(0L)
```
В итоге получаем те же метрики, что и у предыдущего алгоритма, но здесь вся рекурсия (все циклы!) спрятаны в свёртку/развёртку рекурсивной структуры (списка).


# Brackets


# PathFinder



# Первоначальные планы

## Префикс функция


## Быстрое преобразование Фурье

https://rosettacode.org/wiki/Fast_Fourier_transform#Scala

##  Динамическое программирование

[О динамическом программировании на пальцах](https://habr.com/ru/articles/777618/)
