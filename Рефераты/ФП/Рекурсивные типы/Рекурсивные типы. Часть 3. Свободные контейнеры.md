

<anchor>free</anchor>

#### Свободный контейнер

Выше были представлены общие свойства неподвижных точек, применяемых к произвольным ковариантным конструкторам типов непосредственно. Здесь рассмотрим чуть более сложные неподвижные точки, когда произвольный целевой контейнер предварительно оборачивается в другую конструкцию.

Неподвижная точка, принимая конструктор типов, возвращает простой тип – как бы «понижает арность». Если же «повысить арность» исходного контейнера, использовав его в выражении с дополнительным свободным параметром, то неподвижная точка как бы «восстановит арность», формируя тем самым преобразователь произвольного контейнерного типа в некий другой. Рассмотрим такой пример:
```scala
type CoEnv[E, F[_]] = [X] =>> E Either F[X]  // устоявшееся название
```
Конструктор типов `CoEnv` параметризирован помимо контейнерного `F[_]` ещё двумя простыми типами `E` и `X`. «Унарный» `F[_]` он превращает в «бинарный» `ConEnv[_, F][_]`, неподвижной точной которого будет снова «унарный» контейнер:
```scala
type Free[F[_]] = [A] =>> μ[CoEnv[A, F]] // A Either F[Free[F, A]]
```
Ввиду ковариантности `F[_]` и универсального свойства суммы типов, контейнер `Free[F][_]` можно представить в виде такой бесконечной суммы:

$$
Free[F][A] = A + F[A + F[A + \ldots]] \cong A + F[A] + F[F[A]] + \ldots
$$

Не сложно убедиться, что рекурсивный контейнер `Free[F][_]` также является ковариантным:
```scala
given liftForCoenv[F[_]: Lift, A]: Lift[CoEnv[A, F]] =
  [X, Y] => (f: X => Y) => (fx: CoEnv[A, F][X]) => fx.map(_ map f)

given liftForFree[F[_]: Lift]: Lift[Free[F]] =
  [A, B] => (f: A => B) => (fa: Free[F][A]) =>
    inFix[μ, CoEnv[B, F]](
      outFix[μ, CoEnv[A, F]](fa)
        .left .map(                   f  )
        .right.map(fmap(fmap[Free[F]](f)))
    )
```

Чистые значения можно «освободить» с помощью `pureFree`,  а запакованные в `F[_]` – «поднять в свободный мир» посредством `liftFree`:
```scala
def pureFree[F[_]: Lift, A]( a:   A ): Free[F][A] = inFix[μ, CoEnv[A, F]](Left ( a             ))
def liftFree[F[_]: Lift, A](fa: F[A]): Free[F][A] = inFix[μ, CoEnv[A, F]](Right(fa map pureFree))
```
Распаковка свободного контейнера – это обычная свёртка:
```scala
def convertAlgebra[F[_]: Lift, A]: Algebra[F][A] => Algebra[CoEnv[A, F]][A] =
  alg => {_.fold(identity, alg)}

def goFree[F[_]: Lift, A]: Algebra[F][A] => Algebra[Free[F]][A] =
  convertAlgebra[F, A] andThen foldFix[μ][CoEnv[A, F]][A]

val freeVal: Free[Option][Int] = liftFree(Option(42))
goFree[Option, Int](_.get)(freeVal) // 42: Int
```

Самой же интересной возможностью `Free[F]` является «разматрёшивание» для *любого* ковариантного `F[_]`:
```scala
def flattenFree[F[_]: Lift, A]: Free[F][Free[F][A]] => Free[F][A] =
  foldFix[μ][CoEnv[Free[F][A], F]](
    _.fold(identity, inFix[μ, CoEnv[A, F]] compose Right.apply)
  )

given freeMonad[F[_]: Lift]: Monad[Free[F]] = Monad[Free[F]](
  pure    = pureFree,
  flatten = [X] => (ffx: Free[F][Free[F][X]]) => flattenFree(ffx)
)
```

Таким образом, из «эффективных» функций вида `A => F[B]`, всегда можно построить цепочку вычислений, даже если для `F[_]` не определено «разматрёшивание»! Достаточно на каждом шаге вычислений «поднимать» результат `F[X]` до `Free[F][X]`, композировать вычисления, посредством `liftFree` и `freeMonad` (`flatMap`), в итоге получая результат `Free[F][Result]`. И только в самом конце, при распаковке, потребуется F-алгебра `F[Result] => Result`.

- nLab - круто, но сложновато [transfinite construction of free algebras](https://ncatlab.org/nlab/show/transfinite+construction+of+free+algebras)





<anchor>freer</anchor>

#### Более свободный контейнер

Для работы с контейнером `Free[F][_]` требуется доказательство ковариантности `F[_]`, которое представляет собой реализацию метода `map`. Больше интересных возможностей даёт «более свободный» контейнер `Freer[F][_]` для которого ковариантность `F[_]` необязательна:
```scala
enum   Freer  [F[_], A]:
  case Pure   [F[_], A](a: A)                                      extends Freer[F, A]
  case Suspend[F[_], A](a: F[Freer[F, A]])                         extends Freer[F, A]
  case FlatMap[F[_], A, B](fb: Freer[F, B], afb: B => Freer[F, A]) extends Freer[F, A]

extension [F[_], A](ffa: Freer[F, A])
  def map    [B](f: A =>          B ): Freer[F, B] = Freer.FlatMap(ffa, f andThen Pure.apply)
  def flatMap[B](f: A => Freer[F, B]): Freer[F, B] = Freer.FlatMap(ffa, f                   )
```
Для композиции вычислений теперь вообще не требуются никакие возможности `F[_]`!

Представить `Freer[F][_]` в виде неподвижной точки какого-либо конструктора типов оказывается не так-то просто… Дело в том, что из-за `FlatMap[F[_], A, B]` этот контейнер представляет собой *список преобразований*, причём каждый элемент этого списка *типизирован по-своему*. Такой разнородный список относится к частному случаю *зависимых типов*, а эта тема выходит за рамки данной статьи.

Тем не менее, `Freer[F][_]` открывает замечательные возможности. С ним можно описать бизнес-эффекты как *обобщённые алгебраические типы* (GADT) вида `SomeBuisenessEffect[_]`, и скомбинировать их посредством `Freer`, получая *программу-как-данные* – ту самую ленивую последовательность вычислений. Интерпретация такой программы производится *в самом конце* в любой удобный контейнер эффектов `G[_]`, если для него предоставлены монадные возможности и «естественное преобразование» `SomeBuisenessEffect ~> G`:
```scala
extension [F[_], A](ffa: Freer[F, A])
  def foldMap[G[_]: Monad](interprete: F ~> G): G[A] = ffa match
    case Return(a)      => Monad[G].pure(a)
    case Suspend(ma)    => interprete(ma).flatMap(_ foldMap interprete)
    case FlatMap(fa, f) => fa.foldMap(interprete).flatMap(f(_) foldMap interprete)
```

Больше подробностей, а также примеры использования таких контейнеров можно найти [в предыдущей статье](https://habr.com/ru/articles/807495/#free). В дополнение упомянутых там источников рекомендую также [эту подборку ссылок](https://github.com/mtumilowicz/scala-cats-free-monad-workshop).

«Более свободный» контейнер встречается, например, в библиотеках [Cats](https://typelevel.org/cats/datatypes/freemonad.html) и [Scalaz](https://eed3si9n.com/learning-scalaz/Free+Monad.html) в под именем `Free`. Построение на его основе программных продуктов требует перед исполнением (интерпретацией) «свободной» программы сперва собрать эту самую программу как некое значение. Этот «лишний шаг» влечёт не то чтобы большие, но системные издержки по производительности, поэтому такой подход используется редко. Но сама идея «ленивого списка преобразований» эксплуатируется достаточно часто, в том числе и для бесстековой обработки рекурсии, о которой расскажем далее.



<anchor>trampolines</anchor>

#### Батуты

У англоязычных коллег повторение действий ассоциируется с прыжками на батуте, когда один прыжок приводит к последующим. По этой причине способ защиты от переполнения стека посредством рекурсивных типов называется «*trampoline*».

В качестве первого примера батута будет обобщённый контейнер TailRec из пакета [TailCalls](https://www.scala-lang.org/api/3.x/scala/util/control/TailCalls$.html) стандартной библиотеки Scala.

- [TailRec in the standard library](https://gist.github.com/eamelink/4466932a11d8d92a6b76e80364062250#tailrec-in-the-standard-library)
- Eval из Cats проще
- [IO](https://typelevel.org/cats-effect/docs/datatypes/io) из библиотеки Cats Effect.


[Stackless Scala With Free Monads](https://blog.higher-order.com/assets/trampolines.pdf)(pdf) Runar ´ Oli Bjarnason
[Зачем в Scala трамплины и как их использовать / Хабр](https://habr.com/ru/companies/kryptonite/articles/796433/) (продолжения)

