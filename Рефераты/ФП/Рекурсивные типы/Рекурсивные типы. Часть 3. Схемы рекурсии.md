

<anchor>motivation</anchor>

#### Пример для мотивации

Свёртка и развёртка неподвижных точек конструкторов типов покрывает многие сценарии, где приходилось бы вручную писать рекурсивные функции, но иногда этого оказывается недостаточно.  Рассмотрим пример.

В некоторой компании для каждого работника задан обобщённый перечь атрибутов:
```scala
type EmployerAttributes[A] = (Employer, List[A])
```
Одними из таких атрибутов являются подчинённые – такие же работники компании. Формируется иерархия сотрудников, которую можно записать посредством наименьшей неподвижной точки:
```scala
type Hierarchy = μ[EmployerAttributes]
```

Стоит задача – имея полную иерархию научиться находить для заданного работника всех его подчинённых. Такую функцию можно реализовать рекурсивно:
```scala
def findSubordinates(employer: Employer)(hierarchy: Hierarchy): Option[Hierarchy] =
  val (empl, subrordinates) = outμ(hierarchy) //     отдаётся иерархия ↑↑↑↑↑↑↑↑↑ указанного сотрудника
  Option //                 ↓↓↓↓↓↓↓↓↓ на каждом шаге требуется вся текущая иерархия
    .when(empl == employer)(hierarchy)
    .orElse(subrordinates.flatMap(findSubordinates(employer)).headOption)
    //                            ↑↑↑↑рекурсия↑↑↑↑
```
Для вызова `outμ` потребуется доказательство ковариантности `EmployerAttributes`:
```scala
given Lift[EmployerAttributes] = [A, B] => (f: A => B) =>
  (aLst: EmployerAttributes[A]) => aLst._1 -> aLst._2.map(f)
```

Пусть у нас есть такая структура компании:
```scala
type Employer = String

val hierarchy: Hierarchy = inμ("Бугор", //      Бугор
  List(inμ("Петя",                      //       /
    List(inμ("Ваня", Nil), inμ("Маша",  //     Петя
      List(inμ("Вася", Nil))            //     /  \
	))                                  //  Ваня  Маша
  ))                                    //       /
)                                       //     Вася

val employerStringAlg: Algebra[EmployerAttributes][String] =
  attrs => attrs._1 + attrs._2.mkString(": (", ", ", ")")

foldμ(employerStringAlg)(hierarchy)     // "Бугор: (Петя: (Ваня: (), Маша: (Вася: ())))"
```
Тогда найти подчинённых сотрудника можно так:
```scala
findSubordinates("Петя")(hierarchy)     // Some(Петя: (Ваня: (), Маша: (Вася: ())))
findSubordinates("Вася")(hierarchy)     // Some(Вася: ())
findSubordinates("Катя")(hierarchy)     // None
```

Применять для тех же целей функцию свёртки, описанную ранее, весьма не удобно. Проблема заключается в том, что простая свёртка оперирует F-алгеброй, которая в нашем случае распаковывает единственное значение типа `Employer`, в то время когда нам на каждом шаге в функции `findSubordinates` требуется как работник, так и вся иерархия его подчинённых. Другими словами, нам требуется другая свёртка, с более сложной алгеброй.



<anchor>generalization</anchor>

#### Обобщение свёрток/развёрток

Как можно обобщить F-алгебру для использования её при свёртке рекурсивных структур? Основная задача алгебры – распаковка значения некого типа `X` из контейнера `F`. Поэтому, пожалуй, в наиболее общем виде такими алгебрами будут конструкции вида
```scala
//              Algebra                   = [F[_]] =>> [X] =>>   F[  X ]  =>   X
type GeneralizedAlgebra[W[_], G[_], M[_]] = [F[_]] =>> [X] =>> W[F[G[X]]] => M[X]
```
Но для простоты понимания можно декомпозировать эту конструкцию на три частных случая:
```scala
type     GAlgebra [G[_]] = [F[_]] =>> [X] =>> F[G[X]] =>   X
type ElgotAlgebra [W[_]] = [F[_]] =>> [X] =>> W[F[X]] =>   X // алгебры Элгота
type      AlgebraM[M[_]] = [F[_]] =>> [X] =>>   F[X]  => M[X]
```

В основе любой свёртки по-прежнему лежит всё тот же базовый алгоритм `fold`, описанный ранее. Секрет использования обобщённых алгебр в тех же целях заключается в их приведении к обычной F-алгебре, используемой в `fold`. Для реализации такого приведения необходимы некоторые возможности дополнительных контейнерных типов. Пожалуй, наиболее важной среди них является перестановка этих контейнеров с `F[_]` (**дистрибутивный закон**). Введём дополнительные обозначения:
```scala
type ~>[F[_], G[_]] = [X] => F[X] => G[X]   // естественное преобразование (почти)
type ∘ [F[_], G[_]] = [X] =>> F[G[X]]       // композиция контейнеров
type ⇄[F[_], G[_]] = (F ∘ G) ~> (G ∘ F)     // собственно, перестановка контейнеров
def swap[F[_], G[_]](using sw: F ⇄ G) = sw // [X] => F[G[X]] => G[F[X]]
```
Также для удобства определим следующие классы типов:
```scala
type SwapOut[F[_]] = [G[_]] =>> F ⇄ G     // перестановка вложенного наружу
type SwapIn [F[_]] = [G[_]] =>> G ⇄ F     // перестановка внешнего внутрь
```

Ещё нужны будут возможности «разматрёшивания» и «заматрёшивания» дополнительных контейнеров. Вообще, понятия «монады» и «комонады» заимствованы из *теории категорий*, и обоснование их использования выходит за рамки данного обзора. Поэтому тут введём их без комментариев:
```scala
case class Monad[F[_]: Lift]( // требуется доказательство коварианности F[_]
  pure:         Id ~> F,
  flatten: (F ∘ F) ~> F,
) { val lift = summon[Lift[F]] }

given liftFromMoand[F[_]](using m: Monad[F]): Lift[F] = m.lift

def pure    [F[_]: Monad] = summon[Monad[F]].pure
def flatten [F[_]: Monad] = summon[Monad[F]].flatten
def flatFMap[F[_]: Monad] = [A, B] => (f: A => F[B]) => fmap[F](f) andThen flatten[F][B]

extension  [F[_]: Monad, A] (fa: F[A])
  def flatMap[B] = (f: A => F[B]) => flatFMap(f)(fa)
extension  [F[_]: Monad, A, B] (afb: A => F[B])
  def andThenK[C] = (bfc: B => F[C]) => (a: A) => afb(a).flatMap(bfc)


case class Comonad[F[_]: Lift]( // требуется доказательство коварианности F[_]
  extract:   F ~> Id,
  coFlatten: F ~> (F ∘ F),
) { val fmap = summon[Lift[F]] }

given liftFromComoand[F[_]](using cm: Comonad[F]): Lift[F] = cm.fmap
def extract  [F[_]: Comonad] = summon[Comonad[F]].extract
def coFlatten[F[_]: Comonad] = summon[Comonad[F]].coFlatten
def coFlatMap[F[_]: Comonad] = [A, B] => (f: F[A] => B) => coFlatten[F][A] andThen fmap[F](f)
```

Вооружившись перечисленными возможностями, вот так можно записать преобразование алгебр
```scala
def gAlgToFAlg[F[_]: Lift, G[_]: Comonad: SwapOut[F], X]:          AlgebraG[G][F][X] => Algebra[F][G[X]]    =
  galg => fmap[F](coFlatten[G][X]) andThen swap[F, G][G[X]] andThen fmap[G](galg)

def elgotAlgToFAlg[F[_]: Lift, W[_]: Comonad: SwapOut[F], X]: ElgotAlgebra [W][F][X] => Algebra[F][W[F[X]]] =
  elgotAlg => fmap(coFlatMap(elgotAlg)) andThen swap[F, W][X]

def algMToFAlg[F[_]: Lift, M[_]: Monad: SwapOut[F], X]:            AlgebraM[M][F][X] => Algebra[F][M[X]]    =
  swap[F, M][X] andThen flatFMap(_)
```
и соответствующие им свёртки:
```scala
def gFold[Fix[_[_]]: Fold, F[_]: Lift, G[_]: Comonad: SwapOut[F], X]: AlgebraG[G][F][X] => Fix[F] => X =
  gAlgToFAlg(_) pipe foldFix[Fix][F][G[X]] andThen extract[G][X]

def elgotFold[Fix[_[_]]: Fold, F[_]: Lift, W[_]: Comonad: SwapOut[F], X]: ElgotAlgebra[W][F][X] => Fix[F] => X =
  elgotAlg => elgotAlgToFAlg(elgotAlg) pipe foldFix[Fix][F][W[F[X]]] andThen elgotAlg

def foldM[Fix[_[_]]: Fold, F[_]: Lift, M[_]: Monad: SwapOut[F], X]: AlgebraM[M][F][X] => Fix[F] => M[X] =
  algMToFAlg andThen foldFix[Fix][F][M[X]]
```
Комбинатор `pipe`, передающий аргумент слева в функцию справа, доступен благодаря `import scala.util.chaining.scalaUtilChainingOps`.




<anchor>rec_schemes</anchor>

#### Параморфизм и другие схемы рекурсии

 Для решения задачи о подчинённых можно ввести обобщённую свёртку, называемую «*параморфизм*»:
```scala
type ParaW[Fix[_[_]]] = [F[_]] =>> [X] =>> (X, Fix[F]) // помимо одного элемента, доступна вся оставшаяся структура
type ParaAlgebra[Fix[_[_]], F[_]] = [X] =>> GAlgebra[ParaW[Fix][F]][F][X]

given paraLift[Fix[_[_]], F[_]]: Lift[ParaW[Fix][F]] =
  [A, B] => (f: A => B) => (pfixfa: ParaW[Fix][F][A]) => f(pfixfa._1) -> pfixfa._2

given paraComonad[Fix[_[_]], F[_]]: Comonad[ParaW[Fix][F]] = Comonad(
  extract   = [X] => (px: (X, Fix[F])) => px._1,
  coFlatten = [X] => (px: (X, Fix[F])) => px -> px._2,
)

given paraSwapOut[Fix[_[_]]: Fold: InFix, F[_]: Lift]: F ⇄ ParaW[Fix][F] =
  [X] => (fpara: F[ParaW[Fix][F][X]]) =>
    fpara.map((_: ParaW[Fix][F][X])._1) -> inFix(fpara.map(_._2))

def para[Fix[_[_]]: Fold: InFix, F[_]: Lift, X]: ParaAlgebra[Fix, F][X] => Fix[F] => X =
  gfold[Fix, F, ParaW[Fix][F], X]
```
Теперь в параморфизм можно спрятать всю рекурсию из нашей задаче:
```scala
def subordinatesParaAlg(employer: Employer): ParaAlgebra[μ, EmployerAttributes][Option[Hierarchy]] =
  case (empl, subs) => Option
    .when(empl == employer)(empl -> subs.map(_._2) pipe inFix[μ, EmployerAttributes])
    .orElse(subs.flatMap(_._1).headOption)

def findSubordinates(employer: Employer): Hierarchy => Option[Hierarchy] =
  para[μ, EmployerAttributes, Option[Hierarchy]](subordinatesParaAlg(employer))
```

Обычная свёртка обрабатывает каждый элемент рекурсивной структуры по-отдельности. В этом смысле её иногда называют *итератором*. В тоже время параморфизм рекурсивно проваливается внутрь, на каждом шагу давая доступ ко всей оставшейся структуре. Поэтому такую свёртку иногда называют *простой рекурсией* или [рекурсором](https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt#:~:text=ITERATORS%20AND%20RECURSORS).

Параморфизм оказывается полезен для решения целого класса задач, и по этой причине ему присвоено собственное название. Также свои названия имеют и свёртки, основанные на некоторых других частных случаях обобщённых алгебр. Например, обычная свёртка `fold` традиционно называется *катаморфизмом* (`cata`). Названия, как правило, берутся из греческого языка.

Схожим образом строятся и обобщённые развёртки. Соответствующие обобщённые коалгебры приводятся к обычным, для чего используются такие же монадные и комонадные возможности дополнительных контейнерных типов, а также возможность их перестановки с целевым `F[_]`. У многих обобщённых развёрток также устоялись собственные названия. Например, обычный `unfold` называется *анаморфизмом* (`ana`), а развёртка, дуальная параморфизму – *апоморфизмом* (`apo`).

Без своих имён не остались и некоторые пересвёртки (`refold`). В частности, катаморфизм после анаморфизма образуют *хиломорфизм* (`hylo`). Для демонстрации полезности пересвёрток часто упоминают компиляторы, которые берут текст программы, *разворачивают* его в **абстрактное синтаксическое дерево (AST)**, а затем *сворачивают* это дерево в исполняемый файл.

##### Пересвёртка для факториала

Кроме того, пересвёртки являются основой, так называемого, **динамического программирования**. Это не то, чтобы чётко сформулированная методология, скорее парадигма, относящая определённые алгоритмы к одному классу, если в них используется пересвёртка некоторой рекурсивной структуры данных с какими-либо преобразованиями этой структуры в промежутке.

Опираясь на представленные выше примеры, можно собирать и более сложные алгебры/коалгебры – в них дополнительные контейнеры будут композицией контейнеров попроще (`[H[_]] => [G[_]] =>> H ∘ G`). Имена получаемых в результате свёрткок/развёрткок собираются из имён морфизмов, соответствующих алгебрам, на базе которых были собраны эти композитные конструкции. В частности, так строится ставший уже мемом *[зигогистоморфный препроморфизм](https://wiki.haskell.org/Zygohistomorphic_prepromorphisms)* (`zygoHistoPrepro`).

Все перечисленные в этом разделе манипуляции с рекурсивными типами объединяются одним общим понятием – **схемы рекурсии**. Но сюда также относят и другие операции, например:
- свёртка двух, или более рекурсивных структур за раз;
- пересвёртки с промежуточным преобразованием посередине (`map`, `flatMap`);
- преобразования вида `μ[F] => μ[G]` (дерево в список и т.п.).
Но все эти схемы так или иначе *опираются на всё те же универсальные свойства наибольшей и наименьшей неподвижных точек конструкторов типов – функции `fold` и `unfold`*.

Больше о схемах рекурсии можно узнать тут:
- [Awesome Recursion Schemes](https://github.com/passy/awesome-recursion-schemes) библиография
- [Paramorphism](https://github.com/softwaremill/recursion-training?tab=readme-ov-file#paramorphism) (GitHub)
- [Introduction to Recursion Schemes with Matryoshka](https://akmetiuk.com/posts/2017-03-10-matryoshka-intro/)
- [matryoshka](https://github.com/xuwei-k/matryoshka) (GitHub)
- [Recursion Schemes: A Field Guide (Redux)](http://comonad.com/reader/2009/recursion-schemes/ "Permanent Link: Recursion Schemes: A Field Guide (Redux)") перечень схем со ссылками на Haskell-примеры
- [Recursion Schemes in Scala - An Absolutely Elementary Introduction](https://free.cofree.io/2017/11/13/recursion/) (Цзыян Лю)
- [Catamorphisms](https://wiki.haskell.org/Catamorphisms) (wiki.haskell) любопытная статья
- [An introduction to recursion schemes](https://nrinaudo.github.io/articles/recschemes.html) Николя Ринаудо [слайды](https://nrinaudo.github.io/recursion-schemes-from-the-ground-up/#1)
- [AST playground: recursion schemes and recursive data](https://kubuszok.com/2019/ast-playground-recursion-schemes-and-recursive-data/ "AST playground: recursion schemes and recursive data") (Кубужок)


