

<anchor>free</anchor>

#### Свободный контейнер

Выше были представлены общие свойства неподвижных точек, применяемых к произвольным ковариантным конструкторам типов непосредственно. Здесь рассмотрим чуть более сложные неподвижные точки, когда произвольный целевой контейнер предварительно оборачивается в другую конструкцию.

Неподвижная точка, принимая конструктор типов, возвращает простой тип – как бы «понижает арность». Если же «повысить арность» исходного контейнера, использовав его в выражении с дополнительным свободным параметром, то неподвижная точка как бы «восстановит арность», формируя тем самым преобразователь произвольного контейнерного типа в некий другой. Рассмотрим такой пример:
```scala
type CoEnv[E, F[_]] = [X] =>> E Either F[X]  // устоявшееся название
```
Конструктор типов `CoEnv` параметризирован помимо контейнерного `F[_]` ещё двумя простыми типами `E` и `X`. «Унарный» `F[_]` он превращает в «бинарный» `ConEnv[_, F][_]`, неподвижной точной которого будет снова «унарный» контейнер:
```scala
type Free[F[_]] = [A] =>> μ[CoEnv[A, F]] // A Either F[Free[F, A]]
```
Ввиду ковариантности `F[_]` и универсального свойства суммы типов, контейнер `Free[F][_]` можно представить в виде такой бесконечной суммы:

$$
Free[F][A] = A + F[A + F[A + \ldots]] \cong A + F[A] + F[F[A]] + \ldots
$$

Не сложно убедиться, что рекурсивный контейнер `Free[F][_]` также является ковариантным:
```scala
given liftForCoenv[F[_]: Lift, A]: Lift[CoEnv[A, F]] =
  [X, Y] => (f: X => Y) => (fx: CoEnv[A, F][X]) => fx.map(_ map f)

def liftFreeAlg[F[_]: Lift, A, B](f: A => B): Algebra[CoEnv[A, F]][Free[F][B]] =
  _.left.map(f).pipe(inFix[μ, CoEnv[B, F]])
given liftForFree[F[_]: Lift]: Lift[Free[F]] = [A, B] => (f: A => B) =>
  foldFix[μ][CoEnv[A, F]](liftFreeAlg(f))
```

 У нас есть два основных конструктора для `Free`:
```scala
def pureFree[F[_]: Lift] = [A] => ( a:           A  ) => inFix[μ, CoEnv[A, F]](Left ( a))
def bindFree[F[_]: Lift] = [A] => (fa: F[Free[F][A]]) => inFix[μ, CoEnv[A, F]](Right(fa))
```
Чистые значения можно «освободить» с помощью `pureFree`,  а запакованные в `F[_]` – «поднять в свободный мир» посредством `liftFree`:
```scala
def liftFree[F[_]: Lift] = [A] => (fa: F[A ]) => bindFree[F][A](fa map pureFree[F][A])
```

Распаковка свободного контейнера – это обычная свёртка:
```scala
def convertAlgebra[F[_]: Lift, A]: Algebra[F][A] => Algebra[CoEnv[A, F]][A] =
  alg => {_.fold(identity, alg)}

def goFree[F[_]: Lift, A]: Algebra[F][A] => Algebra[Free[F]][A] =
  convertAlgebra[F, A] andThen foldFix[μ][CoEnv[A, F]][A]

val freeVal: Free[Option][Int] = liftFree(Option(42))
goFree[Option, Int](_.get)(freeVal) // 42: Int
```

Самой же интересной возможностью `Free[F]` является «разматрёшивание» для *любого* ковариантного `F[_]`:
```scala
def flattenFree[F[_]: Lift, A]: Free[F][Free[F][A]] => Free[F][A] =
  foldFix[μ][CoEnv[Free[F][A], F]](_.fold(identity, bindFree[F][A]))

given freeMonad[F[_]: Lift]: Monad[Free[F]] = Monad[Free[F]](
  pure    = pureFree,
  flatten = [X] => (ffx: Free[F][Free[F][X]]) => flattenFree(ffx)
)
```

Таким образом, из «эффективных» функций вида `A => F[B]`, всегда можно построить цепочку вычислений, даже если для `F[_]` не определено «разматрёшивание»! Достаточно на каждом шаге вычислений «поднимать» результат `F[X]` до `Free[F][X]`, композировать вычисления, посредством `liftFree` и `freeMonad` (`flatMap`), в итоге получая результат `Free[F][Result]`. И только в самом конце, при распаковке, потребуется F-алгебра `F[Result] => Result`.

- nLab - круто, но сложновато [transfinite construction of free algebras](https://ncatlab.org/nlab/show/transfinite+construction+of+free+algebras)





<anchor>freer</anchor>

#### Более свободный контейнер

Для работы с контейнером `Free[F][_]` требуется доказательство ковариантности `F[_]`, которое представляет собой реализацию метода `map`. Больше интересных возможностей даёт «более свободный» контейнер `Freer[F][_]` для которого ковариантность `F[_]` необязательна:
```scala
enum   Freer  [F[_], A]:
  case Pure   [F[_], A]   (a: A)                                   extends Freer[F, A]
  case Suspend[F[_], A]   (a: F[Freer[F, A]])                      extends Freer[F, A]
  case FlatMap[F[_], A, B](fb: Freer[F, B], afb: B => Freer[F, A]) extends Freer[F, A]

extension [F[_], A](ffa: Freer[F, A])
  def map    [B](f: A =>          B ): Freer[F, B] = Freer.FlatMap(ffa, f andThen Pure.apply)
  def flatMap[B](f: A => Freer[F, B]): Freer[F, B] = Freer.FlatMap(ffa, f                   )
```
Для композиции вычислений теперь вообще не требуются никакие возможности `F[_]`!

Представить `Freer[F][_]` в виде неподвижной точки какого-либо конструктора типов оказывается не так-то просто… Дело в том, что из-за `FlatMap[F[_], A, B]` этот контейнер представляет собой *список преобразований*, причём каждый элемент этого списка *типизирован по-своему*. Такой разнородный список относится к частному случаю *зависимых типов*, а эта тема выходит за рамки данной статьи.

Тем не менее, `Freer[F][_]` открывает замечательные возможности. С ним можно описать бизнес-эффекты как *обобщённые алгебраические типы* (GADT) вида `SomeBuisenessEffect[_]`, и скомбинировать их посредством `Freer`, получая *программу-как-данные* – ту самую ленивую последовательность вычислений. Интерпретация такой программы производится *в самом конце* в любой удобный контейнер эффектов `G[_]`, если для него предоставлены монадные возможности и «естественное преобразование» `SomeBuisenessEffect ~> G`:
```scala
extension [F[_], A](ffa: Freer[F, A])
  def foldMap[G[_]: Monad](interprete: F ~> G): G[A] = ffa match
    case Return(a)      => Monad[G].pure(a)
    case Suspend(ma)    => interprete(ma).flatMap(_ foldMap interprete)
    case FlatMap(fa, f) => fa.foldMap(interprete).flatMap(f(_) foldMap interprete)
```

Больше подробностей, а также примеры использования таких контейнеров можно найти [в предыдущей статье](https://habr.com/ru/articles/807495/#free). В дополнение упомянутых там источников рекомендую также [эту подборку ссылок](https://github.com/mtumilowicz/scala-cats-free-monad-workshop).

«Более свободный» контейнер встречается, например, в библиотеках [Cats](https://typelevel.org/cats/datatypes/freemonad.html) и [Scalaz](https://eed3si9n.com/learning-scalaz/Free+Monad.html) в под именем `Free`. Построение на его основе программных продуктов требует перед исполнением (интерпретацией) «свободной» программы сперва собрать эту самую программу как некое значение. Этот «лишний шаг» влечёт не то чтобы большие, но системные издержки по производительности, поэтому такой подход используется редко. Но сама идея «ленивого списка преобразований» эксплуатируется достаточно часто, в том числе и для бесстековой обработки рекурсии, о которой расскажем далее.



<anchor>trampolines</anchor>

#### Батуты

У англоязычных коллег повторение действий ассоциируется с прыжками на батуте, когда один прыжок порождает последующие. По этой причине способ защиты от переполнения стека посредством рекурсивных типов носит название «*trampoline*» (батут).

Первым примером послужит обобщённый контейнер `TailRec` из пакета [TailCalls](https://www.scala-lang.org/api/3.x/scala/util/control/TailCalls$.html) стандартной библиотеки Scala:
```scala
sealed abstract class TailRec[+A   ]{ ... }
protected case  class Call   [ A   ](rest: () => TailRec[A])            extends TailRec[A]
protected case  class Done   [ A   ](value: A)                          extends TailRec[A]
protected case  class Cont   [ A, B](a: TailRec[A], f: A => TailRec[B]) extends TailRec[B]
```
Видно, что по структуре он сильно напоминает `Freer`, и это неспроста. Пожалуй, все трамплины оказываются изоморфны такому «более свободному» контейнеру:
```scala
type TrampolineBase[A] = () => A // TrampolineBase[A] ≅ A¹ ≅ A
type Trampoline[A] = Freer[TrampolineBase, A]
```
«База» трамплина `TrampolineBase[_]` изоморфна тривиальному `Id[A] = A`, но отличается семантикой «ленивого вычисления». Это вычисление не обязательно вызывать сразу, его можно передать как аргумент в другую функцию и лишь там принять решение, запускать ли его, и сколько раз. `Freer` позволяет размещать список отложенных вычислений в *куче*, которая значительно больше чем стек. В дальнейшем этот список можно свернуть с помощью всё той же компиляторной оптимизации хвостовой рекурсии.

Трамплины удобны, в частности, для обслуживания косвенной рекурсии, которую компилятор не в состоянии оптимизировать автоматически. Вот пример использования `TailRec`:
```scala
import scala.util.control.TailCalls.*

val even: Int => TailRec[Boolean] =
  case 0 => done(true)
  case i => tailcall(odd(i - 1))

val odd: Int => TailRec[Boolean] =
  case 0 => done(false)
  case i => tailcall(even(i - 1))

even(1234567).result // true
```
При вычислении метода `reult` хвостовая рекурсия оптимизируется компилятором.

Чаще в качестве примера батута называют контейнер `Eval[_]` [из библиотеки Cats](https://typelevel.org/cats/datatypes/eval.html). Он аналогичен `TailRec`, но дополнен эффектом «запоминания» (memoization), позволяющим вычислять «запакованное значение» лишь при *первой* распаковке контейнера, что нам сейчас не интересно в контексте изучения батутов. Вот как можно реализовать стекобезопасное вычисление чисел Фибоначчи посредством `Eval`:
```scala
def fib(n: Int, a: Long = 0, b: Long = 1): Eval[Long] =
  Eval.always(a + b)          // ленивое вычиление
    .flatMap { b2 =>          // аналог tailcall
      if (n > 0) fib(n - 1, b, b2)
      else       Eval.now(a)  // жадное вычисление константы))
    }

fib(10).value // 55
```
Может показаться, что вся магия оптимизации хвостовой рекурсии заключается здесь в наличии возможности `flatMap`. Но требуется не только наличие, но и «ленивость» *конкретной* реализации `flatMap`, которая, как правило, определяется структурой контейнерного типа.

Продемонстрируем это на примере такой функции:
```scala
import cats.Moand
import cats.syntax.all.*

def tailRecM[F[_]: Monad, A, B](f: A => F[Either[A, B]]): A => F[B]
  = (a: A) => f(a)
	.flatMap(_.fold(
	  tailRecM(f), // рекурсия
	  cats.Monad[F].pure
	))
```
Это типичный унаследованный от Haskell механизм реализации рекурсии с использованием монадических возможностей некого контейнера `F[_]`. Однако такая универсальная реализация подойдёт вовсе не для любого контейнера:
```scala
def evenBase: Int => Either[Int, Boolean] = 
  case        0   => true   .asRight
  case        1   => false  .asRight
  case        x   => (x - 2).asLeft

def evenId   = tailRecM[  Id, Int, Boolean](         evenBase   ) 
def evenEval = tailRecM[Eval, Int, Boolean](Eval now evenBase(_))

evenEval(1234567).value // false
evenId  (1234567)       // StackOverflowException
```
«Ленивый» `Eval` отрабатывает без проблем, тогда как «жадная» реализация `flatMap` для `Id` приводит к переполнению стека. Однако метод `tailRecM` из встроенной в Cats реализации класса типов `Monad[Id]` работает без ошибок:
```scala
Monad[Id].tailRecM(1234567)(evenBase) // false
```
Фокус в том, что `tailRecM` из `cats.Monad[Id]` реализован неуниверсально, а специфично для `Id`, через оптимизацию хвостовой рекурсии (и аннотацию `@tailrec`). Впрочем, в этой библиотеке аналогичным способом записаны `tailRecM` и для других стандартных контейнеров.

Стоит упомянуть ещё одну реализацию батута из библиотеки Cats.Effect – контейнер произвольных побочных эффектов [IO](https://typelevel.org/cats-effect/docs/datatypes/io). Секрет его универсальности как раз и заключается в том, что он по сути представляет собой рекурсивный свободный контейнер, «чисто» накапливающий в себе последовательность «эффективных преобразований». Контейнер `IO[_]` также аналогичен введённому ранее `Trampoline[_]`, но дополнен многочисленными возможностями. В частности, в `IO` встроен механизм обработки ошибок, что делает его больше похожим на такой тип:
```scala
type IO[A] = Freer[[X] =>> () => Try[X], A]
```

Да, `IO[_]` – это самый настоящий свободный контейнер, который может быть интерпретирован в конце программы в любой другой: `Id`, `Either`, `Future`, `ZIО`… Его можно использовать в качестве батута по аналогии с `Eval[_]`, обращаясь к методам `flatMap` и `tailRecM`, но пожалуй чаще всего в продуктовом коде используется метод `foreverM`:
```scala
extension [F[_]: Monad, A] (fa: F[A])
  def foreverM: F[Nothing] =
    Monad[F].tailRecM(())(_ => fa as Left(()))
```
Метод зацикливает указанный эффект, что бывает полезно при организации действий через какие-то промежутки времени пока приложение запущено.


- [Зачем в Scala трамплины и как их использовать / Хабр](https://habr.com/ru/companies/kryptonite/articles/796433/) (продолжения)
- [Taming Cats - Eval](https://plippe.github.io/blog/2018/12/01/taming-cats-eval.html) в блоге Ифлиппа Хози-Винчона
- [Tail Recursive Monads (FlatMap)](https://eed3si9n.com/herding-cats/tail-recursive-monads.html) (herding cats)
- [Stackless Scala With Free Monads](https://blog.higher-order.com/assets/trampolines.pdf)(pdf) статья Рунара Бьярнасона 
- [Stack Safety for Free](https://functorial.com/stack-safety-for-free/index.pdf) (pdf) статья Фила Фримана



<anchor>cofree</anchor>

#### Ко-свободный контейнер

Полезным оказывается тип, дуальный свободному контейнеру – *ко-свободный контейнер*. Дуальность проявляется в том, что вместо суммы типов теперь произведение, а вместо наименьшей неподвижной точки – наибольшая:
```scala
type CoFreeBase[F[_], A] = [X] =>> (A, F[X]) // A × F[X]
type Cofree[F[_]] = [A] =>> 𝛎[CoFreeBase[F, A]]
```

Конструкция и деконструкция ко-свободного контейнера выполняется стандартными для неподвижных точек методами:
```scala
def unapplyCofree[F[_]: Lift, A] = outFix[𝛎, CoFreeBase[F, A]]
def    pureCofree[F[_]: Lift, A] =  inFix[𝛎, CoFreeBase[F, A]]
```
Деконструктор `unapplyCofree` разбирает Cofree на пару `(A, F[Cofree[F][A]])`. Соответственно, для создания экземпляра с помощью `pureCofree` потребуется, помимо значения `A`, другой ко-свободный контейнер, запакованный в `F[_]`. Это означает, что честно создать экземпляр возможно только в том случае, если для `F[_]` существует конструктор, *не принимающий ни одного аргумента типа своего параметра*; другими словами, если `F[Nothing] ≠ Nothing`. Типичным примером является `Option` с конструктором `None`. Это позволяет создавать типы деревьев и списков, которые могут быть пустыми (конечные структуры данных).

Дуально Free,  ковариантность ко-свободного контейнера демонстрируется посредством развёртки – универсального свойства наибольшей неподвижной точки:
```scala
given liftCofreeBase[F[_]: Lift, X]: Lift[CoFreeBase[F, X]] = 
  [A, B] => (f: A => B) => ((attr: X, prev: F[A]) => attr -> prev.map(f)).tupled

def liftCofreeCoalg[F[_]: Lift, A, B](f: A => B): Coalgebra[CoFreeBase[F, B]][Cofree[F][A]] =
  unapplyCofree[F, A] andThen { (head, tail) => f(head) -> tail }
given liftForCofree[F[_]: Lift]: Lift[Cofree[F]] =
  [A, B] => (f: A => B) => unfoldFix[𝛎][CoFreeBase[F, B]](liftCofreeCoalg(f))
```

В то время как свободный контейнер обладал замечательной возможностью «разматрёшивания», ко-свободный, наоборот, умеет «заматрёшиваться» (`coFlatten`), даже если этого не умеет `F[_]`:
```scala
given comonadCofree[F[_]: Lift]: Comonad[Cofree[F]] =
  def coflattenCoalg[A](cfa: Cofree[F][A]) = unapplyCofree(cfa).copy(_1 = cfa)
  Comonad(
    extract   = [A] => (cfa: Cofree[F][A]) => unapplyCofree(cfa)._1,
    coFlatten = [A] => (cfa: Cofree[F][A]) => unfoldFix[𝛎][CoFreeBase[F, Cofree[F][A]]](coflattenCoalg[A])(cfa)
  )
```

Казалось бы, какая может быть польза от бесконечного роста? Это не совсем очевидно, но далее мы увидим, как это свойство ко-свободного контейнера помогает «заглядывать в прошлое»!

![[Тыквёнок.png|Cofree может показаться бесполезным овощем, но всё же, он умеет РАСТИ!]]


<anchor>histomorphism</anchor>

#### Хистоморфизм

Свободные контейнеры, также как и списки `List`, представляются в виде наименьших неподвижных точек. Для них важна прежде всего свёртка, когда сперва обрабатывается текущее значение `head`, а затем все *последующие* (`tail`). В свою очередь, ко-свободный контейнер, так же как, например, потоки `Stream` или ленивые списки `LazyList`, являются наибольшими неподвижными точками, нацеленными на развёртку, рост. На такие структуры можно смотреть как на пару текущего значения `head` и всех *предыдущих* (`prev`), которые были «развёрнуты» ранее.

В процессе свёртки наименьшей неподвижной точки мы шаг за шагом получаем промежуточные результаты и иногда встречаются задачи, когда оказывается полезным подсмотреть, что же было вычислено на предыдущих шагах. Заглянуть в прошлое нам поможет схема рекурсии с названием «*хистоморфизм*», использующая `Cofree`:
```scala
extension [F[_]: Lift, X](cof: Cofree[F][X])  
  def current  = unapplyCofree[F, X](cof)._1  
  def previous = unapplyCofree[F, X](cof)._2

def cofreeAlgToFAlg[F[_]: Lift, X]: Algebra[F ∘ Cofree[F]][X] => Algebra[F][Cofree[F][X]] =
  alg => fcof => pureCofree(alg(fcof), fcof) // outFix[𝛎]

def histo[Fix[_[_]]: Fold, F[_]: Lift, X]: Algebra[F ∘ Cofree[F]][X] => Fix[F] => X =
  cofreeAlgToFAlg(_) pipe foldFix[Fix][F][Cofree[F][X]] andThen {_.current}
```

Хистоморфизм может быть использован и в чистом виде, но чаще он комбинируется с анаморфизмом, образуя такую пересвёртку:
```scala
def dynamo[Fix[_[_]]: Fold: Unfold, F[_]: Lift, A, B](
  coalg     : Coalgebra[F][A],
  histoAlg  : Algebra[F ∘ Cofree[F]][B]
): A => B =
  unfoldFix[Fix][F][A](coalg) andThen histo(histoAlg) // ana >>> histo
```

Продемонстрируем работу этого *динамоморфизма* на примере вычисления последовательности Фибоначчи:
```scala
def fibonacci: Int => Int = dynamo[μ, Option, Int, Int](
  i => Option.when(i > 1)(i - 1),  // коалгебра для развёртки последовательноти натуральных чисел
  _.flatMap{ last => last.previous.map(prev => last.current + prev.current) }.getOrElse(1)
) //         если ранее уже посчитаны двое, то   последнее  +  предыдущее      иначе    1

fibonacci(10) // 55 - десятое число последовательности Фибоначчи
```

Таким образом, хистоморфизм может быть использован при вычислении членов последовательности, порождаемых рекурсивных выражениями, когда последующие члены зависят от предыдущих. Впрочем, применительно именно к последовательности Фибоначчи удобнее оказываются параморфизм, или даже обычная свёртка (катаморфизм) из предыдущих частей данного обзора.

Название «динамоморфизм» обусловлено тем, что изначально он предназначался для решения задач [динамического программирования](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). При решении таких задачах сперва производится декомпозиция на мелкие подзадачки (развёртка), затем они решаются последовательно, *с использованием результатов уже решённых подзадач* (свёртка с Cofree – хистоморфизм). На Хабре есть [неплохая статья о динамическом программировании](https://habr.com/ru/articles/777618/) с примерами на Python.




<anchor>futumorphism</anchor>

#### Футуморфизм




- [Histomorphism, Dynamorphism, Futumorphism](https://free.cofree.io/2017/11/13/recursion/#histomorphism) (Scala) Блог Цзияна Лю.
- [Recursion Schemes, Part IV: Time is of the Essence](http://blog.sumtypeofway.com/recursion-schemes-part-iv-time-is-of-the-essence/) (Haskell) в блоге Патрика Томпсона
- [Time Traveling Recursion Schemes](https://jtobin.io/time-traveling-recursion) (Haskell) Джаред Тобин.