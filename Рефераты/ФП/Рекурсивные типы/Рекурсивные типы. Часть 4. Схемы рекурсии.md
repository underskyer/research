–í—Å–µ —á–∞—Å—Ç–∏ –æ–±–∑–æ—Ä–∞:
- <a href="#recursion">–ß–∞—Å—Ç—å 1. –†–µ–∫—É—Ä—Å–∏—è</a>.
- <a href="#recursion">–ß–∞—Å—Ç—å 2. –ù–µ–ø–æ–¥–≤–∏–∂–Ω—ã–µ —Ç–æ—á–∫–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤ —Ç–∏–ø–æ–≤</a>.
- <a href="#lambda_calcs">–ß–∞—Å—Ç—å 3. –°–≤–æ–±–æ–¥–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã</a>.
- <a href="#lambda_calcs">–ß–∞—Å—Ç—å 4. –°—Ö–µ–º—ã —Ä–µ–∫—É—Ä—Å–∏–∏</a> (–º—ã –∑–¥–µ—Å—å).
- <a href="#lambda_calcs">–ß–∞—Å—Ç—å 5. –ó–∞–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã–π –º–∞—Ç–∞–Ω</a>.



<anchor>motivation</anchor>

#### –ü—Ä–∏–º–µ—Ä –¥–ª—è –º–æ—Ç–∏–≤–∞—Ü–∏–∏

–°–≤—ë—Ä—Ç–∫–∞ –∏ —Ä–∞–∑–≤—ë—Ä—Ç–∫–∞ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω—ã—Ö —Ç–æ—á–µ–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤ —Ç–∏–ø–æ–≤ –ø–æ–∫—Ä—ã–≤–∞–µ—Ç –º–Ω–æ–≥–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏, –≥–¥–µ –ø—Ä–∏—Ö–æ–¥–∏–ª–æ—Å—å –±—ã –≤—Ä—É—á–Ω—É—é –ø–∏—Å–∞—Ç—å —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –Ω–æ –∏–Ω–æ–≥–¥–∞ —ç—Ç–æ–≥–æ –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ.  –†–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–∏–º–µ—Ä.

–í –Ω–µ–∫–æ—Ç–æ—Ä–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–∞–±–æ—Ç–Ω–∏–∫–∞ –∑–∞–¥–∞–Ω –æ–±–æ–±—â—ë–Ω–Ω—ã–π –ø–µ—Ä–µ—á—å –∞—Ç—Ä–∏–±—É—Ç–æ–≤:
```scala
type EmployerAttributes[A] = (Employer, List[A])
```
–û–¥–Ω–∏–º–∏ –∏–∑ —Ç–∞–∫–∏—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤ —è–≤–ª—è—é—Ç—Å—è –ø–æ–¥—á–∏–Ω—ë–Ω–Ω—ã–µ ‚Äì —Ç–∞–∫–∏–µ –∂–µ —Ä–∞–±–æ—Ç–Ω–∏–∫–∏ –∫–æ–º–ø–∞–Ω–∏–∏. –§–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –∏–µ—Ä–∞—Ä—Ö–∏—è —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤, –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ –∑–∞–ø–∏—Å–∞—Ç—å –ø–æ—Å—Ä–µ–¥—Å—Ç–≤–æ–º –Ω–∞–∏–º–µ–Ω—å—à–µ–π –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏:
```scala
type Hierarchy = Œº[EmployerAttributes]
```

–°—Ç–æ–∏—Ç –∑–∞–¥–∞—á–∞ ‚Äì –∏–º–µ—è –ø–æ–ª–Ω—É—é –∏–µ—Ä–∞—Ä—Ö–∏—é –Ω–∞—É—á–∏—Ç—å—Å—è –Ω–∞—Ö–æ–¥–∏—Ç—å –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Ä–∞–±–æ—Ç–Ω–∏–∫–∞ –≤—Å–µ—Ö –µ–≥–æ –ø–æ–¥—á–∏–Ω—ë–Ω–Ω—ã—Ö. –¢–∞–∫—É—é —Ñ—É–Ω–∫—Ü–∏—é –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ:
```scala
def findSubordinates(employer: Employer)(hierarchy: Hierarchy): Option[Hierarchy] =
  val (empl, subrordinates) = outŒº(hierarchy) //     –æ—Ç–¥–∞—ë—Ç—Å—è –∏–µ—Ä–∞—Ä—Ö–∏—è ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞
  Option //                 ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –≤—Å—è —Ç–µ–∫—É—â–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è
    .when(empl == employer)(hierarchy)
    .orElse(subrordinates.flatMap(findSubordinates(employer)).headOption)
    //                            ‚Üë‚Üë‚Üë‚Üë—Ä–µ–∫—É—Ä—Å–∏—è‚Üë‚Üë‚Üë‚Üë
```
–î–ª—è –≤—ã–∑–æ–≤–∞ `outŒº` –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –∫–æ–≤–∞—Ä–∏–∞–Ω—Ç–Ω–æ—Å—Ç–∏ `EmployerAttributes`:
```scala
given Lift[EmployerAttributes] = [A, B] => (f: A => B) =>
  (aLst: EmployerAttributes[A]) => aLst._1 -> aLst._2.map(f)
```

–ü—É—Å—Ç—å —É –Ω–∞—Å –µ—Å—Ç—å —Ç–∞–∫–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∫–æ–º–ø–∞–Ω–∏–∏:
```scala
type Employer = String

val hierarchy: Hierarchy = inŒº("–ë—É–≥–æ—Ä", //      –ë—É–≥–æ—Ä
  List(inŒº("–ü–µ—Ç—è",                      //       /
    List(inŒº("–í–∞–Ω—è", Nil), inŒº("–ú–∞—à–∞",  //     –ü–µ—Ç—è
      List(inŒº("–í–∞—Å—è", Nil))            //     /  \
	))                                  //  –í–∞–Ω—è  –ú–∞—à–∞
  ))                                    //       /
)                                       //     –í–∞—Å—è

val employerStringAlg: Algebra[EmployerAttributes][String] =
  attrs => attrs._1 + attrs._2.mkString(": (", ", ", ")")

foldŒº(employerStringAlg)(hierarchy)     // "–ë—É–≥–æ—Ä: (–ü–µ—Ç—è: (–í–∞–Ω—è: (), –ú–∞—à–∞: (–í–∞—Å—è: ())))"
```
–¢–æ–≥–¥–∞ –Ω–∞–π—Ç–∏ –ø–æ–¥—á–∏–Ω—ë–Ω–Ω—ã—Ö —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞ –º–æ–∂–Ω–æ —Ç–∞–∫:
```scala
findSubordinates("–ü–µ—Ç—è")(hierarchy)     // Some(–ü–µ—Ç—è: (–í–∞–Ω—è: (), –ú–∞—à–∞: (–í–∞—Å—è: ())))
findSubordinates("–í–∞—Å—è")(hierarchy)     // Some(–í–∞—Å—è: ())
findSubordinates("–ö–∞—Ç—è")(hierarchy)     // None
```

–ü—Ä–∏–º–µ–Ω—è—Ç—å –¥–ª—è —Ç–µ—Ö –∂–µ —Ü–µ–ª–µ–π —Ñ—É–Ω–∫—Ü–∏—é —Å–≤—ë—Ä—Ç–∫–∏, –æ–ø–∏—Å–∞–Ω–Ω—É—é —Ä–∞–Ω–µ–µ, –≤–µ—Å—å–º–∞ –Ω–µ —É–¥–æ–±–Ω–æ. –ü—Ä–æ–±–ª–µ–º–∞ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –ø—Ä–æ—Å—Ç–∞—è —Å–≤—ë—Ä—Ç–∫–∞ –æ–ø–µ—Ä–∏—Ä—É–µ—Ç F-–∞–ª–≥–µ–±—Ä–æ–π, –∫–æ—Ç–æ—Ä–∞—è –≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ —Ä–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ `Employer`, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–æ–≥–¥–∞ –Ω–∞–º –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ `findSubordinates` —Ç—Ä–µ–±—É–µ—Ç—Å—è –∫–∞–∫ —Ä–∞–±–æ—Ç–Ω–∏–∫, —Ç–∞–∫ –∏ –≤—Å—è –∏–µ—Ä–∞—Ä—Ö–∏—è –µ–≥–æ –ø–æ–¥—á–∏–Ω—ë–Ω–Ω—ã—Ö. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –Ω–∞–º —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥—Ä—É–≥–∞—è —Å–≤—ë—Ä—Ç–∫–∞, —Å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–π –∞–ª–≥–µ–±—Ä–æ–π.



<anchor>generalization</anchor>

#### –û–±–æ–±—â–µ–Ω–∏–µ —Å–≤—ë—Ä—Ç–æ–∫/—Ä–∞–∑–≤—ë—Ä—Ç–æ–∫

–ö–∞–∫ –º–æ–∂–Ω–æ –æ–±–æ–±—â–∏—Ç—å F-–∞–ª–≥–µ–±—Ä—É –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –µ—ë –ø—Ä–∏ —Å–≤—ë—Ä—Ç–∫–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä? –û—Å–Ω–æ–≤–Ω–∞—è –∑–∞–¥–∞—á–∞ –∞–ª–≥–µ–±—Ä—ã ‚Äì —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ–∫–æ–≥–æ —Ç–∏–ø–∞ `X` –∏–∑ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ `F`. –ü–æ—ç—Ç–æ–º—É, –ø–æ–∂–∞–ª—É–π, –≤ –Ω–∞–∏–±–æ–ª–µ–µ –æ–±—â–µ–º –≤–∏–¥–µ —Ç–∞–∫–∏–º–∏ –∞–ª–≥–µ–±—Ä–∞–º–∏ –±—É–¥—É—Ç –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –≤–∏–¥–∞
```scala
//              Algebra                   = [F[_]] =>> [X] =>>   F[  X ]  =>   X
type GeneralizedAlgebra[W[_], G[_], M[_]] = [F[_]] =>> [X] =>> W[F[G[X]]] => M[X]
```
–ù–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –ø–æ–Ω–∏–º–∞–Ω–∏—è –º–æ–∂–Ω–æ –¥–µ–∫–æ–º–ø–æ–∑–∏—Ä–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –Ω–∞ —Ç—Ä–∏ —á–∞—Å—Ç–Ω—ã—Ö —Å–ª—É—á–∞—è:
```scala
type     GAlgebra [G[_]] = [F[_]] =>> [X] =>> F[G[X]] =>   X
type ElgotAlgebra [W[_]] = [F[_]] =>> [X] =>> W[F[X]] =>   X // –∞–ª–≥–µ–±—Ä—ã –≠–ª–≥–æ—Ç–∞
type      AlgebraM[M[_]] = [F[_]] =>> [X] =>>   F[X]  => M[X]
```

–í –æ—Å–Ω–æ–≤–µ –ª—é–±–æ–π —Å–≤—ë—Ä—Ç–∫–∏ –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –ª–µ–∂–∏—Ç –≤—Å—ë —Ç–æ—Ç –∂–µ –±–∞–∑–æ–≤—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º `fold`, –æ–ø–∏—Å–∞–Ω–Ω—ã–π —Ä–∞–Ω–µ–µ. –°–µ–∫—Ä–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö –∞–ª–≥–µ–±—Ä –≤ —Ç–µ—Ö –∂–µ —Ü–µ–ª—è—Ö –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ –∏—Ö –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–∏ –∫ –æ–±—ã—á–Ω–æ–π F-–∞–ª–≥–µ–±—Ä–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–π –≤ `fold`. –î–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç–∞–∫–æ–≥–æ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–Ω—ã—Ö —Ç–∏–ø–æ–≤. –ü–æ–∂–∞–ª—É–π, –Ω–∞–∏–±–æ–ª–µ–µ –≤–∞–∂–Ω–æ–π —Å—Ä–µ–¥–∏ –Ω–∏—Ö —è–≤–ª—è–µ—Ç—Å—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ —ç—Ç–∏—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ —Å `F[_]` (**–¥–∏—Å—Ç—Ä–∏–±—É—Ç–∏–≤–Ω—ã–π –∑–∞–∫–æ–Ω**). –í–≤–µ–¥—ë–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è:
```scala
type ~>[F[_], G[_]] = [X] => F[X] => G[X]   // –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ (–ø–æ—á—Ç–∏)
type ‚àò [F[_], G[_]] = [X] =>> F[G[X]]       // –∫–æ–º–ø–æ–∑–∏—Ü–∏—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
type ‚áÑ[F[_], G[_]] = (F ‚àò G) ~> (G ‚àò F)     // —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ, –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
def swap[F[_], G[_]](using sw: F ‚áÑ G) = sw // [X] => F[G[X]] => G[F[X]]
```
–¢–∞–∫–∂–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –æ–ø—Ä–µ–¥–µ–ª–∏–º —Å–ª–µ–¥—É—é—â–∏–µ –∫–ª–∞—Å—Å—ã —Ç–∏–ø–æ–≤:
```scala
type SwapOut[F[_]] = [G[_]] =>> F ‚áÑ G     // –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –Ω–∞—Ä—É–∂—É
type SwapIn [F[_]] = [G[_]] =>> G ‚áÑ F     // –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–Ω–µ—à–Ω–µ–≥–æ –≤–Ω—É—Ç—Ä—å
```

–ï—â—ë –Ω—É–∂–Ω—ã –±—É–¥—É—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ ¬´—Ä–∞–∑–º–∞—Ç—Ä—ë—à–∏–≤–∞–Ω–∏—è¬ª –∏ ¬´–∑–∞–º–∞—Ç—Ä—ë—à–∏–≤–∞–Ω–∏—è¬ª –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤. –í–æ–æ–±—â–µ, –ø–æ–Ω—è—Ç–∏—è ¬´–º–æ–Ω–∞–¥—ã¬ª –∏ ¬´–∫–æ–º–æ–Ω–∞–¥—ã¬ª –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω—ã –∏–∑ *—Ç–µ–æ—Ä–∏–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π*, –∏ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ —Ä–∞–º–∫–∏ –¥–∞–Ω–Ω–æ–≥–æ –æ–±–∑–æ—Ä–∞. –ü–æ—ç—Ç–æ–º—É —Ç—É—Ç –≤–≤–µ–¥—ë–º –∏—Ö –±–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤:
```scala
case class Monad[F[_]: Lift]( // —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –∫–æ–≤–∞—Ä–∏–∞–Ω–Ω–æ—Å—Ç–∏ F[_]
  pure:         Id ~> F,
  flatten: (F ‚àò F) ~> F,
) { val lift = summon[Lift[F]] }

given liftFromMoand[F[_]](using m: Monad[F]): Lift[F] = m.lift
def pure    [F[_]: Monad] = summon[Monad[F]].pure
def flatten [F[_]: Monad] = summon[Monad[F]].flatten
def flatFMap[F[_]: Monad] = [A, B] => (f: A => F[B]) => fmap[F](f) andThen flatten[F][B]

extension  [F[_]: Monad, A] (fa: F[A])
  def flatMap[B] = (f: A => F[B]) => flatFMap(f)(fa)
extension  [F[_]: Monad, A, B] (afb: A => F[B])
  def andThenK[C] = (bfc: B => F[C]) => (a: A) => afb(a).flatMap(bfc)


case class Comonad[F[_]: Lift]( // —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –∫–æ–≤–∞—Ä–∏–∞–Ω–Ω–æ—Å—Ç–∏ F[_]
  extract:   F ~> Id,
  coFlatten: F ~> (F ‚àò F),
) { val fmap = summon[Lift[F]] }

given liftFromComoand[F[_]](using cm: Comonad[F]): Lift[F] = cm.fmap
def extract  [F[_]: Comonad] = summon[Comonad[F]].extract
def coFlatten[F[_]: Comonad] = summon[Comonad[F]].coFlatten
def coFlatMap[F[_]: Comonad] = [A, B] => (f: F[A] => B) => coFlatten[F][A] andThen fmap[F](f)
```

–í–æ–æ—Ä—É–∂–∏–≤—à–∏—Å—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏, –≤–æ—Ç —Ç–∞–∫ –º–æ–∂–Ω–æ –∑–∞–ø–∏—Å–∞—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∞–ª–≥–µ–±—Ä
```scala
def gAlgToFAlg[F[_]: Lift, G[_]: Comonad: SwapOut[F], X]:          AlgebraG[G][F][X] => Algebra[F][G[X]]    =
  galg => fmap[F](coFlatten[G][X]) andThen swap[F, G][G[X]] andThen fmap[G](galg)

def elgotAlgToFAlg[F[_]: Lift, W[_]: Comonad: SwapOut[F], X]: ElgotAlgebra [W][F][X] => Algebra[F][W[F[X]]] =
  elgotAlg => fmap(coFlatMap(elgotAlg)) andThen swap[F, W][X]

def algMToFAlg[F[_]: Lift, M[_]: Monad: SwapOut[F], X]:            AlgebraM[M][F][X] => Algebra[F][M[X]]    =
  swap[F, M][X] andThen flatFMap(_)
```
–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –∏–º —Å–≤—ë—Ä—Ç–∫–∏:
```scala
def gFold[Fix[_[_]]: Fold, F[_]: Lift, G[_]: Comonad: SwapOut[F], X]: AlgebraG[G][F][X] => Fix[F] => X =
  gAlgToFAlg(_) pipe foldFix[Fix][F][G[X]] andThen extract[G][X]

def elgotFold[Fix[_[_]]: Fold, F[_]: Lift, W[_]: Comonad: SwapOut[F], X]: ElgotAlgebra[W][F][X] => Fix[F] => X =
  elgotAlg => elgotAlgToFAlg(elgotAlg) pipe foldFix[Fix][F][W[F[X]]] andThen elgotAlg

def foldM[Fix[_[_]]: Fold, F[_]: Lift, M[_]: Monad: SwapOut[F], X]: AlgebraM[M][F][X] => Fix[F] => M[X] =
  algMToFAlg andThen foldFix[Fix][F][M[X]]
```
–ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä `pipe`, –ø–µ—Ä–µ–¥–∞—é—â–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç —Å–ª–µ–≤–∞ –≤ —Ñ—É–Ω–∫—Ü–∏—é —Å–ø—Ä–∞–≤–∞, –¥–æ—Å—Ç—É–ø–µ–Ω –±–ª–∞–≥–æ–¥–∞—Ä—è `import scala.util.chaining.scalaUtilChainingOps`.




<anchor>rec_schemes</anchor>

#### –ü–∞—Ä–∞–º–æ—Ä—Ñ–∏–∑–º –∏ –¥—Ä—É–≥–∏–µ —Å—Ö–µ–º—ã —Ä–µ–∫—É—Ä—Å–∏–∏

 –î–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ –æ –ø–æ–¥—á–∏–Ω—ë–Ω–Ω—ã—Ö –º–æ–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –æ–±–æ–±—â—ë–Ω–Ω—É—é —Å–≤—ë—Ä—Ç–∫—É, –Ω–∞–∑—ã–≤–∞–µ–º—É—é ¬´*–ø–∞—Ä–∞–º–æ—Ä—Ñ–∏–∑–º*¬ª:
```scala
type ParaW[Fix[_[_]]] = [F[_]] =>> [X] =>> (X, Fix[F]) // –ø–æ–º–∏–º–æ –æ–¥–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞, –¥–æ—Å—Ç—É–ø–Ω–∞ –≤—Å—è –æ—Å—Ç–∞–≤—à–∞—è—Å—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
type ParaAlgebra[Fix[_[_]], F[_]] = [X] =>> GAlgebra[ParaW[Fix][F]][F][X]

given paraLift[Fix[_[_]], F[_]]: Lift[ParaW[Fix][F]] =
  [A, B] => (f: A => B) => (pfixfa: ParaW[Fix][F][A]) => f(pfixfa._1) -> pfixfa._2

given paraComonad[Fix[_[_]], F[_]]: Comonad[ParaW[Fix][F]] = Comonad(
  extract   = [X] => (px: (X, Fix[F])) => px._1,
  coFlatten = [X] => (px: (X, Fix[F])) => px -> px._2,
)

given paraSwapOut[Fix[_[_]]: Fold: InFix, F[_]: Lift]: F ‚áÑ ParaW[Fix][F] =
  [X] => (fpara: F[ParaW[Fix][F][X]]) =>
    fpara.map((_: ParaW[Fix][F][X])._1) -> inFix(fpara.map(_._2))

def para[Fix[_[_]]: Fold: InFix, F[_]: Lift, X]: ParaAlgebra[Fix, F][X] => Fix[F] => X =
  gfold[Fix, F, ParaW[Fix][F], X]
```
–¢–µ–ø–µ—Ä—å –≤ –ø–∞—Ä–∞–º–æ—Ä—Ñ–∏–∑–º –º–æ–∂–Ω–æ —Å–ø—Ä—è—Ç–∞—Ç—å –≤—Å—é —Ä–µ–∫—É—Ä—Å–∏—é –∏–∑ –Ω–∞—à–µ–π –∑–∞–¥–∞—á–µ:
```scala
def subordinatesParaAlg(employer: Employer): ParaAlgebra[Œº, EmployerAttributes][Option[Hierarchy]] =
  case (empl, subs) => Option
    .when(empl == employer)(empl -> subs.map(_._2) pipe inFix[Œº, EmployerAttributes])
    .orElse(subs.flatMap(_._1).headOption)

def findSubordinates(employer: Employer): Hierarchy => Option[Hierarchy] =
  para[Œº, EmployerAttributes, Option[Hierarchy]](subordinatesParaAlg(employer))
```

–û–±—ã—á–Ω–∞—è —Å–≤—ë—Ä—Ç–∫–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ-–æ—Ç–¥–µ–ª—å–Ω–æ—Å—Ç–∏. –í —ç—Ç–æ–º —Å–º—ã—Å–ª–µ –µ—ë –∏–Ω–æ–≥–¥–∞ –Ω–∞–∑—ã–≤–∞—é—Ç *–∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–º*. –í —Ç–æ–∂–µ –≤—Ä–µ–º—è –ø–∞—Ä–∞–º–æ—Ä—Ñ–∏–∑–º —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø—Ä–æ–≤–∞–ª–∏–≤–∞–µ—Ç—Å—è –≤–Ω—É—Ç—Ä—å, –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥—É –¥–∞–≤–∞—è –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–π –æ—Å—Ç–∞–≤—à–µ–π—Å—è —Å—Ç—Ä—É–∫—Ç—É—Ä–µ. –ü–æ—ç—Ç–æ–º—É —Ç–∞–∫—É—é —Å–≤—ë—Ä—Ç–∫—É –∏–Ω–æ–≥–¥–∞ –Ω–∞–∑—ã–≤–∞—é—Ç *–ø—Ä–æ—Å—Ç–æ–π —Ä–µ–∫—É—Ä—Å–∏–µ–π* –∏–ª–∏ [—Ä–µ–∫—É—Ä—Å–æ—Ä–æ–º](https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt#:~:text=ITERATORS%20AND%20RECURSORS).

–ü–∞—Ä–∞–º–æ—Ä—Ñ–∏–∑–º –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ–ª–µ–∑–µ–Ω –¥–ª—è —Ä–µ—à–µ–Ω–∏—è —Ü–µ–ª–æ–≥–æ –∫–ª–∞—Å—Å–∞ –∑–∞–¥–∞—á, –∏ –ø–æ —ç—Ç–æ–π –ø—Ä–∏—á–∏–Ω–µ –µ–º—É –ø—Ä–∏—Å–≤–æ–µ–Ω–æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ. –¢–∞–∫–∂–µ —Å–≤–æ–∏ –Ω–∞–∑–≤–∞–Ω–∏—è –∏–º–µ—é—Ç –∏ —Å–≤—ë—Ä—Ç–∫–∏, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –¥—Ä—É–≥–∏—Ö —á–∞—Å—Ç–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö –∞–ª–≥–µ–±—Ä. –ù–∞–ø—Ä–∏–º–µ—Ä, –æ–±—ã—á–Ω–∞—è —Å–≤—ë—Ä—Ç–∫–∞ `fold` —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è *–∫–∞—Ç–∞–º–æ—Ä—Ñ–∏–∑–º–æ–º* (`cata`). –ù–∞–∑–≤–∞–Ω–∏—è –∑–∞—á–∞—Å—Ç—É—é –∑–∞–∏–º—Å—Ç–≤—É—é—Ç—Å—è –∏–∑ –≥—Ä–µ—á–µ—Å–∫–æ–≥–æ —è–∑—ã–∫–∞.

–°—Ö–æ–∂–∏–º –æ–±—Ä–∞–∑–æ–º —Å—Ç—Ä–æ—è—Ç—Å—è –∏ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ä–∞–∑–≤—ë—Ä—Ç–∫–∏. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ –∫–æ–∞–ª–≥–µ–±—Ä—ã –ø—Ä–∏–≤–æ–¥—è—Ç—Å—è –∫ –æ–±—ã—á–Ω—ã–º, –¥–ª—è —á–µ–≥–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–∞–∫–∏–µ –∂–µ –º–æ–Ω–∞–¥–Ω—ã–µ –∏ –∫–æ–º–æ–Ω–∞–¥–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–Ω—ã—Ö —Ç–∏–ø–æ–≤, –∞ —Ç–∞–∫–∂–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Ö –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å —Ü–µ–ª–µ–≤—ã–º `F[_]`. –£ –º–Ω–æ–≥–∏—Ö –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ä–∞–∑–≤—ë—Ä—Ç–æ–∫ —Ç–∞–∫–∂–µ —É—Å—Ç–æ—è–ª–∏—Å—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è. –ù–∞–ø—Ä–∏–º–µ—Ä, –æ–±—ã—á–Ω—ã–π `unfold` –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è *–∞–Ω–∞–º–æ—Ä—Ñ–∏–∑–º–æ–º* (`ana`), –∞ —Ä–∞–∑–≤—ë—Ä—Ç–∫–∞, –¥—É–∞–ª—å–Ω–∞—è –ø–∞—Ä–∞–º–æ—Ä—Ñ–∏–∑–º—É ‚Äì *–∞–ø–æ–º–æ—Ä—Ñ–∏–∑–º–æ–º* (`apo`).

–ë–µ–∑ —Å–≤–æ–∏—Ö –∏–º—ë–Ω –Ω–µ –æ—Å—Ç–∞–ª–∏—Å—å –∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ—Å–≤—ë—Ä—Ç–∫–∏ (`refold`). –í —á–∞—Å—Ç–Ω–æ—Å—Ç–∏, –∫–∞—Ç–∞–º–æ—Ä—Ñ–∏–∑–º –ø–æ—Å–ª–µ –∞–Ω–∞–º–æ—Ä—Ñ–∏–∑–º–∞ –æ–±—Ä–∞–∑—É—é—Ç *—Ö–∏–ª–æ–º–æ—Ä—Ñ–∏–∑–º* (`hylo`). –í–æ—Ç –∫–∞–∫ —á–µ—Ä–µ–∑ –Ω–µ–≥–æ –≤—ã—Ä–∞–∂–∞–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª–∞:
```scala
def ana [Fix[_[_]]: Unfold] = unfoldFix[Fix]         //  –∞–Ω–∞–º–æ—Ä—Ñ–∏–∑–º 
def cata[Fix[_[_]]:   Fold] =   foldFix[Fix]         // –∫–∞—Ç–∞–º–æ—Ä—Ñ–∏–∑–º

def hylo[Fix[_[_]]: Unfold: Fold, F[_]: Lift, A, B]( // —Ö–∏–ª–æ–º–æ—Ä—Ñ–∏–∑–º
  coalgebra: Coalgebra[F][A],
  algebra: Algebra[F][B]
): A => B =
  ana[Fix](coalgebra) andThen cata[Fix](algebra)  
  
val natCoalg: Coalgebra[OptCell[Int]][Int ] = n => Option.when(n > 0)(n, n - 1) // —Å–ø–∏—Å–æ–∫ —á–∏—Å–µ–ª [n .. 1]
val factAlg:    Algebra[OptCell[Int]][Long] = _.fold(1L)(_ * _)                 // –ª–∏–±–æ 1, –ª–∏–±–æ n * prev

val fact = hylo(natCoalg, factAlg)  // Int => Long
fact(10) // 3628800
```
–ü—Ä–æ –µ—â—ë –æ–¥–Ω—É –ø–µ—Ä–µ—Å–≤—ë—Ä—Ç–∫—É, *–¥–∏–Ω–∞–º–æ–º–æ—Ä—Ñ–∏–∑–º*, –±—É–¥–µ—Ç —Ä–∞—Å—Å–∫–∞–∑–∞–Ω–æ –≤ —Å–ª–µ–¥—É—é—â–µ–º —Ä–∞–∑–¥–µ–ª–µ.

–û–ø–∏—Ä–∞—è—Å—å –Ω–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –≤—ã—à–µ –ø—Ä–∏–º–µ—Ä—ã, –º–æ–∂–Ω–æ —Å–æ–±–∏—Ä–∞—Ç—å –∏ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ –∞–ª–≥–µ–±—Ä—ã/–∫–æ–∞–ª–≥–µ–±—Ä—ã ‚Äì –≤ –Ω–∏—Ö –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –±—É–¥—É—Ç –∫–æ–º–ø–æ–∑–∏—Ü–∏–µ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –ø–æ–ø—Ä–æ—â–µ. –ò–º–µ–Ω–∞ —Ç–∞–∫–∏—Ö —Å–≤—ë—Ä—Ç–æ–∫/—Ä–∞–∑–≤—ë—Ä—Ç–æ–∫ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è –∏–∑ –∏–º—ë–Ω –º–æ—Ä—Ñ–∏–∑–º–æ–≤, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –∞–ª–≥–µ–±—Ä–∞–º, –Ω–∞ –±–∞–∑–µ –∫–æ—Ç–æ—Ä—ã—Ö –±—ã–ª–∏ —Å–æ–±—Ä–∞–Ω—ã —ç—Ç–∏ –∫–æ–º–ø–æ–∑–∏—Ç–Ω—ã–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏. –í —á–∞—Å—Ç–Ω–æ—Å—Ç–∏, —Ç–∞–∫ —Å—Ç—Ä–æ–∏—Ç—Å—è —Å—Ç–∞–≤—à–∏–π —É–∂–µ –º–µ–º–æ–º *[–∑–∏–≥–æ–≥–∏—Å—Ç–æ–º–æ—Ä—Ñ–Ω—ã–π –ø—Ä–µ–ø—Ä–æ–º–æ—Ä—Ñ–∏–∑–º](https://wiki.haskell.org/Zygohistomorphic_prepromorphisms)* (`zygoHistoPrepro`).

<anchor>histomorphism</anchor>

#### –•–∏—Å—Ç–æ–º–æ—Ä—Ñ–∏–∑–º

–û–±—ã—á–Ω—ã–µ —Å–ø–∏—Å–∫–∏ `List` –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç—Å—è –≤ –≤–∏–¥–µ –Ω–∞–∏–º–µ–Ω—å—à–∏—Ö –Ω–µ–ø–æ–¥–≤–∏–∂–Ω—ã—Ö —Ç–æ—á–µ–∫. –î–ª—è –Ω–∏—Ö –≤–∞–∂–Ω–∞ –ø—Ä–µ–∂–¥–µ –≤—Å–µ–≥–æ —Å–≤—ë—Ä—Ç–∫–∞, –∫–æ–≥–¥–∞ —Å–ø–µ—Ä–≤–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ `head`, –∞ –∑–∞—Ç–µ–º –≤—Å–µ *–ø–æ—Å–ª–µ–¥—É—é—â–∏–µ* (`tail`). –í —Å–≤–æ—é –æ—á–µ—Ä–µ–¥—å, –ø–æ—Ç–æ–∫–∏ `Stream` –∏–ª–∏ –ª–µ–Ω–∏–≤—ã–µ —Å–ø–∏—Å–∫–∏ `LazyList` —è–≤–ª—è—é—Ç—Å—è –Ω–∞–∏–±–æ–ª—å—à–∏–º–∏ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω—ã–º–∏ —Ç–æ—á–∫–∞–º–∏, –Ω–∞—Ü–µ–ª–µ–Ω–Ω—ã–º–∏ –Ω–∞ —Ä–∞–∑–≤—ë—Ä—Ç–∫—É, —Ä–æ—Å—Ç. –ù–∞ —Ç–∞–∫–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–∂–Ω–æ —Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞–∫ –Ω–∞ –ø–∞—Ä—É —Ç–µ–∫—É—â–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è `current` –∏ –≤—Å–µ—Ö *–ø—Ä–µ–¥—ã–¥—É—â–∏—Ö* (`previous`), –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –≤—ã—á–∏—Å–ª–µ–Ω—ã —Ä–∞–Ω–µ–µ.

–í –ø—Ä–æ—Ü–µ—Å—Å–µ —Å–≤—ë—Ä—Ç–∫–∏ –Ω–∞–∏–º–µ–Ω—å—à–µ–π –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏ –º—ã —à–∞–≥ –∑–∞ —à–∞–≥–æ–º –ø–æ–ª—É—á–∞–µ–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏ –∏–Ω–æ–≥–¥–∞ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –∑–∞–¥–∞—á–∏, –∫–æ–≥–¥–∞ –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ–ª–µ–∑–Ω—ã–º –ø–æ–¥—Å–º–æ—Ç—Ä–µ—Ç—å, —á—Ç–æ –∂–µ –±—ã–ª–æ –≤—ã—á–∏—Å–ª–µ–Ω–æ –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —à–∞–≥–∞—Ö. –ó–∞–≥–ª—è–Ω—É—Ç—å –≤ –ø—Ä–æ—à–ª–æ–µ –Ω–∞–º –ø–æ–º–æ–∂–µ—Ç —Å—Ö–µ–º–∞ —Ä–µ–∫—É—Ä—Å–∏–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º ¬´*—Ö–∏—Å—Ç–æ–º–æ—Ä—Ñ–∏–∑–º*¬ª, –∏—Å–ø–æ–ª—å–∑—É—é—â–∞—è `Cofree` (—Å–º. **–ø—Ä–µ–¥—ã–¥—É—â—É—é —á–∞—Å—Ç—å –æ–±–∑–æ—Ä–∞**):
```scala
extension [F[_]: Lift, X](cof: Cofree[F][X])  
  def current  = unapplyCofree[F, X](cof)._1  
  def previous = unapplyCofree[F, X](cof)._2

def cofreeAlgToFAlg[F[_]: Lift, X]: Algebra[F ‚àò Cofree[F]][X] => Algebra[F][Cofree[F][X]] =
  alg => fcof => pureCofree(alg(fcof), fcof) // outFix[ùõé]

def histo[Fix[_[_]]: Fold, F[_]: Lift, X]: Algebra[F ‚àò Cofree[F]][X] => Fix[F] => X =
  cofreeAlgToFAlg(_) pipe foldFix[Fix][F][Cofree[F][X]] andThen {_.current}
```

–•–∏—Å—Ç–æ–º–æ—Ä—Ñ–∏–∑–º –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –∏ –≤ —á–∏—Å—Ç–æ–º –≤–∏–¥–µ, –Ω–æ —á–∞—â–µ –æ–Ω –∫–æ–º–±–∏–Ω–∏—Ä—É–µ—Ç—Å—è —Å –∞–Ω–∞–º–æ—Ä—Ñ–∏–∑–º–æ–º, –æ–±—Ä–∞–∑—É—è —Ç–∞–∫—É—é –ø–µ—Ä–µ—Å–≤—ë—Ä—Ç–∫—É:
```scala
def dynamo[Fix[_[_]]: Fold: Unfold, F[_]: Lift, A, B](
  coalg     : Coalgebra[F][A],
  histoAlg  : Algebra[F ‚àò Cofree[F]][B]
): A => B =
  unfoldFix[Fix][F][A](coalg) andThen histo(histoAlg) // ana >>> histo
```

–ü—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ–º —Ä–∞–±–æ—Ç—É —ç—Ç–æ–≥–æ *–¥–∏–Ω–∞–º–æ–º–æ—Ä—Ñ–∏–∑–º–∞* –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –§–∏–±–æ–Ω–∞—á—á–∏:
```scala
def fibonacci: Int => Int = dynamo[Œº, Option, Int, Int](
  i => Option.when(i > 1)(i - 1),  // –∫–æ–∞–ª–≥–µ–±—Ä–∞ –¥–ª—è —Ä–∞–∑–≤—ë—Ä—Ç–∫–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Ç–∏ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª
  _.flatMap{ last => last.previous.map(prev => last.current + prev.current) }.getOrElse(1)
) //         –µ—Å–ª–∏ —Ä–∞–Ω–µ–µ —É–∂–µ –ø–æ—Å—á–∏—Ç–∞–Ω—ã –¥–≤–æ–µ, —Ç–æ   –ø–æ—Å–ª–µ–¥–Ω–µ–µ  +  –ø—Ä–µ–¥—ã–¥—É—â–µ–µ      –∏–Ω–∞—á–µ    1

fibonacci(10) // 55 - –¥–µ—Å—è—Ç–æ–µ —á–∏—Å–ª–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –§–∏–±–æ–Ω–∞—á—á–∏
```

–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —Ö–∏—Å—Ç–æ–º–æ—Ä—Ñ–∏–∑–º –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –ø—Ä–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–∏ —á–ª–µ–Ω–æ–≤ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, –ø–æ—Ä–æ–∂–¥–∞–µ–º—ã—Ö —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏, –∫–æ–≥–¥–∞ –ø–æ—Å–ª–µ–¥—É—é—â–∏–µ —á–ª–µ–Ω—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö. –í–ø—Ä–æ—á–µ–º, –ø—Ä–∏–º–µ–Ω–∏—Ç–µ–ª—å–Ω–æ –∏–º–µ–Ω–Ω–æ –∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –§–∏–±–æ–Ω–∞—á—á–∏ —É–¥–æ–±–Ω–µ–µ –æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –ø–∞—Ä–∞–º–æ—Ä—Ñ–∏–∑–º, –∏–ª–∏ –¥–∞–∂–µ –æ–±—ã—á–Ω–∞—è —Å–≤—ë—Ä—Ç–∫–∞ (–∫–∞—Ç–∞–º–æ—Ä—Ñ–∏–∑–º).

–ù–∞–∑–≤–∞–Ω–∏–µ ¬´–¥–∏–Ω–∞–º–æ–º–æ—Ä—Ñ–∏–∑–º¬ª –æ–±—É—Å–ª–æ–≤–ª–µ–Ω–æ —Ç–µ–º, —á—Ç–æ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –æ–Ω –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–∞–ª—Å—è –¥–ª—è –∑–∞–¥–∞—á [–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). –ü—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏ —Ç–∞–∫–∏—Ö –∑–∞–¥–∞—á–∞—Ö —Å–ø–µ—Ä–≤–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è –Ω–∞ –º–µ–ª–∫–∏–µ –ø–æ–¥–∑–∞–¥–∞—á–∫–∏ (—Ä–∞–∑–≤—ë—Ä—Ç–∫–∞), –∑–∞—Ç–µ–º –æ–Ω–∏ —Ä–µ—à–∞—é—Ç—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, *—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —É–∂–µ —Ä–µ—à—ë–Ω–Ω—ã—Ö –ø–æ–¥–∑–∞–¥–∞—á* (—Å–≤—ë—Ä—Ç–∫–∞ —Å Cofree ‚Äì —Ö–∏—Å—Ç–æ–º–æ—Ä—Ñ–∏–∑–º). –ù–∞ –•–∞–±—Ä–µ –µ—Å—Ç—å [–Ω–µ–ø–ª–æ—Ö–∞—è —Å—Ç–∞—Ç—å—è –æ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏](https://habr.com/ru/articles/777618/) —Å –ø—Ä–∏–º–µ—Ä–∞–º–∏ –Ω–∞ Python.




<anchor>futumorphism</anchor>

#### –§—É—Ç—É–º–æ—Ä—Ñ–∏–∑–º

–°—Ö–µ–º–∞ —Ä–µ–∫—É—Ä—Å–∏–∏ –¥—É–∞–ª—å–Ω–∞—è —Ö–∏—Å—Ç–æ–º–æ—Ä—Ñ–∏–∑–º—É –Ω–æ—Å–∏—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ ¬´—Ñ—É—Ç–æ–º–æ—Ä—Ñ–∏–º–∑–º¬ª. –≠—Ç–æ —Ä–∞–∑–≤—ë—Ä—Ç–∫–∞, –≤ –∞–ª–≥–µ–±—Ä–µ –∫–æ—Ç–æ—Ä–æ–π –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–≤–æ–±–æ–¥–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä:
```scala
def futuCoalgToCoalg[F[_]: Lift, X]: Coalgebra[F ‚àò Free[F]][X] => Coalgebra[F][Free[F][X]] =
  coalg => outFix[Œº, CoEnv[X, F]] andThen {_.fold(coalg, identity)}
  //                           –≤—ã—á–∏—Å–ª—è–µ–º —Å–µ–π—á–∞—Å - ‚Üë‚Üë‚Üë‚Üë‚Üë  ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë - –≤—ã—á–∏—Å–ª–µ–Ω—ã —Ä–∞–Ω–µ–µ

def futu [Fix[_[_]]: Unfold: OutFix, F[_]: Lift, X]: Coalgebra[F ‚àò Free[F]][X] => X => Fix[F] =
  futuCoalgToCoalg andThen unfoldFix[Fix][F][Free[F][X]] andThen {pureFree[F][X] andThen _}
```

–•–∏—Å—Ç–æ–º–æ—Ä—Ñ–∏–∑–º –ø–æ–∑–≤–æ–ª—è–ª –∑–∞–≥–ª—è–¥—ã–≤–∞—Ç—å –≤ –ø—Ä–æ—à–ª–æ–µ, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —à–∞–≥–æ–≤ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π. –î—É–∞–ª—å–Ω—ã–π –µ–º—É —Ñ—É—Ç—É–º–æ—Ä—Ñ–∏–∑–º, –Ω–∞–æ–±–æ—Ä–æ—Ç –¥–∞—ë—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –≤—ã—á–∏—Å–ª–µ–Ω—ã –ª–∏—à—å –≤ –±—É–¥—É—â–µ–º!

–ù–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –Ω–µ—Ç —Ç–∞–∫ –º–Ω–æ–≥–æ –∑–∞–¥–∞—á, –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∫–æ—Ç–æ—Ä—ã—Ö –±—ã–ª–æ –±—ã –ø–æ–ª–µ–∑–Ω–æ —Å—Ç–æ–ª—å –∏–Ω—Ç—Ä–∏–≥—É—é—â–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å —Ñ—É—Ç—É–º–æ—Ä—Ñ–∏–∑–º–∞. –ß–∞—Å—Ç–æ –≤ –ø—Ä–∏–º–µ—Ä –ø—Ä–∏–≤–æ–¥—è—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–µ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä—ã ‚Äì –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ª–µ–∫—Å–µ–º –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –≤ –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω–æ–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–æ–µ –¥–µ—Ä–µ–≤–æ (AST), –ø—Ä–∏—á—ë–º –∫–∞–∫–∏–µ-—Ç–æ —Å—É—â–Ω–æ—Å—Ç–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—ä—è–≤–ª–µ–Ω—ã ¬´–≤ –±—É–¥—É—â–µ–º¬ª, –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –∏—Ö –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –≤—Å—Ç—Ä–µ—Ç—è—Ç—Å—è –≤ –∫–æ–¥–µ.

–ó–¥–µ—Å—å –∂–µ –ø—Ä–∏–≤–µ–¥—ë–º [–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–π –ê–¥–∞–º–æ–º –í–∞–Ω–¥–µ—Ä–≤–æ—Ä—Å—Ç–æ–º](https://github.com/Adam-Vandervorst/RecursionSchemes) –ø—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã —Å [–∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–º–∏ –≥—Ä–∞—Ñ–∞–º–∏](https://dl.acm.org/doi/pdf/10.1145/3122955.3122956):
```scala
enum GraphSum[Vert, Gr]:
  case Empty extends GraphSum[Nothing, Nothing]
  case Vertex(a: Vert)
  case Overlay(x: Gr, y: Gr)
  case Connect(x: Gr, y: Gr)
import GraphSum.*

type GraphBase[Vert] = [Gr] =>> GraphSum[Vert, Gr]
type Graph    [Vert] = Œº[GraphBase[Vert]]
```

–ö–∞–∂–¥—ã–π —Ç–∞–∫–æ–π –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ –º–æ–∂–µ—Ç –±—ã—Ç—å:
- –ø—É—Å—Ç—ã–º `Empty`;
- –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–π –≤–µ—Ä—à–∏–Ω–æ–π `Vertex`;
- –Ω–∞–ª–æ–∂–µ–Ω–∏–µ–º `Overlay` –≥—Ä–∞—Ñ–æ–≤ (–º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤–µ—Ä—à–∏–Ω –∏ —Ä—ë–±–µ—Ä –≥—Ä–∞—Ñ–æ–≤ –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è);
- –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ–º –¥–≤—É—Ö –≥—Ä–∞—Ñ–æ–≤ `Connect` (–ø–æ–º–∏–º–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ –Ω–∞–ª–æ–∂–µ–Ω–∏—è –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è —Ä–µ–±—Ä–∞ –æ—Ç –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã –ø–µ—Ä–≤–æ–≥–æ –≥—Ä–∞—Ñ–∞ –∫ –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω–µ –≤—Ç–æ—Ä–æ–≥–æ).

–°–æ–±–∏—Ä–∞—Ç—å –≥—Ä–∞—Ñ –±—É–¥–µ–º –∏–∑ [–º–∞—Ç—Ä–∏—Ü—ã —Å–º–µ–∂–Ω–æ—Å—Ç–∏](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%D1%81%D0%BC%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8), –≤ –∫–æ—Ç–æ—Ä–æ–π —É–∫–∞–∑–∞–Ω–æ, –∫–∞–∫ –∫–∞–∂–¥–∞—è –≤–µ—Ä—à–∏–Ω–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∞ —Å –¥—Ä—É–≥–∏–º–∏:
```scala
type AdjacencyMatrix[Vert] = Iterable[(Vert, Set[Vert])]
```
–ü–æ —Å—É—Ç–∏, –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç —Ç–∞–∫–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –º–∞–ª–µ–Ω—å–∫–∏–π –≥—Ä–∞—Ñ –∏ –Ω–∞–º –æ—Å—Ç–∞—ë—Ç—Å—è –ª–∏—à—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏—Ö —Å–∫–ª–µ–∏—Ç—å. –ö–∞–∂–¥–æ–µ —Ä–µ–±—Ä–æ —Å–æ–µ–¥–∏–Ω—è–µ—Ç –æ–¥–∏–Ω –≥—Ä–∞—Ñ —Å –¥—Ä—É–≥–∏–º, –Ω–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è —Å–ø–∏—Å–æ–∫ —Ä—ë–±–µ—Ä –Ω—É–∂–Ω–æ —É—á–∏—Ç—ã–≤–∞—Ç—å, —á—Ç–æ *–æ–ø–∏—Å–∞–Ω–∏–µ –¥—Ä—É–≥–∏—Ö —á–∞—Å—Ç–µ–π –≥—Ä–∞—Ñ–∞ –ø–æ—è–≤–∏—Ç—Å—è –ª–∏—à—å –¥–∞–ª—å—à–µ* –≤ —ç—Ç–æ–º —Å–ø–∏—Å–∫–µ. –î–ª—è —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±–∞ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ `bindFree` –∏ `pureFree`:
```scala
def fromAdjCoalg[V]: Coalgebra[GraphBase[V] ‚àò Free[GraphBase[V]]][AdjacencyMatrix[V]] =  
  case (vertex, connectedGraphs) :: tail => Overlay(  
    bindFree(Connect(  
      bindFree(Vertex(vertex)),  
      connectedGraphs.foldLeft[Free[GraphBase[V]][AdjacencyMatrix[V]]](  
        bindFree(Empty))(  
        (childGraph, childVertex) => bindFree(Overlay(  
          childGraph,  
          bindFree(Vertex(childVertex))  
        ))  
      )  
    )),  
    pureFree(tail), // —Å—Å—ã–ª–∞–µ–º—Å—è –Ω–∞ —á–∞—Å—Ç–∏ –≥—Ä–∞—Ñ–∞, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –≤—ã—á–∏—Å–ª–µ–Ω—ã –í –ë–£–î–£–©–ï–ú!  
  )  
  case Nil => Empty

def fromAdj[V]: AdjacencyMatrix[V] => Graph[V] =  
  futu[Œº, GraphBase[V], AdjacencyMatrix[V]](fromAdjCoalg[V])
```

–í–µ—Ä—Ö–Ω–µ—É—Ä–æ–≤–Ω–µ–≤–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –≤ –∫–æ–∞–ª–≥–µ–±—Ä–µ ‚Äì —ç—Ç–æ –Ω–∞–ª–æ–∂–µ–Ω–∏–µ –¥–≤—É—Ö –≥—Ä–∞—Ñ–æ–≤ `Overlay(bindFree(...), pureFree(tail))`. –ü–µ—Ä–≤—ã–π –≥—Ä–∞—Ñ —Å—Ç—Ä–æ–∏—Ç—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–∏ –º–∞—Ç—Ä–∏—Ü—ã —Å–º–µ–∂–Ω–æ—Å—Ç–∏, –Ω–æ –≤–æ—Ç –≤—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç ‚Äì —ç—Ç–æ —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–æ–æ–±—â–µ –≤–µ—Å—å –≥—Ä–∞—Ñ, –∫–æ—Ç–æ—Ä—ã–π –µ—â—ë –ø—Ä–µ–¥—Å—Ç–æ–∏—Ç –≤—ã—á–∏—Å–ª–∏—Ç—å!

–ü—Ä–æ–≤–µ—Ä—è—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±—É–¥–µ–º –ø—Ä–∏–≤–æ–¥—è –≥—Ä–∞—Ñ –∫ —Å—Ç—Ä–æ–∫–µ –ø–æ—Å—Ä–µ–¥—Å—Ç–≤–æ–º –æ–±—ã—á–Ω–æ–π —Å–≤—ë—Ä—Ç–∫–∏:
```scala
def graphToString[V] = foldFix[Œº][GraphBase[V]][String]:  
  case Empty         => "‚àÖ"  
  case Vertex(a)     => a.toString  
  case Overlay(l, r) =>  
    if l == "‚àÖ" then r else // —É–ø—Ä–æ—â–µ–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
    if r == "‚àÖ" then l else // —É–ø—Ä–æ—â–µ–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è  
      s"($l + $r)"  
  case Connect(l, r) =>  
    if l == "‚àÖ" then r else // —É–ø—Ä–æ—â–µ–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
    if r == "‚àÖ" then l else // —É–ø—Ä–æ—â–µ–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
      s"($l -> $r)"
```

–í –∏—Ç–æ–≥–µ –ø–æ–ª—É—á–∞–µ–º —Å—Ç–æ—á–∫—É, –∫–æ—Ç–æ—Ä—É—é –ª–µ–≥–∫–æ —Å–≤–µ—Ä–∏—Ç—å —Å –∏—Å—Ö–æ–¥–Ω–æ–π –º–∞—Ç—Ä–∏—Ü–µ–π —Å–º–µ–∂–Ω–æ—Å—Ç–∏:
```scala
val adjacencyMatrix = Map(  
  4 -> Set(3),  
  2 -> Set(2),  
  3 -> Set(),  
  1 -> Set(1, 3),  
  4 -> Set(1, 2, 5),  
  5 -> Set(3),  
)

graphToString(fromAdj(small_adj.toSeq))
// ((5 -> 3) + ((1 -> (1 + 3)) + ((2 -> 2) + (3 + (4 -> ((1 + 2) + 5))))))
```
–î—Ä—É–≥–∏–µ –ø—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å—Ö–µ–º —Ä–µ–∫—É—Ä—Å–∏–∏ –¥–ª—è —Ç–∞–∫–æ–≥–æ –≥—Ä–∞—Ñ–∞ –º–æ–∂–Ω–æ –ø–æ–¥—Å–º–æ—Ç—Ä–µ—Ç—å —É –ê–¥–∞–º–∞ –ø–æ —Å—Å—ã–ª–∫–µ –≤—ã—à–µ.

#### –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–í—Å–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –≤ —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ —Å —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è –æ–¥–Ω–∏–º –æ–±—â–∏–º –ø–æ–Ω—è—Ç–∏–µ–º ‚Äì **—Å—Ö–µ–º—ã —Ä–µ–∫—É—Ä—Å–∏–∏**. –ù–æ —Å—é–¥–∞ —Ç–∞–∫–∂–µ –æ—Ç–Ω–æ—Å—è—Ç –∏ –¥—Ä—É–≥–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä:
- —Å–≤—ë—Ä—Ç–∫–∞ –¥–≤—É—Ö, –∏–ª–∏ –±–æ–ª–µ–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –∑–∞ —Ä–∞–∑;
- –ø–µ—Ä–µ—Å–≤—ë—Ä—Ç–∫–∏ —Å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º –ø–æ—Å–µ—Ä–µ–¥–∏–Ω–µ (`map`, `flatMap`);
- –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤–∏–¥–∞ `Œº[F] => Œº[G]` (–¥–µ—Ä–µ–≤–æ –≤ —Å–ø–∏—Å–æ–∫ –∏ —Ç.–ø.).
–ù–æ –≤—Å–µ —ç—Ç–∏ —Å—Ö–µ–º—ã —Ç–∞–∫ –∏–ª–∏ –∏–Ω–∞—á–µ *–æ–ø–∏—Ä–∞—é—Ç—Å—è –Ω–∞ –≤—Å—ë —Ç–µ –∂–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –Ω–∞–∏–±–æ–ª—å—à–µ–π –∏ –Ω–∞–∏–º–µ–Ω—å—à–µ–π –Ω–µ–ø–æ–¥–≤–∏–∂–Ω—ã—Ö —Ç–æ—á–µ–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤ —Ç–∏–ø–æ–≤ ‚Äì —Ñ—É–Ω–∫—Ü–∏–∏ `fold` –∏ `unfold`*.

–ï—â—ë –±–æ–ª—å—à–µ –æ —Å—Ö–µ–º–∞—Ö —Ä–µ–∫—É—Ä—Å–∏–∏ –º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å —Ç—É—Ç:
- [Awesome Recursion Schemes](https://github.com/passy/awesome-recursion-schemes) –±–∏–±–ª–∏–æ–≥—Ä–∞—Ñ–∏—è
- [Paramorphism](https://github.com/softwaremill/recursion-training?tab=readme-ov-file#paramorphism) (GitHub)
- [Introduction to Recursion Schemes with Matryoshka](https://akmetiuk.com/posts/2017-03-10-matryoshka-intro/)
- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ [matryoshka](https://github.com/xuwei-k/matryoshka) (GitHub)
- [Recursion Schemes: A Field Guide (Redux)](http://comonad.com/reader/2009/recursion-schemes/ "Permanent Link: Recursion Schemes: A Field Guide (Redux)") –ø–µ—Ä–µ—á–µ–Ω—å —Å—Ö–µ–º —Å–æ —Å—Å—ã–ª–∫–∞–º–∏ –Ω–∞ Haskell-–ø—Ä–∏–º–µ—Ä—ã
- [Recursion Schemes in Scala - An Absolutely Elementary Introduction](https://free.cofree.io/2017/11/13/recursion/) (–¶–∑—ã—è–Ω –õ—é)
- [Catamorphisms](https://wiki.haskell.org/Catamorphisms) (wiki.haskell) –ª—é–±–æ–ø—ã—Ç–Ω–∞—è —Å—Ç–∞—Ç—å—è
- [An introduction to recursion schemes](https://nrinaudo.github.io/articles/recschemes.html) –ù–∏–∫–æ–ª—è –†–∏–Ω–∞—É–¥–æ [—Å–ª–∞–π–¥—ã](https://nrinaudo.github.io/recursion-schemes-from-the-ground-up/#1)
- [AST playground: recursion schemes and recursive data](https://kubuszok.com/2019/ast-playground-recursion-schemes-and-recursive-data/ "AST playground: recursion schemes and recursive data") (–ö—É–±—É–∂–æ–∫)


- [Histomorphism, Dynamorphism, Futumorphism](https://free.cofree.io/2017/11/13/recursion/#histomorphism) (Scala) –ë–ª–æ–≥ –¶–∑–∏—è–Ω–∞ –õ—é.
- [Recursion Schemes, Part IV: Time is of the Essence](http://blog.sumtypeofway.com/recursion-schemes-part-iv-time-is-of-the-essence/) (Haskell) –≤ –±–ª–æ–≥–µ –ü–∞—Ç—Ä–∏–∫–∞ –¢–æ–º–ø—Å–æ–Ω–∞
- [Time Traveling Recursion Schemes](https://jtobin.io/time-traveling-recursion)¬†(Haskell) –î–∂–∞—Ä–µ–¥ –¢–æ–±–∏–Ω.
