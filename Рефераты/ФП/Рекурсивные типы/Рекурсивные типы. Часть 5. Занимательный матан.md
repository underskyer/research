![[Угвей.png|Мастера Угвэя ничуть не удивляло, что отношения между типами напоминают на обычную математику.|600]]


<anchor>nat_numbers</anchor>

#### Натуральные числа

В своё время для меня стал настоящим открытием тот факт, что тип натуральных чисел также является рекурсивным:
```scala
type Nat = μ[Option]
```

Продемонстрировать это не сложно. Сперва введём более удобные конструкторы:
```scala
// основные
val zero:          Nat = inFix[μ, Option](None   )
def succ(n:Nat):   Nat = inFix[μ, Option](Some(n))
// вспомгательные
val one:           Nat = succ(zero)
def toNat(i: Int): Nat = (1 to i).foldRight(zero)((_, acc) => succ(acc)) // не корректно для отрицательных i, но сейчас это не важно
```

Затем реализуем обычную [арифметику по Пеано](https://ru.wikipedia.org/wiki/%D0%90%D0%BA%D1%81%D0%B8%D0%BE%D0%BC%D1%8B_%D0%9F%D0%B5%D0%B0%D0%BD%D0%BE):
```scala
extension (nat: Nat)
  def +     = foldFix[μ]((_: Option[Nat]).fold(nat )(succ   ))
  def *     = foldFix[μ]((_: Option[Nat]).fold(zero)(_ + nat))
  def **    = foldFix[μ]((_: Option[Nat]).fold(one )(_ * nat))  
  def toInt = foldFix[μ]((_: Option[Int]).fold(0   )(_ + 1  ))(nat)
```

Операции для `Nat`, обратные этим, будут частично определёнными. Попытка вывести типы, замкнутые относительно обратных операций (чтобы они стали полностью определёнными) приведёт нас к целым, рациональным и прочим числам. Такие типы, по большей части, будут нерекурсивными, поэтому отложим эту тему на другой раз.

А работает наша арифметика следующим образом:
```scala
val two   = succ(one)
val three = succ(two)
val six   = toNat(6)

val theAnswer = (two * three) ** two + six
theAnswer.toInt // 42
```

Важно обратить внимание, что конструкторы `Nat` реализованы через `inFix`, а арифметические операции и деконструкция в `Int` – через `foldFix`. Пара этих методов как раз определяет **основные возможности** для **наименьшей неподвижной точки** `μ`, введённой в предыдущей части статьи. Вообще, всё полезное, что может дать тип `Nat`, выражается через свёртку этого рекурсивного типа! Например, факториал – это свёртка `Nat` в такой же рекурсивный `Nat`:
```scala
def factorial: Nat => Nat =
  foldFix[μ][Option][(Nat, Nat)]{
	_.fold((one, one))((n, fact) => succ(n) -> fact * n)
  } andThen {_._2}

factorial(toNat(5)).toInt // 120
```

Натуральные числа играют огромную роль в математике в целом и в программировании в частности. Они олицетворяют идею [математической индукции](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%B8%D0%BD%D0%B4%D1%83%D0%BA%D1%86%D0%B8%D1%8F) – *пошагового* вывода новых конструкций из существующих. Все значения, с которыми имеют дело программисты, конструктивны. Следовательно все типы этих значений счётны – они все *изоморфны натуральным числам*! 

> Строго говоря, технически можно сформулировать и несчётные типы, но по факту мы сможем создавать только значения их счётных подтипов.



<anchor>row_decompose</anchor>

#### Разложение в ряд

Ранее список был выражен через неподвижную точку  конструктора типов `OptCell`:
$$
\begin{align}
OptCell[A][X] &\cong 1 + A \times X,\\
List[A] &= \mu[OptCell[A]]\\
\end{align}
$$

При этом `μ` определялся в стиле передачи продолжений, чтобы скрыть «ссылку на себя». Но давайте теперь посмотрим на чуть более привычное определение списка:
$$
List[A] = 1 + A \times List[A]\\
$$

Это не что иное, как функциональное уравнение для «функции» `List[A]`. Выражение справа можно попробовать раскрыть, шаг за шагом подставляя вместо `List[A]` всё выражение целиком. У нас будет получаться такая бесконечная сумма:
$$
List[A] = 1 + A + A \times A + A \times A \times A + \ldots = \sum_{n=0}^\infty A^n\\
$$

Трактуется эта сумма очевидно: список – это либо пустой список, либо один элемент, либо их пара, тройка и т.д. Выглядит, как сумма членов геометрической прогрессии, для которой можно применить известную формулу:
$$
List[A] = \frac1{1 - A}\\
$$

Точно такой же результат получается, если напрямую решить исходное функциональное уравнение. Оказывается, типы можно не только складывать и перемножать но и делить и вычитать!

Точнее говоря, здесь же такие выражения следует трактовать как *производящие функции* для разложения в ряд. На самом деле, это достаточно распространённый приём в математике. Эти выражения можно комбинировать друг с другом и даже упрощать, получая в итоге разложения в новые ряды.

И такие выражения появляются не только при работе со списками. К примеру, обычное бинарное дерево представляется следующим функциональным уравнением:
$$
Tree[A] = 1 + A \times Tree[A] \times Tree[A]\\
$$

Его «решением» является такой ряд:
$$
Tree[A] = 1 + A + 2 A^2 + 5 A^3 + 14 A^4 + \ldots\\
$$

«Числовые» коэффициенты (это всё подтипы `Nat`!) перед $A^n$ показывают, сколько существуют различных «форм» деревьев, содержащих $n$ элементов $A$. Например, в случае двух элементов, один оказывается в корне (или на вершине, смотря как смотреть)), а другой может быть слева или справа – всего два варианта. В то же время разных форм деревьев из четырёх элементов наберётся целых четырнадцать.

*Производящая функция* этого ряда будет содержать радикал:
$$
Tree[A] = \frac{1-\sqrt{1-4A}}{2A}\\
$$

> Второе решение, со знаком $+$ перед корнем из дискриминанта оказывается непродуктивным. Разложение подразумевает «малость» $A$, но при $A \rightarrow 0$ такое решение устремляется в «бесконечность», и сложно понять, как использовать получаемый ряд: $1/A - 1 - A - 2 A^2 - 5 A^3 + \ldots$

Если построить дерево с пятью или более ветвями в узле, то точное решение для соответствующего функционального уравнения [не удастся получить](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%90%D0%B1%D0%B5%D0%BB%D1%8F_%D0%BE_%D0%BD%D0%B5%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8_%D1%83%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9_%D0%B2_%D1%80%D0%B0%D0%B4%D0%B8%D0%BA%D0%B0%D0%BB%D0%B0%D1%85). Тем не менее, разложение в ряд интерпретируется также просто, как и в случае бинарного дерева.

И всё же, не все полиномиальные рекурсивные типы приводят к полезным разложениям в ряд. Рассмотрим такой тип:
$$
\begin{eqnarray}
UMagma[A] &=& A + 1 + UMagma[A] \times UMagma[A]\\
UMagma[A] &=& \frac12 \left(1 \pm \sqrt{-4 A - 3}\right)\\
\end{eqnarray}
$$

При попытке разложения $UMagma[A]$ в ряд выясняется, что все его коэффициенты бесконечны! Другими словами, для любого заданного наперёд количества элементов $A$ существует бесконечное множество различных форм дерева такой структуры. Причём, сам по себе тип корректный и не бесполезный:
```scala
final case class UMagma[A](value: A Either Option[(UMagma[A], UMagma[A])])

def leaf[A](a: A) = UMagma(Left(a))
def twig[A] = UMagma[A](Right(None))
def node[A](left: UMagma[A], right: UMagma[A]) = UMagma(Right(Some((left, right))))

val someTree = node( //     /\
  leaf(42),          //   42  \
  twig               //        ∅
)

val sameTree = node( //     /\
  leaf(42),          //   42  \
  node(              //       /\    // ∅ добавляются неограниченно.
    twig,            //      ∅  \   // вот откуда возникают
    twig             //          ∅  // все эти бесконечные формы 
  )                                 // для одинакового количества A
)
```

Неподвижные точки любых полиномиальных конструкторов типов («алгебраические» типы, состоящие из сумм произведений) представляют собой различные деревья. Вырожденными случаями таких деревьев являются и списки (дерево с единственной веткой), и даже натуральные числа:
$$Nat \cong List[Unit]$$

Функциональное уравнение для натуральных чисел выглядит просто
$$
Nat = 1 + Nat
$$

Тип не параметризирован, и единственное решение уравнения – бесконечность)).

Что же до неподвижных точек конструкторов типов, в которых есть экспоненциалы (типы функций), то тут картина такая. Если тип-параметр хотя бы раз находится в отрицательной позиции, то, **как уже говорилось ранее**, такая неподвижна точка неконструктивна и с её значениями не получится работать. В прочих же случаях, когда тип-параметр является результатом какой-либо функции, например $A^{Int}$ («степенной» тип), то тип в значении экспоненты, как говорилось ранее, считается счётным, изоморфным `Nat`. Это означает что все степенные типы можно представить как *произведения* типа-параметра с самим собой. Соответственно, неподвижные точки таких выражений можно трактовать как знакомые деревья, просто с большим количеством ветвей в узлах.



<anchor>onehole-context</anchor>

#### Однодырочный контекст

Положим, у нас есть контейнер $F[A]$, в котором «хранится» в общем случае более одного значения. Это может быть просто пара значений `(A, A)`, или дерево `Tree[A]` из примера выше. И мы «захотели странного» – заменить *единственное* значение там. Помимо нового значения `A`, нам потребуется точное указание, в каком месте его нужно заменить, а так же все остальные данные исходной структуры `F[A]`.

Для изоморфизма $A^{n-1} \times A \cong A^n$ существует ровно $n$ уникальных реализаций, и необходимо указать индекс одного из них, чтобы изоморфизм был определён однозначно: $n \times A^{n-1} \times A \cong A^n$.

$$
\begin{eqnarray}
\partial_A Const &=& 0 \hspace{2cm} \text{выражение $Const$ не содрежит типовой переменной $A$}\\
\partial_A A &=& 1\\
\partial_A \left(F[A] + G[A]\right) &=& \partial_A F[A] + \partial_A G[A]\\
\partial_A \left(F[A] \times G[A]\right) &=& G[A] \times \partial_A F[A] + F[A] \times \partial_A G[A]\\
\partial_A \left(F[G[A]]\right) &=& \partial_X F[X]|_{X = G[A]} \times \partial_A G[A]\\
\end{eqnarray}
$$

Ограничимся пока полиномиальными контейнерами (алгебраическими типами).

Из этих правил, а так же факта, что все наши контейнеры сводятся к суммам произведений, можно вывести выражение для полной производной:
$$
\partial_A F[G, H] = \partial_G\; F[G, H] \times \partial_A G + \partial_H\; F[G, H] \times \partial_A H
$$

Вообще говоря получаем $\partial_A F[A] \times A + F[0] \cong F[A]$. Напоминает операцию деления с остатком.
[Производная Фреше](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%BD%D0%B0%D1%8F_%D0%A4%D1%80%D0%B5%D1%88%D0%B5):
$$
\begin{eqnarray}
F[A+B] = F[A] + D[A] \times B + R[A, B]\\
\frac{||R[A, B]||}{||B||} \rightarrow 0,\hspace{5mm} \text{когда}\hspace{5mm} ||B| |\rightarrow 0
\end{eqnarray}
$$

Пример $B = 1 + A^2 \times X^2 + A^3 \times X$. Тогда $A\times\partial_A B = 2A^2X^2+3A^3X$. Привести к $B$ можно, но для этого есть несколько способов.

Выше было продемонстрированно, что разложение в степенные ряды позволяет лучше понять структуру неподвижных точек конструкторов типов. Обычно [ряд Тейлора](https://ru.wikipedia.org/wiki/%D0%A0%D1%8F%D0%B4_%D0%A2%D0%B5%D0%B9%D0%BB%D0%BE%D1%80%D0%B0) в окрестностях нуля записывают так:
$$
Taylor_0[f](x) = \sum_{n=0}^{\infty}
\frac1{n!}
\left.\frac{d^n f(x)}{dx^n}\right|_{x \rightarrow 0}
x^n
$$

Как же трактовать все эти операции в контексте конструкторов типов? Возможно, просто совпало, что точные вычисления производных в нуле, делённых на соответствующий факториал дают правильное количество форм деревьев заданного размера? Математики обычно пренебрегают трактовкой различных математических конструкций. Это обязанность физиков, в частности, программистов.




<anchor>type_derivatives</anchor>

#### Производные от рекурсивных типов


Тогда можем вывести правило дифференцирования неподвижной точки $T \equiv T[A] = \mu X. F[A, X]$:
$$
\begin{eqnarray}
\partial_AT &=& d_A\; F[A, T[A]] = \hspace{2cm}\text{$d_A$ - символ полной производной по $A$}\\
&=& \partial_A F + \partial_X F \times \partial_A T =\\
&=& \mu Y. \left(\partial_A F + \partial_X F \times Y \right)\\
&=& \partial_A F \times List \left[\partial_X F\right]\\
\end{eqnarray}
$$



$$
\begin{eqnarray}
B &&= \lambda A. \lambda X \ldots\\
T_A &&= \mu X. B \\
\partial_A T_A &&= \left.\partial_A B\right|_{X=T_A} \times List[\left.\partial_X B\right|_{X=T_A}]\\
Zipper[T_A] &&= A \times \partial_A T_A \;\;\;\;\text{зиппер в общем случае жирнее T}\\ 
plug &&: Zipper[T_A] \Rightarrow T_A\\
\end{eqnarray}
$$




[Haskell/Zippers](https://en.m.wikibooks.org/wiki/Haskell/Zippers#Mechanical_Differentiation)
[Pdf: The Derivative of a Regular Type is its Type of One-Hole Contexts](http://strictlypositive.org/diff.pdf)
[Abusing the algebra of algebraic data types - why does this work?](https://stackoverflow.com/questions/9190352/abusing-the-algebra-of-algebraic-data-types-why-does-this-work)
[Derivatives of Containers](https://www.cs.le.ac.uk/people/ma139/docs/derivative.pdf) (pdf)
[How to interpret the derivative of the type Set?](https://www.reddit.com/r/math/comments/1au68xb/how_to_interpret_the_derivative_of_the_type_seta/?rdt=52193) (reddit)
[Unordered tuples and type algebra](https://byorgey.wordpress.com/2012/08/24/unordered-tuples-and-type-algebra/) – подсчёт перестановок в кортежах с учётом совпадающих значений
[Finite Differences of Types](http://blog.sigfpe.com/2009/09/finite-differences-of-types.html)


<anchor>conclusion</anchor>

#### Заключение
