
<anchor>nat_numbers</anchor>

#### Натуральные числа

```scala
type Nat = μ[Option]

given liftOption: Lift[Option] =
  [A, B] => (f: A => B) => (_: Option[A]).map(f)
```
Конструкторы:
```scala
val zero:          Nat = inFix[μ, Option](None   )
def succ(n:Nat):   Nat = inFix[μ, Option](Some(n))
def toNat(i: Int): Nat = (1 to i).foldRight(zero)((_, acc) => succ(acc))
```

```scala
extension (nat: Nat)
  def toInt        = foldFix[μ]((_: Option[Int]).fold(0   )(_ + 1  ))(nat)
  def +(over: Nat) = foldFix[μ]((_: Option[Nat]).fold(nat )(succ   ))(over)
  def *(over: Nat) = foldFix[μ]((_: Option[Nat]).fold(zero)(_ + nat))(over)

(toNat(4) * toNat(9) + toNat(6)).toInt // 4 * 9 + 6 = 42
```


$$
\begin{align}
List[A] &= \mu[OptCell[A]] \cong \mu[\Lambda X.\; 1 + A \times X]\\
List[A] &= 1 + A \times List[A]
\end{align}
$$


$$Nat = 1 + Nat$$




<anchor>row_decompose</anchor>

#### Разложение в ряд


<anchor>type_derivatives</anchor>

#### Производные от типов

[Haskell/Zippers](https://en.m.wikibooks.org/wiki/Haskell/Zippers#Mechanical_Differentiation)
[Pdf: The Derivative of a Regular Type is its Type of One-Hole Contexts](http://strictlypositive.org/diff.pdf)
[Abusing the algebra of algebraic data types - why does this work?](https://stackoverflow.com/questions/9190352/abusing-the-algebra-of-algebraic-data-types-why-does-this-work)
[Arxiv: Objects of Categories as Complex Numbers](https://arxiv.org/abs/math/0212377v1)


<anchor>conclusion</anchor>

#### Заключение
