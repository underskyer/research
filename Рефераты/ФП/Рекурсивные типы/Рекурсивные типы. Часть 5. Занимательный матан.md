
<anchor>nat_numbers</anchor>

#### Натуральные числа

```scala
type Nat = μ[Option]

given liftOption: Lift[Option] =
  [A, B] => (f: A => B) => (_: Option[A]).map(f)
```
Конструкторы:
```scala
val zero:          Nat = inFix[μ, Option](None   )
def succ(n:Nat):   Nat = inFix[μ, Option](Some(n))
val one:           Nat = succ(zero)
def toNat(i: Int): Nat = (1 to i).foldRight(zero)((_, acc) => succ(acc))
```

```scala
extension (nat: Nat)
  def toInt        = foldFix[μ]((_: Option[Int]).fold(0   )(_ + 1  ))(nat)
  def +(over: Nat) = foldFix[μ]((_: Option[Nat]).fold(nat )(succ   ))(over)
  def *(over: Nat) = foldFix[μ]((_: Option[Nat]).fold(zero)(_ + nat))(over)
  def ^(over: Nat) = foldFix[μ]((_: Option[Nat]).fold(one)(_ * nat))(over)

((toNat(2) * toNat(3)) ^ toNat(2) + toNat(6)).toInt // 42
```



<anchor>row_decompose</anchor>

#### Разложение в ряд

Ранее список был выражен через неподвижную точку  конструктора типов `OptCell`:
$$
\begin{align}
OptCell[A][X] &\cong 1 + A \times X,\\
List[A] &= \mu[OptCell[A]]\\
\end{align}
$$

При этом `μ` определялся в стиле передачи продолжений, чтобы скрыть «ссылку на себя». Но давайте теперь посмотрим на чуть более привычное определение списка:
$$
List[A] = 1 + A \times List[A]\\
$$

Это не что иное, как функциональное уравнение для «функции» `List[A]`. Выражение справа можно попробовать раскрыть, шаг за шагом подставляя вместо `List[A]` всё выражение целиком. У нас будет получаться такая бесконечная сумма:
$$
List[A] = 1 + A + A \times A + A \times A \times A + \ldots = \sum_{n=0}^\infty A^n\\
$$

Трактуется эта сумма очевидно: список – это либо пустой список, либо один элемент, либо их пара, тройка и т.д. Выглядит, как сумма членов геометрической прогрессии, для которой можно применить известную формулу:
$$
List[A] = \frac1{1 - A}\\
$$

Точно такой же результат получается, если напрямую решить исходное функциональное уравнение. Оказывается, типы можно не только складывать и перемножать но и делить и вычитать!

Ну почти)). Точнее, можем, конечно, но об этом поговорим как-нибудь в другой раз. Здесь же такие выражения следует трактовать именно в смысле их разложения в [ряд Тейлора](https://ru.wikipedia.org/wiki/%D0%A0%D1%8F%D0%B4_%D0%A2%D0%B5%D0%B9%D0%BB%D0%BE%D1%80%D0%B0), как будто считая, что $A < 1$. На самом деле, это достаточно распространённый приём в математике. Да, при этом нужно учитывать всякие нюансы, вроде того, что в общем случае произведение типов не коммутирует… И всё же эти выражения можно комбинировать друг с другом и даже упрощать, получая в итоге разложения в новые ряды.

И такие выражения появляются не только при работе со списками. К примеру, обычное бинарное дерево представляется следующим функциональным уравнением:
$$
Tree[A] = 1 + A \times Tree[A] \times Tree[A]\\
$$

Его «решением» является такой ряд:
$$
Tree[A] = \frac{1-\sqrt{1-4A}}{2A} = 1 + A + 2 A^2 + 5 A^3 + 14 A^4 + \ldots\\
$$

«Числовые» (это всё типы!) коэффициенты перед $A^n$ показывают, сколько существуют различных «форм» деревьев, содержащих $n$ элементов $A$. Например, в случае двух элементов, один оказывается в корне (или на вершине, смотря как смотреть))), а другой может быть слева или справа – всего два варианта. Тогда как разных форм деревьев из четырёх элементов наберётся целых четырнадцать.

> Второе решение, со знаком $+$ перед корнем из дискриминанта оказывается непродуктивным. Разложение подразумевает «малость» $A$, но при $A \rightarrow 0$ решение устремляется в «бесконечность», и сложно понять, как использовать получаемый ряд: $1/A - 1 - A - 2 A^2 - 5 A^3 + \ldots$

Неподвижные точки любых полиномиальных конструкторов типов («алгебраические» типы, состоящие из сумм произведений) представляют собой различные деревья. Вырожденными случаями таких деревьев являются и списки, и даже натуральные числа:
$$Nat \cong List[Unit]$$

Функциональное уравнение для натуральных чисел выглядит просто
$$Nat = 1 + Nat$$

Тип не параметризирован, и единственное решение уравнения – бесконечность)).

Если построить дерево с пятью или более ветвями в узле, то точное решение для соответствующего функционального уравнения [не удастся получить](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%90%D0%B1%D0%B5%D0%BB%D1%8F_%D0%BE_%D0%BD%D0%B5%D1%80%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8_%D1%83%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9_%D0%B2_%D1%80%D0%B0%D0%B4%D0%B8%D0%BA%D0%B0%D0%BB%D0%B0%D1%85). Тем не менее, разложение в ряд интерпретируется также просто, как и в случае бинарного дерева. И всё же, не все полиномиальные рекурсивные типы приводят к полезным разложениям в ряд. Рассмотрим такой тип:
$$
\begin{eqnarray}
UMagma[A] &=& 1 + UMagma[A] \times UMagma[A] + A\\
UMagma[A] &=& \frac12 \left(1 \pm \sqrt{-4 A - 3}\right)\\
\end{eqnarray}
$$
При попытке разложения его в ряд выясняется, что все его коэффициенты бесконечны! Другими словами, для любого заданного наперёд количества элементов $A$ существует бесконечное множество различных подходящего форм дерева такой структуры. Причём, сам по себе тип корректный и не бесполезный:
```scala
final case class UMagma[A](value: A Either Option((UMagma[A], UMagma[A])))

val someTree = UMagma(Right(Some(( //       /\
  UMagma(Left(42)),                //     42  \
  UMagma(Right(None))              //          ∅
))))

val sameTree = UMagma(Right(Some(( //       /\
  UMagma(Left(42)),                //     42  \
  UMagma(Right(Some((              //         /\
    UMagma(Right(None)),           //        ∅  \   // вот откуда возникают
    UMagma(Right(None))            //            ∅  // все эти бесконечноти 
  ))))
))))
```

##### Разложение экспоненциала




<anchor>type_derivatives</anchor>

#### Производные от типов

[Haskell/Zippers](https://en.m.wikibooks.org/wiki/Haskell/Zippers#Mechanical_Differentiation)
[Pdf: The Derivative of a Regular Type is its Type of One-Hole Contexts](http://strictlypositive.org/diff.pdf)
[Abusing the algebra of algebraic data types - why does this work?](https://stackoverflow.com/questions/9190352/abusing-the-algebra-of-algebraic-data-types-why-does-this-work)
[Arxiv: Objects of Categories as Complex Numbers](https://arxiv.org/abs/math/0212377v1)


<anchor>conclusion</anchor>

#### Заключение
